# Mall-Go 第三周缓存优化技术方案设计文档

**文档版本**: v1.0  
**创建日期**: 2025-01-10  
**项目**: Mall-Go 电商系统性能优化  
**阶段**: 第三周 - 缓存优化

## 📋 **项目背景**

### **第二周成果回顾**

基于第二周并发安全优化的完美成果：

- ✅ 并发安全性：四大核心场景 100%成功率
- ✅ 性能指标：QPS 1000-2500，稳定超过基准
- ✅ 系统稳定性：50 并发用户下完全稳定
- ✅ 数据一致性：100%，零超卖现象

### **第三周优化目标**

在保持并发安全的基础上，通过 Redis 缓存层优化：

- 🎯 **查询响应时间**：从平均 50ms 降低到 5ms 以下
- 🎯 **缓存命中率**：核心业务场景达到 90%以上
- 🎯 **系统 QPS**：从 2500 提升到 10000+
- 🎯 **用户体验**：页面加载时间减少 80%

## 🏗️ **Redis 缓存架构设计**

### **1. 缓存层架构**

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Web Layer     │    │   Cache Layer   │    │  Database Layer │
│                 │    │                 │    │                 │
│ ┌─────────────┐ │    │ ┌─────────────┐ │    │ ┌─────────────┐ │
│ │ Controllers │ │───▶│ │ Redis Cache │ │───▶│ │   MySQL     │ │
│ └─────────────┘ │    │ └─────────────┘ │    │ └─────────────┘ │
│                 │    │                 │    │                 │
│ ┌─────────────┐ │    │ ┌─────────────┐ │    │ ┌─────────────┐ │
│ │ Services    │ │───▶│ │ Cache Mgr   │ │───▶│ │ GORM ORM    │ │
│ └─────────────┘ │    │ └─────────────┘ │    │ └─────────────┘ │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### **2. 缓存策略设计**

#### **Cache-Aside 模式（主要策略）**

```go
// 读取流程
func GetProduct(id uint) (*Product, error) {
    // 1. 先查缓存
    if product := cache.Get("product:" + id); product != nil {
        return product, nil
    }

    // 2. 缓存未命中，查数据库
    product, err := db.GetProduct(id)
    if err != nil {
        return nil, err
    }

    // 3. 写入缓存
    cache.Set("product:" + id, product, 30*time.Minute)
    return product, nil
}

// 更新流程
func UpdateProduct(product *Product) error {
    // 1. 更新数据库
    err := db.UpdateProduct(product)
    if err != nil {
        return err
    }

    // 2. 删除缓存（让下次读取时重新加载）
    cache.Delete("product:" + product.ID)
    return nil
}
```

#### **Write-Through 模式（关键数据）**

```go
// 用于库存等关键数据，确保强一致性
func UpdateStock(productID uint, quantity int) error {
    // 1. 同时更新数据库和缓存
    err := db.UpdateStock(productID, quantity)
    if err != nil {
        return err
    }

    // 2. 立即更新缓存
    cache.Set("stock:" + productID, quantity, 10*time.Minute)
    return nil
}
```

### **3. 数据结构设计**

#### **商品信息缓存**

```go
// 商品基础信息 - Hash结构
Key: "product:{id}"
Fields: {
    "name": "商品名称",
    "price": "99.99",
    "description": "商品描述",
    "category_id": "1",
    "status": "active",
    "created_at": "2025-01-10T10:00:00Z"
}
TTL: 30分钟

// 商品库存 - String结构（高频更新）
Key: "stock:{id}"
Value: "100"
TTL: 10分钟

// 商品价格 - String结构（可能频繁变动）
Key: "price:{id}"
Value: "99.99"
TTL: 15分钟
```

#### **用户会话缓存**

```go
// 用户登录状态 - Hash结构
Key: "user:session:{token}"
Fields: {
    "user_id": "123",
    "username": "user123",
    "role": "customer",
    "login_time": "2025-01-10T10:00:00Z",
    "last_active": "2025-01-10T10:30:00Z"
}
TTL: 2小时

// 购物车数据 - List结构
Key: "cart:{user_id}"
Value: [
    {"product_id": 1, "quantity": 2, "price": "99.99"},
    {"product_id": 2, "quantity": 1, "price": "199.99"}
]
TTL: 24小时
```

#### **热点数据缓存**

```go
// 热门商品列表 - ZSet结构（按销量排序）
Key: "hot:products"
Members: {
    "product:1": 1000,  // 销量作为score
    "product:2": 800,
    "product:3": 600
}
TTL: 1小时

// 分类商品列表 - List结构
Key: "category:{id}:products"
Value: ["product:1", "product:2", "product:3"]
TTL: 30分钟
```

### **4. 缓存键命名规范**

```go
// 命名规范
const (
    // 商品相关
    ProductInfoKey    = "product:{id}"           // 商品基础信息
    ProductStockKey   = "stock:{id}"             // 商品库存
    ProductPriceKey   = "price:{id}"             // 商品价格

    // 用户相关
    UserSessionKey    = "user:session:{token}"   // 用户会话
    UserCartKey       = "cart:{user_id}"         // 购物车
    UserProfileKey    = "user:profile:{id}"      // 用户资料

    // 业务相关
    CategoryProductsKey = "category:{id}:products" // 分类商品
    HotProductsKey     = "hot:products"            // 热门商品
    OrderKey          = "order:{id}"               // 订单信息

    // 统计相关
    ProductViewKey    = "stats:view:{id}"        // 商品浏览量
    DailyStatsKey     = "stats:daily:{date}"     // 日统计
)
```

### **5. 过期策略设计**

#### **TTL 设置策略**

```go
var CacheTTL = map[string]time.Duration{
    // 基础数据 - 较长TTL
    "product":     30 * time.Minute,  // 商品信息
    "category":    60 * time.Minute,  // 分类信息
    "user":        120 * time.Minute, // 用户资料

    // 动态数据 - 较短TTL
    "stock":       10 * time.Minute,  // 库存数据
    "price":       15 * time.Minute,  // 价格信息
    "cart":        24 * time.Hour,    // 购物车

    // 会话数据 - 中等TTL
    "session":     2 * time.Hour,     // 用户会话
    "token":       30 * time.Minute,  // 访问令牌

    // 统计数据 - 短TTL
    "stats":       5 * time.Minute,   // 实时统计
    "hot":         60 * time.Minute,  // 热点数据
}
```

#### **缓存预热策略**

```go
// 系统启动时预热关键数据
func WarmupCache() error {
    // 1. 预热热门商品
    hotProducts, err := db.GetHotProducts(100)
    if err != nil {
        return err
    }
    for _, product := range hotProducts {
        cache.Set(ProductInfoKey(product.ID), product, CacheTTL["product"])
    }

    // 2. 预热分类数据
    categories, err := db.GetAllCategories()
    if err != nil {
        return err
    }
    for _, category := range categories {
        cache.Set(CategoryKey(category.ID), category, CacheTTL["category"])
    }

    return nil
}
```

## 🔗 **与并发安全机制集成**

### **1. 乐观锁与缓存结合**

```go
// 库存扣减时的缓存更新
func DeductStockWithCache(productID uint, quantity int) error {
    // 1. 使用乐观锁更新数据库（保持第二周的并发安全机制）
    err := productService.DeductStockWithOptimisticLock(productID, quantity)
    if err != nil {
        return err
    }

    // 2. 更新缓存中的库存
    stockKey := fmt.Sprintf("stock:%d", productID)
    newStock, err := db.GetProductStock(productID)
    if err != nil {
        // 缓存更新失败不影响主流程，记录日志
        log.Errorf("Failed to update stock cache: %v", err)
        return nil
    }

    cache.Set(stockKey, newStock, CacheTTL["stock"])
    return nil
}
```

### **2. 分布式锁防止缓存击穿**

```go
// 防止热点数据缓存击穿
func GetProductWithLock(id uint) (*Product, error) {
    cacheKey := fmt.Sprintf("product:%d", id)
    lockKey := fmt.Sprintf("lock:product:%d", id)

    // 1. 先查缓存
    if product := cache.Get(cacheKey); product != nil {
        return product, nil
    }

    // 2. 获取分布式锁
    lock, err := redis.SetNX(lockKey, "1", 10*time.Second)
    if err != nil || !lock {
        // 获取锁失败，等待后重试
        time.Sleep(50 * time.Millisecond)
        return GetProductWithLock(id) // 递归重试
    }

    defer redis.Del(lockKey) // 释放锁

    // 3. 双重检查缓存
    if product := cache.Get(cacheKey); product != nil {
        return product, nil
    }

    // 4. 查询数据库并更新缓存
    product, err := db.GetProduct(id)
    if err != nil {
        return nil, err
    }

    cache.Set(cacheKey, product, CacheTTL["product"])
    return product, nil
}
```

## 📊 **性能目标与验收标准**

### **第三周验收标准**

| 指标             | 当前值 | 目标值  | 验证方法 |
| ---------------- | ------ | ------- | -------- |
| 商品查询响应时间 | 50ms   | ≤5ms    | 压力测试 |
| 缓存命中率       | 0%     | ≥90%    | 监控统计 |
| 系统 QPS         | 2,500  | ≥10,000 | 并发测试 |
| 页面加载时间     | 500ms  | ≤100ms  | 前端测试 |
| 数据库查询减少   | 0%     | ≥80%    | 监控对比 |

### **关键性能指标**

```go
type CacheMetrics struct {
    HitRate        float64 `json:"hit_rate"`        // 缓存命中率
    MissRate       float64 `json:"miss_rate"`       // 缓存未命中率
    AvgResponseTime time.Duration `json:"avg_response_time"` // 平均响应时间
    QPS            int     `json:"qps"`             // 每秒查询数
    CacheSize      int64   `json:"cache_size"`      // 缓存大小
    MemoryUsage    int64   `json:"memory_usage"`    // 内存使用量
}
```

## 🛠️ **技术实现要点**

### **1. Redis 连接池配置**

```go
type RedisConfig struct {
    Host         string `yaml:"host"`
    Port         int    `yaml:"port"`
    Password     string `yaml:"password"`
    DB           int    `yaml:"db"`
    PoolSize     int    `yaml:"pool_size"`
    MinIdleConns int    `yaml:"min_idle_conns"`
    MaxRetries   int    `yaml:"max_retries"`
    DialTimeout  time.Duration `yaml:"dial_timeout"`
    ReadTimeout  time.Duration `yaml:"read_timeout"`
    WriteTimeout time.Duration `yaml:"write_timeout"`
}
```

### **2. 缓存管理器接口**

```go
type CacheManager interface {
    Get(key string) (interface{}, error)
    Set(key string, value interface{}, ttl time.Duration) error
    Delete(key string) error
    Exists(key string) bool
    Expire(key string, ttl time.Duration) error

    // 批量操作
    MGet(keys []string) ([]interface{}, error)
    MSet(pairs map[string]interface{}, ttl time.Duration) error

    // 统计信息
    GetMetrics() *CacheMetrics
}
```

### **3. 缓存一致性保证**

```go
// 事务性缓存更新
func UpdateProductWithCache(product *Product) error {
    // 1. 开启数据库事务
    tx := db.Begin()
    defer func() {
        if r := recover(); r != nil {
            tx.Rollback()
        }
    }()

    // 2. 更新数据库
    if err := tx.UpdateProduct(product); err != nil {
        tx.Rollback()
        return err
    }

    // 3. 提交事务
    if err := tx.Commit(); err != nil {
        return err
    }

    // 4. 更新缓存（异步，失败不影响主流程）
    go func() {
        cacheKey := fmt.Sprintf("product:%d", product.ID)
        if err := cache.Set(cacheKey, product, CacheTTL["product"]); err != nil {
            log.Errorf("Failed to update cache: %v", err)
        }
    }()

    return nil
}
```

## 🔍 **监控与运维**

### **1. 缓存监控指标**

- 缓存命中率/未命中率
- 平均响应时间
- QPS 统计
- 内存使用情况
- 连接池状态
- 错误率统计

### **2. 告警策略**

- 缓存命中率 < 80%
- 响应时间 > 10ms
- 内存使用率 > 80%
- 连接池耗尽
- 错误率 > 1%

### **3. 运维工具**

- 缓存数据查看工具
- 缓存清理工具
- 性能分析工具
- 监控面板

## 📝 **详细开发计划**

### **阶段 1：Redis 基础架构搭建（预计 2 天）**

**任务 1.1：Redis 连接配置实现**

- 验收标准：连接池正常工作，支持并发连接
- 完成时间：0.5 天
- 依赖关系：无

**任务 1.2：缓存管理器接口设计**

- 验收标准：接口设计完整，支持基础 CRUD 和批量操作
- 完成时间：0.5 天
- 依赖关系：依赖 1.1

**任务 1.3：缓存键管理工具**

- 验收标准：键命名规范实现，TTL 管理正常
- 完成时间：1 天
- 依赖关系：依赖 1.2

### **阶段 2：商品信息缓存实现（预计 3 天）**

**任务 2.1：商品基础信息缓存**

- 验收标准：商品详情缓存命中率>90%，响应时间<5ms
- 完成时间：1 天
- 依赖关系：依赖阶段 1 完成

**任务 2.2：商品库存缓存**

- 验收标准：与乐观锁机制完美集成，数据一致性 100%
- 完成时间：1 天
- 依赖关系：依赖 2.1，需要集成第二周乐观锁

**任务 2.3：商品价格缓存**

- 验收标准：价格更新实时同步，支持促销价格
- 完成时间：0.5 天
- 依赖关系：依赖 2.2

**任务 2.4：分类商品列表缓存**

- 验收标准：分类列表查询响应时间<3ms
- 完成时间：0.5 天
- 依赖关系：依赖 2.3

### **阶段 3：用户会话缓存优化（预计 2 天）**

**任务 3.1：用户登录状态缓存**

- 验收标准：JWT 验证响应时间<2ms
- 完成时间：0.5 天
- 依赖关系：依赖阶段 2 完成

**任务 3.2：购物车数据缓存**

- 验收标准：购物车操作响应时间<3ms，数据实时同步
- 完成时间：1 天
- 依赖关系：依赖 3.1

**任务 3.3：用户偏好缓存**

- 验收标准：个性化推荐响应时间<5ms
- 完成时间：0.5 天
- 依赖关系：依赖 3.2

### **阶段 4：缓存一致性与性能优化（预计 2 天）**

**任务 4.1：缓存一致性机制**

- 验收标准：缓存与数据库数据一致性 100%
- 完成时间：0.5 天
- 依赖关系：依赖阶段 3 完成

**任务 4.2：缓存预热功能**

- 验收标准：系统启动后热点数据预加载完成
- 完成时间：0.5 天
- 依赖关系：依赖 4.1

**任务 4.3：防缓存击穿机制**

- 验收标准：高并发下无缓存击穿现象
- 完成时间：0.5 天
- 依赖关系：依赖 4.2

**任务 4.4：缓存监控与统计**

- 验收标准：实时监控缓存命中率、响应时间等指标
- 完成时间：0.5 天
- 依赖关系：依赖 4.3

### **阶段 5：性能测试与验证（预计 2 天）**

**任务 5.1：缓存功能测试**

- 验收标准：所有缓存功能正常，无数据丢失
- 完成时间：0.5 天
- 依赖关系：依赖阶段 4 完成

**任务 5.2：缓存性能测试**

- 验收标准：达到所有性能目标指标
- 完成时间：0.5 天
- 依赖关系：依赖 5.1

**任务 5.3：并发安全验证**

- 验收标准：缓存与第二周乐观锁机制完美集成
- 完成时间：0.5 天
- 依赖关系：依赖 5.2

**任务 5.4：压力测试验证**

- 验收标准：系统 QPS 达到 10000+，响应时间<5ms
- 完成时间：0.5 天
- 依赖关系：依赖 5.3

### **📊 第三周具体目标**

**基于第二周 100%验收标准达标的基础上：**

| 性能指标         | 第二周基线 | 第三周目标 | 提升幅度 | 验证方法           |
| ---------------- | ---------- | ---------- | -------- | ------------------ |
| 商品查询响应时间 | 50ms       | ≤5ms       | 90%↓     | 压力测试 1000 并发 |
| 缓存命中率       | 0%         | ≥90%       | +90%     | 监控统计 24 小时   |
| 系统 QPS         | 2,500      | ≥10,000    | 300%↑    | 并发测试验证       |
| 页面加载时间     | 500ms      | ≤100ms     | 80%↓     | 前端性能测试       |
| 数据库查询减少   | 0%         | ≥80%       | +80%     | 监控对比分析       |
| 内存使用效率     | -          | ≤512MB     | -        | Redis 监控         |

### **🎯 关键里程碑**

**里程碑 1（第 2 天）**：基础架构完成

- Redis 连接池正常工作
- 缓存管理器接口实现
- 基础工具类开发完成

**里程碑 2（第 5 天）**：核心缓存功能完成

- 商品信息缓存实现
- 用户会话缓存实现
- 基础性能指标达标

**里程碑 3（第 7 天）**：高级功能完成

- 缓存一致性机制实现
- 防击穿机制实现
- 监控系统完善

**里程碑 4（第 9 天）**：性能验证完成

- 所有验收标准达标
- 压力测试通过
- 系统整体性能提升验证

### **🔄 与第二周集成要点**

1. **乐观锁机制保持**：缓存层不影响第二周的并发安全机制
2. **数据一致性**：缓存更新与乐观锁更新同步进行
3. **性能叠加**：缓存优化 + 并发安全 = 双重性能提升
4. **测试兼容**：第二周的并发测试框架继续有效

**总计：9 天完成，比原计划提前 3 天**

---

**文档状态**: ✅ 已完成
**下一步**: 等待确认后开始阶段 1 开发工作
