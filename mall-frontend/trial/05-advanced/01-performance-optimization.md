# ç¬¬1ç« ï¼šå‰ç«¯æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ âš¡

> _"æ€§èƒ½ä¸æ˜¯åŠŸèƒ½ï¼Œè€Œæ˜¯ç”¨æˆ·ä½“éªŒçš„åŸºç¡€ï¼"_ ğŸš€

## ğŸ“š æœ¬ç« å¯¼è§ˆ

å‰ç«¯æ€§èƒ½ä¼˜åŒ–æ˜¯ç°ä»£Webå¼€å‘çš„æ ¸å¿ƒæŠ€èƒ½ä¹‹ä¸€ã€‚éšç€ç”¨æˆ·å¯¹ä½“éªŒè¦æ±‚çš„ä¸æ–­æé«˜ï¼Œä»¥åŠç§»åŠ¨è®¾å¤‡å’Œç½‘ç»œç¯å¢ƒçš„å¤šæ ·åŒ–ï¼Œæ€§èƒ½ä¼˜åŒ–å·²ç»ä»"é”¦ä¸Šæ·»èŠ±"å˜æˆäº†"å¿…å¤‡æŠ€èƒ½"ã€‚æœ¬ç« å°†ä»æ€§èƒ½ä¼˜åŒ–çš„åŸºç¡€ç†è®ºå‡ºå‘ï¼Œæ·±å…¥æ¢è®¨å„ç§ä¼˜åŒ–æŠ€æœ¯å’Œç­–ç•¥ï¼Œç»“åˆMall-Frontendé¡¹ç›®çš„å®é™…æ¡ˆä¾‹ï¼Œæä¾›å®Œæ•´çš„æ€§èƒ½ä¼˜åŒ–è§£å†³æ–¹æ¡ˆã€‚

### ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œä½ å°†æŒæ¡ï¼š

- **æ€§èƒ½æŒ‡æ ‡ä½“ç³»** - ç†è§£Core Web Vitalså’Œæ€§èƒ½æµ‹é‡æ–¹æ³•
- **åŠ è½½æ€§èƒ½ä¼˜åŒ–** - æŒæ¡èµ„æºåŠ è½½å’Œé¦–å±ä¼˜åŒ–æŠ€æœ¯
- **è¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–** - å­¦ä¼šReactæ€§èƒ½ä¼˜åŒ–å’Œå†…å­˜ç®¡ç†
- **ç½‘ç»œæ€§èƒ½ä¼˜åŒ–** - ç†è§£HTTPç¼“å­˜å’ŒCDNä¼˜åŒ–ç­–ç•¥
- **æ„å»ºä¼˜åŒ–** - æŒæ¡Webpack/Viteçš„æ„å»ºä¼˜åŒ–æŠ€å·§
- **å›¾åƒä¼˜åŒ–** - å­¦ä¼šç°ä»£å›¾åƒæ ¼å¼å’Œæ‡’åŠ è½½æŠ€æœ¯
- **ç›‘æ§ä¸åˆ†æ** - æ„å»ºå®Œæ•´çš„æ€§èƒ½ç›‘æ§ä½“ç³»
- **ç§»åŠ¨ç«¯ä¼˜åŒ–** - æŒæ¡ç§»åŠ¨è®¾å¤‡çš„ç‰¹æ®Šä¼˜åŒ–ç­–ç•¥

### ğŸ› ï¸ æŠ€æœ¯æ ˆæ¦‚è§ˆ

```typescript
{
  "performanceOptimization": {
    "metrics": ["Core Web Vitals", "FCP", "LCP", "FID", "CLS", "TTFB"],
    "tools": ["Lighthouse", "WebPageTest", "Chrome DevTools", "Performance API"],
    "bundling": ["Webpack", "Vite", "Rollup", "Parcel", "esbuild"],
    "caching": ["Service Worker", "HTTP Cache", "CDN", "Browser Cache"]
  },
  "monitoring": {
    "realUserMonitoring": ["Google Analytics", "New Relic", "DataDog"],
    "syntheticMonitoring": ["Lighthouse CI", "SpeedCurve", "Pingdom"],
    "errorTracking": ["Sentry", "LogRocket", "Bugsnag"],
    "analytics": ["Google PageSpeed Insights", "GTmetrix", "WebPageTest"]
  },
  "optimization": {
    "images": ["WebP", "AVIF", "Lazy Loading", "Responsive Images"],
    "fonts": ["Font Display", "Preload", "Subset", "Variable Fonts"],
    "javascript": ["Code Splitting", "Tree Shaking", "Minification", "Compression"],
    "css": ["Critical CSS", "CSS Modules", "Purge CSS", "Atomic CSS"]
  }
}
```

### ğŸ“– æœ¬ç« ç›®å½•

- [æ€§èƒ½æŒ‡æ ‡ä¸æµ‹é‡](#æ€§èƒ½æŒ‡æ ‡ä¸æµ‹é‡)
- [åŠ è½½æ€§èƒ½ä¼˜åŒ–](#åŠ è½½æ€§èƒ½ä¼˜åŒ–)
- [è¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–](#è¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–)
- [ç½‘ç»œæ€§èƒ½ä¼˜åŒ–](#ç½‘ç»œæ€§èƒ½ä¼˜åŒ–)
- [æ„å»ºä¼˜åŒ–ç­–ç•¥](#æ„å»ºä¼˜åŒ–ç­–ç•¥)
- [å›¾åƒä¸åª’ä½“ä¼˜åŒ–](#å›¾åƒä¸åª’ä½“ä¼˜åŒ–)
- [å­—ä½“ä¼˜åŒ–](#å­—ä½“ä¼˜åŒ–)
- [CSSæ€§èƒ½ä¼˜åŒ–](#cssæ€§èƒ½ä¼˜åŒ–)
- [JavaScriptæ€§èƒ½ä¼˜åŒ–](#javascriptæ€§èƒ½ä¼˜åŒ–)
- [ç§»åŠ¨ç«¯æ€§èƒ½ä¼˜åŒ–](#ç§»åŠ¨ç«¯æ€§èƒ½ä¼˜åŒ–)
- [æ€§èƒ½ç›‘æ§ä½“ç³»](#æ€§èƒ½ç›‘æ§ä½“ç³»)
- [Mall-Frontendæ€§èƒ½ä¼˜åŒ–å®è·µ](#mall-frontendæ€§èƒ½ä¼˜åŒ–å®è·µ)
- [é¢è¯•å¸¸è€ƒçŸ¥è¯†ç‚¹](#é¢è¯•å¸¸è€ƒçŸ¥è¯†ç‚¹)
- [å®æˆ˜ç»ƒä¹ ](#å®æˆ˜ç»ƒä¹ )

---

## ğŸ“Š æ€§èƒ½æŒ‡æ ‡ä¸æµ‹é‡

### Core Web Vitalsæ ¸å¿ƒæŒ‡æ ‡

Googleçš„Core Web Vitalsæ˜¯è¡¡é‡ç”¨æˆ·ä½“éªŒçš„å…³é”®æŒ‡æ ‡ï¼š

```typescript
// Core Web VitalsæŒ‡æ ‡å®šä¹‰
interface CoreWebVitals {
  // æœ€å¤§å†…å®¹ç»˜åˆ¶ (Largest Contentful Paint)
  LCP: {
    description: 'é¡µé¢ä¸»è¦å†…å®¹åŠ è½½å®Œæˆçš„æ—¶é—´';
    goodThreshold: 'â‰¤ 2.5ç§’';
    needsImprovement: '2.5ç§’ - 4.0ç§’';
    poor: '> 4.0ç§’';
    optimization: [
      'ä¼˜åŒ–æœåŠ¡å™¨å“åº”æ—¶é—´',
      'æ¶ˆé™¤é˜»å¡æ¸²æŸ“çš„èµ„æº',
      'ä¼˜åŒ–CSSå’ŒJavaScript',
      'ä½¿ç”¨CDNåŠ é€Ÿèµ„æºåŠ è½½',
    ];
  };

  // é¦–æ¬¡è¾“å…¥å»¶è¿Ÿ (First Input Delay)
  FID: {
    description: 'ç”¨æˆ·é¦–æ¬¡ä¸é¡µé¢äº¤äº’åˆ°æµè§ˆå™¨å“åº”çš„æ—¶é—´';
    goodThreshold: 'â‰¤ 100æ¯«ç§’';
    needsImprovement: '100æ¯«ç§’ - 300æ¯«ç§’';
    poor: '> 300æ¯«ç§’';
    optimization: [
      'å‡å°‘JavaScriptæ‰§è¡Œæ—¶é—´',
      'æ‹†åˆ†é•¿ä»»åŠ¡',
      'ä½¿ç”¨Web Workers',
      'ä¼˜åŒ–ç¬¬ä¸‰æ–¹ä»£ç ',
    ];
  };

  // ç´¯ç§¯å¸ƒå±€åç§» (Cumulative Layout Shift)
  CLS: {
    description: 'é¡µé¢ç”Ÿå‘½å‘¨æœŸå†…æ‰€æœ‰æ„å¤–å¸ƒå±€åç§»çš„ç´¯ç§¯åˆ†æ•°';
    goodThreshold: 'â‰¤ 0.1';
    needsImprovement: '0.1 - 0.25';
    poor: '> 0.25';
    optimization: [
      'ä¸ºå›¾åƒå’Œè§†é¢‘è®¾ç½®å°ºå¯¸å±æ€§',
      'é¿å…åœ¨ç°æœ‰å†…å®¹ä¸Šæ–¹æ’å…¥å†…å®¹',
      'ä½¿ç”¨transformåŠ¨ç”»è€Œéæ”¹å˜å¸ƒå±€çš„å±æ€§',
      'é¢„ç•™å¹¿å‘Šå’ŒåµŒå…¥å†…å®¹çš„ç©ºé—´',
    ];
  };
}

// å…¶ä»–é‡è¦æ€§èƒ½æŒ‡æ ‡
interface AdditionalMetrics {
  // é¦–æ¬¡å†…å®¹ç»˜åˆ¶ (First Contentful Paint)
  FCP: {
    description: 'æµè§ˆå™¨é¦–æ¬¡ç»˜åˆ¶ä»»ä½•æ–‡æœ¬ã€å›¾åƒæˆ–éç™½è‰²canvasçš„æ—¶é—´';
    goodThreshold: 'â‰¤ 1.8ç§’';
    measurement: 'Performance API';
  };

  // é¦–æ¬¡æœ‰æ„ä¹‰ç»˜åˆ¶ (First Meaningful Paint)
  FMP: {
    description: 'é¡µé¢ä¸»è¦å†…å®¹å¯¹ç”¨æˆ·å¯è§çš„æ—¶é—´';
    deprecated: true;
    replacedBy: 'LCP';
  };

  // å¯äº¤äº’æ—¶é—´ (Time to Interactive)
  TTI: {
    description: 'é¡µé¢å®Œå…¨å¯äº¤äº’çš„æ—¶é—´';
    goodThreshold: 'â‰¤ 3.8ç§’';
    factors: [
      'é¡µé¢æ˜¾ç¤ºæœ‰ç”¨å†…å®¹',
      'äº‹ä»¶å¤„ç†ç¨‹åºå·²æ³¨å†Œ',
      'é¡µé¢åœ¨50mså†…å“åº”ç”¨æˆ·äº¤äº’',
    ];
  };

  // é¦–å­—èŠ‚æ—¶é—´ (Time to First Byte)
  TTFB: {
    description: 'ä»è¯·æ±‚å¼€å§‹åˆ°æ¥æ”¶åˆ°ç¬¬ä¸€ä¸ªå­—èŠ‚çš„æ—¶é—´';
    goodThreshold: 'â‰¤ 600æ¯«ç§’';
    optimization: ['ä¼˜åŒ–æœåŠ¡å™¨é…ç½®', 'ä½¿ç”¨CDN', 'å‡å°‘é‡å®šå‘', 'å¯ç”¨HTTP/2'];
  };

  // é€Ÿåº¦æŒ‡æ•° (Speed Index)
  SI: {
    description: 'é¡µé¢å†…å®¹å¯è§å¡«å……çš„é€Ÿåº¦';
    goodThreshold: 'â‰¤ 3.4ç§’';
    calculation: 'åŸºäºè§†è§‰è¿›åº¦çš„ç§¯åˆ†';
  };
}

// æ€§èƒ½æµ‹é‡å®ç°
class PerformanceMonitor {
  private observer: PerformanceObserver | null = null;
  private metrics: Map<string, number> = new Map();

  constructor() {
    this.initializeObserver();
    this.measureCoreWebVitals();
  }

  // åˆå§‹åŒ–æ€§èƒ½è§‚å¯Ÿå™¨
  private initializeObserver(): void {
    if ('PerformanceObserver' in window) {
      this.observer = new PerformanceObserver(list => {
        for (const entry of list.getEntries()) {
          this.processPerformanceEntry(entry);
        }
      });

      // è§‚å¯Ÿå„ç§æ€§èƒ½æŒ‡æ ‡
      try {
        this.observer.observe({
          entryTypes: [
            'navigation',
            'paint',
            'largest-contentful-paint',
            'first-input',
            'layout-shift',
          ],
        });
      } catch (error) {
        console.warn('Performance Observer not fully supported:', error);
      }
    }
  }

  // å¤„ç†æ€§èƒ½æ¡ç›®
  private processPerformanceEntry(entry: PerformanceEntry): void {
    switch (entry.entryType) {
      case 'navigation':
        this.handleNavigationEntry(entry as PerformanceNavigationTiming);
        break;
      case 'paint':
        this.handlePaintEntry(entry as PerformancePaintTiming);
        break;
      case 'largest-contentful-paint':
        this.handleLCPEntry(entry as any);
        break;
      case 'first-input':
        this.handleFIDEntry(entry as any);
        break;
      case 'layout-shift':
        this.handleCLSEntry(entry as any);
        break;
    }
  }

  // å¤„ç†å¯¼èˆªæ€§èƒ½
  private handleNavigationEntry(entry: PerformanceNavigationTiming): void {
    const ttfb = entry.responseStart - entry.requestStart;
    const domContentLoaded =
      entry.domContentLoadedEventEnd - entry.navigationStart;
    const loadComplete = entry.loadEventEnd - entry.navigationStart;

    this.metrics.set('TTFB', ttfb);
    this.metrics.set('DOMContentLoaded', domContentLoaded);
    this.metrics.set('LoadComplete', loadComplete);

    this.reportMetric('TTFB', ttfb);
    this.reportMetric('DOMContentLoaded', domContentLoaded);
    this.reportMetric('LoadComplete', loadComplete);
  }

  // å¤„ç†ç»˜åˆ¶æ€§èƒ½
  private handlePaintEntry(entry: PerformancePaintTiming): void {
    const value = entry.startTime;
    this.metrics.set(entry.name, value);

    if (entry.name === 'first-contentful-paint') {
      this.reportMetric('FCP', value);
    }
  }

  // å¤„ç†LCP
  private handleLCPEntry(entry: any): void {
    const lcp = entry.startTime;
    this.metrics.set('LCP', lcp);
    this.reportMetric('LCP', lcp);
  }

  // å¤„ç†FID
  private handleFIDEntry(entry: any): void {
    const fid = entry.processingStart - entry.startTime;
    this.metrics.set('FID', fid);
    this.reportMetric('FID', fid);
  }

  // å¤„ç†CLS
  private handleCLSEntry(entry: any): void {
    if (!entry.hadRecentInput) {
      const currentCLS = this.metrics.get('CLS') || 0;
      const newCLS = currentCLS + entry.value;
      this.metrics.set('CLS', newCLS);
      this.reportMetric('CLS', newCLS);
    }
  }

  // æµ‹é‡Core Web Vitals
  private measureCoreWebVitals(): void {
    // ä½¿ç”¨web-vitalsåº“è¿›è¡Œç²¾ç¡®æµ‹é‡
    if (typeof window !== 'undefined') {
      import('web-vitals').then(
        ({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
          getCLS(this.onCLS.bind(this));
          getFID(this.onFID.bind(this));
          getFCP(this.onFCP.bind(this));
          getLCP(this.onLCP.bind(this));
          getTTFB(this.onTTFB.bind(this));
        }
      );
    }
  }

  // Core Web Vitalså›è°ƒå‡½æ•°
  private onCLS(metric: any): void {
    this.reportMetric('CLS', metric.value);
  }

  private onFID(metric: any): void {
    this.reportMetric('FID', metric.value);
  }

  private onFCP(metric: any): void {
    this.reportMetric('FCP', metric.value);
  }

  private onLCP(metric: any): void {
    this.reportMetric('LCP', metric.value);
  }

  private onTTFB(metric: any): void {
    this.reportMetric('TTFB', metric.value);
  }

  // ä¸ŠæŠ¥æ€§èƒ½æŒ‡æ ‡
  private reportMetric(name: string, value: number): void {
    // å‘é€åˆ°åˆ†ææœåŠ¡
    if (typeof gtag !== 'undefined') {
      gtag('event', name, {
        event_category: 'Web Vitals',
        value: Math.round(value),
        non_interaction: true,
      });
    }

    // å‘é€åˆ°è‡ªå®šä¹‰åˆ†ææœåŠ¡
    this.sendToAnalytics(name, value);
  }

  // å‘é€åˆ°åˆ†ææœåŠ¡
  private sendToAnalytics(name: string, value: number): void {
    fetch('/api/analytics/performance', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        metric: name,
        value: value,
        timestamp: Date.now(),
        url: window.location.href,
        userAgent: navigator.userAgent,
      }),
    }).catch(error => {
      console.warn('Failed to send performance metric:', error);
    });
  }

  // è·å–æ‰€æœ‰æŒ‡æ ‡
  public getMetrics(): Map<string, number> {
    return new Map(this.metrics);
  }

  // é”€æ¯ç›‘æ§å™¨
  public destroy(): void {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const performanceMonitor = new PerformanceMonitor();

// åœ¨åº”ç”¨å¸è½½æ—¶æ¸…ç†
window.addEventListener('beforeunload', () => {
  performanceMonitor.destroy();
});
```

---

## ğŸš€ åŠ è½½æ€§èƒ½ä¼˜åŒ–

### èµ„æºåŠ è½½ä¼˜åŒ–ç­–ç•¥

```typescript
// èµ„æºåŠ è½½ä¼˜åŒ–é…ç½®
const loadingOptimization = {
  // 1. å…³é”®èµ„æºä¼˜åŒ–
  criticalResources: {
    // å…³é”®CSSå†…è”
    inlineCriticalCSS: {
      description: 'å°†é¦–å±CSSå†…è”åˆ°HTMLä¸­',
      implementation: `
        <!-- å†…è”å…³é”®CSS -->
        <style>
          /* é¦–å±æ ·å¼ */
          .header { background: #fff; height: 60px; }
          .hero { min-height: 400px; background: #f5f5f5; }
          .loading { display: flex; justify-content: center; }
        </style>

        <!-- å¼‚æ­¥åŠ è½½éå…³é”®CSS -->
        <link rel="preload" href="/css/non-critical.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/css/non-critical.css"></noscript>
      `,
      tools: ['Critical', 'Critters', 'PurgeCSS'],
    },

    // èµ„æºé¢„åŠ è½½
    resourcePreloading: {
      description: 'é¢„åŠ è½½å…³é”®èµ„æº',
      strategies: {
        preload: {
          usage: 'é¢„åŠ è½½å½“å‰é¡µé¢éœ€è¦çš„å…³é”®èµ„æº',
          example: `
            <!-- é¢„åŠ è½½å…³é”®å­—ä½“ -->
            <link rel="preload" href="/fonts/inter.woff2" as="font" type="font/woff2" crossorigin>

            <!-- é¢„åŠ è½½å…³é”®å›¾ç‰‡ -->
            <link rel="preload" href="/images/hero.webp" as="image">

            <!-- é¢„åŠ è½½å…³é”®è„šæœ¬ -->
            <link rel="preload" href="/js/critical.js" as="script">
          `,
        },

        prefetch: {
          usage: 'é¢„è·å–ä¸‹ä¸€é¡µé¢å¯èƒ½éœ€è¦çš„èµ„æº',
          example: `
            <!-- é¢„è·å–ä¸‹ä¸€é¡µé¢çš„èµ„æº -->
            <link rel="prefetch" href="/js/product-detail.js">
            <link rel="prefetch" href="/css/product-detail.css">

            <!-- é¢„è·å–APIæ•°æ® -->
            <link rel="prefetch" href="/api/products/trending">
          `,
        },

        preconnect: {
          usage: 'é¢„è¿æ¥åˆ°å¤–éƒ¨åŸŸå',
          example: `
            <!-- é¢„è¿æ¥åˆ°CDN -->
            <link rel="preconnect" href="https://cdn.example.com">

            <!-- é¢„è¿æ¥åˆ°å­—ä½“æœåŠ¡ -->
            <link rel="preconnect" href="https://fonts.googleapis.com">
            <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
          `,
        },
      },
    },
  },

  // 2. ä»£ç åˆ†å‰²ç­–ç•¥
  codeSplitting: {
    // è·¯ç”±çº§åˆ†å‰²
    routeBasedSplitting: {
      description: 'æŒ‰è·¯ç”±æ‹†åˆ†ä»£ç ',
      implementation: `
        // React Router + Lazy Loading
        import { lazy, Suspense } from 'react';
        import { Routes, Route } from 'react-router-dom';

        // æ‡’åŠ è½½é¡µé¢ç»„ä»¶
        const HomePage = lazy(() => import('./pages/HomePage'));
        const ProductPage = lazy(() => import('./pages/ProductPage'));
        const CartPage = lazy(() => import('./pages/CartPage'));
        const CheckoutPage = lazy(() => import('./pages/CheckoutPage'));

        // åŠ è½½ä¸­ç»„ä»¶
        const PageLoader = () => (
          <div className="page-loader">
            <div className="spinner" />
            <p>æ­£åœ¨åŠ è½½é¡µé¢...</p>
          </div>
        );

        const App = () => (
          <Suspense fallback={<PageLoader />}>
            <Routes>
              <Route path="/" element={<HomePage />} />
              <Route path="/products/*" element={<ProductPage />} />
              <Route path="/cart" element={<CartPage />} />
              <Route path="/checkout" element={<CheckoutPage />} />
            </Routes>
          </Suspense>
        );
      `,
    },

    // ç»„ä»¶çº§åˆ†å‰²
    componentBasedSplitting: {
      description: 'æŒ‰ç»„ä»¶æ‹†åˆ†ä»£ç ',
      implementation: `
        // æ‡’åŠ è½½é‡å‹ç»„ä»¶
        const HeavyChart = lazy(() => import('./components/HeavyChart'));
        const VideoPlayer = lazy(() => import('./components/VideoPlayer'));
        const RichTextEditor = lazy(() => import('./components/RichTextEditor'));

        // æ¡ä»¶æ‡’åŠ è½½
        const ConditionalComponent = ({ showChart }) => {
          const [ChartComponent, setChartComponent] = useState(null);

          useEffect(() => {
            if (showChart && !ChartComponent) {
              import('./components/HeavyChart').then(module => {
                setChartComponent(() => module.default);
              });
            }
          }, [showChart, ChartComponent]);

          return (
            <div>
              {showChart && ChartComponent && (
                <Suspense fallback={<div>åŠ è½½å›¾è¡¨ä¸­...</div>}>
                  <ChartComponent />
                </Suspense>
              )}
            </div>
          );
        };
      `,
    },

    // ç¬¬ä¸‰æ–¹åº“åˆ†å‰²
    vendorSplitting: {
      description: 'åˆ†ç¦»ç¬¬ä¸‰æ–¹åº“ä»£ç ',
      webpackConfig: `
        // webpack.config.js
        module.exports = {
          optimization: {
            splitChunks: {
              chunks: 'all',
              cacheGroups: {
                // Reactç›¸å…³åº“
                react: {
                  test: /[\\/]node_modules[\\/](react|react-dom|react-router)[\\/]/,
                  name: 'react',
                  chunks: 'all',
                },

                // UIåº“
                ui: {
                  test: /[\\/]node_modules[\\/](@mui|antd|@chakra-ui)[\\/]/,
                  name: 'ui',
                  chunks: 'all',
                },

                // å·¥å…·åº“
                utils: {
                  test: /[\\/]node_modules[\\/](lodash|moment|date-fns)[\\/]/,
                  name: 'utils',
                  chunks: 'all',
                },

                // å…¶ä»–ç¬¬ä¸‰æ–¹åº“
                vendor: {
                  test: /[\\/]node_modules[\\/]/,
                  name: 'vendor',
                  chunks: 'all',
                  priority: -10,
                },
              },
            },
          },
        };
      `,
    },
  },

  // 3. æ‡’åŠ è½½å®ç°
  lazyLoading: {
    // å›¾ç‰‡æ‡’åŠ è½½
    imageLazyLoading: {
      description: 'å»¶è¿ŸåŠ è½½å›¾ç‰‡èµ„æº',
      implementation: `
        // ä½¿ç”¨Intersection Observerå®ç°å›¾ç‰‡æ‡’åŠ è½½
        const LazyImage = ({ src, alt, className, ...props }) => {
          const [imageSrc, setImageSrc] = useState('');
          const [isLoaded, setIsLoaded] = useState(false);
          const imgRef = useRef(null);

          useEffect(() => {
            const observer = new IntersectionObserver(
              (entries) => {
                entries.forEach(entry => {
                  if (entry.isIntersecting) {
                    setImageSrc(src);
                    observer.unobserve(entry.target);
                  }
                });
              },
              { threshold: 0.1 }
            );

            if (imgRef.current) {
              observer.observe(imgRef.current);
            }

            return () => observer.disconnect();
          }, [src]);

          return (
            <div ref={imgRef} className={className}>
              {imageSrc && (
                <img
                  src={imageSrc}
                  alt={alt}
                  onLoad={() => setIsLoaded(true)}
                  style={{
                    opacity: isLoaded ? 1 : 0,
                    transition: 'opacity 0.3s ease'
                  }}
                  {...props}
                />
              )}
              {!isLoaded && (
                <div className="image-placeholder">
                  <div className="skeleton" />
                </div>
              )}
            </div>
          );
        };

        // ä½¿ç”¨ç°ä»£æµè§ˆå™¨çš„loadingå±æ€§
        const ModernLazyImage = ({ src, alt, ...props }) => (
          <img
            src={src}
            alt={alt}
            loading="lazy"
            decoding="async"
            {...props}
          />
        );
      `,
    },

    // å†…å®¹æ‡’åŠ è½½
    contentLazyLoading: {
      description: 'å»¶è¿ŸåŠ è½½é¡µé¢å†…å®¹',
      implementation: `
        // è™šæ‹Ÿæ»šåŠ¨å®ç°
        const VirtualList = ({ items, itemHeight, containerHeight }) => {
          const [scrollTop, setScrollTop] = useState(0);
          const containerRef = useRef(null);

          // è®¡ç®—å¯è§èŒƒå›´
          const startIndex = Math.floor(scrollTop / itemHeight);
          const endIndex = Math.min(
            startIndex + Math.ceil(containerHeight / itemHeight) + 1,
            items.length
          );

          const visibleItems = items.slice(startIndex, endIndex);

          const handleScroll = (e) => {
            setScrollTop(e.target.scrollTop);
          };

          return (
            <div
              ref={containerRef}
              style={{ height: containerHeight, overflow: 'auto' }}
              onScroll={handleScroll}
            >
              <div style={{ height: items.length * itemHeight, position: 'relative' }}>
                {visibleItems.map((item, index) => (
                  <div
                    key={startIndex + index}
                    style={{
                      position: 'absolute',
                      top: (startIndex + index) * itemHeight,
                      height: itemHeight,
                      width: '100%'
                    }}
                  >
                    <ItemComponent item={item} />
                  </div>
                ))}
              </div>
            </div>
          );
        };
      `,
    },
  },

  // 4. Service Workerç¼“å­˜
  serviceWorkerCaching: {
    description: 'ä½¿ç”¨Service Workerå®ç°ç¦»çº¿ç¼“å­˜',
    implementation: `
      // sw.js - Service Worker
      const CACHE_NAME = 'mall-frontend-v1';
      const STATIC_ASSETS = [
        '/',
        '/static/css/main.css',
        '/static/js/main.js',
        '/manifest.json'
      ];

      // å®‰è£…äº‹ä»¶ - ç¼“å­˜é™æ€èµ„æº
      self.addEventListener('install', (event) => {
        event.waitUntil(
          caches.open(CACHE_NAME)
            .then(cache => cache.addAll(STATIC_ASSETS))
            .then(() => self.skipWaiting())
        );
      });

      // æ¿€æ´»äº‹ä»¶ - æ¸…ç†æ—§ç¼“å­˜
      self.addEventListener('activate', (event) => {
        event.waitUntil(
          caches.keys().then(cacheNames => {
            return Promise.all(
              cacheNames
                .filter(cacheName => cacheName !== CACHE_NAME)
                .map(cacheName => caches.delete(cacheName))
            );
          }).then(() => self.clients.claim())
        );
      });

      // æ‹¦æˆªè¯·æ±‚ - ç¼“å­˜ç­–ç•¥
      self.addEventListener('fetch', (event) => {
        const { request } = event;

        // é™æ€èµ„æºï¼šç¼“å­˜ä¼˜å…ˆ
        if (request.destination === 'script' || request.destination === 'style') {
          event.respondWith(
            caches.match(request).then(response => {
              return response || fetch(request).then(fetchResponse => {
                const responseClone = fetchResponse.clone();
                caches.open(CACHE_NAME).then(cache => {
                  cache.put(request, responseClone);
                });
                return fetchResponse;
              });
            })
          );
        }

        // APIè¯·æ±‚ï¼šç½‘ç»œä¼˜å…ˆ
        else if (request.url.includes('/api/')) {
          event.respondWith(
            fetch(request).then(response => {
              const responseClone = response.clone();
              caches.open(CACHE_NAME).then(cache => {
                cache.put(request, responseClone);
              });
              return response;
            }).catch(() => {
              return caches.match(request);
            })
          );
        }

        // å…¶ä»–è¯·æ±‚ï¼šé»˜è®¤å¤„ç†
        else {
          event.respondWith(
            caches.match(request).then(response => {
              return response || fetch(request);
            })
          );
        }
      });
    `,
  },
};
```

---

## âš¡ è¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–

### Reactæ€§èƒ½ä¼˜åŒ–ç­–ç•¥

```typescript
// Reactæ€§èƒ½ä¼˜åŒ–æŠ€æœ¯
const reactPerformanceOptimization = {
  // 1. ç»„ä»¶ä¼˜åŒ–
  componentOptimization: {
    // React.memoä¼˜åŒ–
    memoization: {
      description: 'ä½¿ç”¨React.memoé˜²æ­¢ä¸å¿…è¦çš„é‡æ¸²æŸ“',
      implementation: `
        // åŸºç¡€memoä½¿ç”¨
        const ProductCard = React.memo(({ product, onAddToCart }) => {
          return (
            <div className="product-card">
              <img src={product.image} alt={product.name} />
              <h3>{product.name}</h3>
              <p>{product.price}</p>
              <button onClick={() => onAddToCart(product)}>
                åŠ å…¥è´­ç‰©è½¦
              </button>
            </div>
          );
        });

        // è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°
        const ProductCardOptimized = React.memo(({ product, onAddToCart }) => {
          // ç»„ä»¶å®ç°
        }, (prevProps, nextProps) => {
          // è‡ªå®šä¹‰æ¯”è¾ƒé€»è¾‘
          return (
            prevProps.product.id === nextProps.product.id &&
            prevProps.product.price === nextProps.product.price &&
            prevProps.product.name === nextProps.product.name
          );
        });

        // ä½¿ç”¨useMemoä¼˜åŒ–å¤æ‚è®¡ç®—
        const ProductList = ({ products, filters }) => {
          const filteredProducts = useMemo(() => {
            return products.filter(product => {
              return Object.entries(filters).every(([key, value]) => {
                if (!value) return true;
                return product[key] === value;
              });
            }).sort((a, b) => {
              // å¤æ‚æ’åºé€»è¾‘
              return a.price - b.price;
            });
          }, [products, filters]);

          return (
            <div className="product-list">
              {filteredProducts.map(product => (
                <ProductCard key={product.id} product={product} />
              ))}
            </div>
          );
        };
      `,
    },

    // useCallbackä¼˜åŒ–
    callbackOptimization: {
      description: 'ä½¿ç”¨useCallbackä¼˜åŒ–äº‹ä»¶å¤„ç†å‡½æ•°',
      implementation: `
        const ProductManager = () => {
          const [products, setProducts] = useState([]);
          const [selectedCategory, setSelectedCategory] = useState('');

          // ä¼˜åŒ–äº‹ä»¶å¤„ç†å‡½æ•°
          const handleAddToCart = useCallback((product) => {
            // æ·»åŠ åˆ°è´­ç‰©è½¦çš„é€»è¾‘
            addToCart(product);

            // å‘é€åˆ†æäº‹ä»¶
            analytics.track('add_to_cart', {
              product_id: product.id,
              product_name: product.name,
              price: product.price
            });
          }, []); // ç©ºä¾èµ–æ•°ç»„ï¼Œå‡½æ•°ä¸ä¼šé‡æ–°åˆ›å»º

          const handleCategoryChange = useCallback((category) => {
            setSelectedCategory(category);

            // å‘é€åˆ†æäº‹ä»¶
            analytics.track('category_filter', {
              category: category
            });
          }, []); // ç©ºä¾èµ–æ•°ç»„

          const handleProductUpdate = useCallback((productId, updates) => {
            setProducts(prevProducts =>
              prevProducts.map(product =>
                product.id === productId
                  ? { ...product, ...updates }
                  : product
              )
            );
          }, []); // ä½¿ç”¨å‡½æ•°å¼æ›´æ–°ï¼Œæ— éœ€ä¾èµ–products

          return (
            <div>
              <CategoryFilter
                selectedCategory={selectedCategory}
                onCategoryChange={handleCategoryChange}
              />
              <ProductList
                products={products}
                onAddToCart={handleAddToCart}
                onProductUpdate={handleProductUpdate}
              />
            </div>
          );
        };
      `,
    },

    // çŠ¶æ€ä¼˜åŒ–
    stateOptimization: {
      description: 'ä¼˜åŒ–çŠ¶æ€ç®¡ç†å‡å°‘é‡æ¸²æŸ“',
      implementation: `
        // çŠ¶æ€åˆ†ç¦» - é¿å…å•ä¸€å¤§çŠ¶æ€å¯¹è±¡
        const useProductState = () => {
          const [products, setProducts] = useState([]);
          const [loading, setLoading] = useState(false);
          const [error, setError] = useState(null);

          return {
            products,
            setProducts,
            loading,
            setLoading,
            error,
            setError
          };
        };

        const useUIState = () => {
          const [selectedCategory, setSelectedCategory] = useState('');
          const [sortBy, setSortBy] = useState('name');
          const [viewMode, setViewMode] = useState('grid');

          return {
            selectedCategory,
            setSelectedCategory,
            sortBy,
            setSortBy,
            viewMode,
            setViewMode
          };
        };

        // ä½¿ç”¨useReducerç®¡ç†å¤æ‚çŠ¶æ€
        const cartReducer = (state, action) => {
          switch (action.type) {
            case 'ADD_ITEM':
              const existingItem = state.items.find(item => item.id === action.payload.id);
              if (existingItem) {
                return {
                  ...state,
                  items: state.items.map(item =>
                    item.id === action.payload.id
                      ? { ...item, quantity: item.quantity + 1 }
                      : item
                  )
                };
              }
              return {
                ...state,
                items: [...state.items, { ...action.payload, quantity: 1 }]
              };

            case 'REMOVE_ITEM':
              return {
                ...state,
                items: state.items.filter(item => item.id !== action.payload.id)
              };

            case 'UPDATE_QUANTITY':
              return {
                ...state,
                items: state.items.map(item =>
                  item.id === action.payload.id
                    ? { ...item, quantity: action.payload.quantity }
                    : item
                )
              };

            default:
              return state;
          }
        };

        const useCart = () => {
          const [state, dispatch] = useReducer(cartReducer, {
            items: [],
            total: 0
          });

          // è®¡ç®—æ€»ä»·
          const total = useMemo(() => {
            return state.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
          }, [state.items]);

          return {
            ...state,
            total,
            dispatch
          };
        };
      `,
    },
  },

  // 2. åˆ—è¡¨ä¼˜åŒ–
  listOptimization: {
    // è™šæ‹Ÿæ»šåŠ¨
    virtualScrolling: {
      description: 'å¤§åˆ—è¡¨è™šæ‹Ÿæ»šåŠ¨ä¼˜åŒ–',
      implementation: `
        // è‡ªå®šä¹‰è™šæ‹Ÿæ»šåŠ¨Hook
        const useVirtualScroll = ({
          items,
          itemHeight,
          containerHeight,
          overscan = 5
        }) => {
          const [scrollTop, setScrollTop] = useState(0);

          const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - overscan);
          const endIndex = Math.min(
            items.length,
            Math.ceil((scrollTop + containerHeight) / itemHeight) + overscan
          );

          const visibleItems = items.slice(startIndex, endIndex);
          const totalHeight = items.length * itemHeight;
          const offsetY = startIndex * itemHeight;

          return {
            visibleItems,
            totalHeight,
            offsetY,
            startIndex,
            endIndex,
            setScrollTop
          };
        };

        // è™šæ‹Ÿæ»šåŠ¨ç»„ä»¶
        const VirtualProductList = ({ products }) => {
          const containerRef = useRef(null);
          const [containerHeight, setContainerHeight] = useState(600);

          const {
            visibleItems,
            totalHeight,
            offsetY,
            setScrollTop
          } = useVirtualScroll({
            items: products,
            itemHeight: 120,
            containerHeight
          });

          const handleScroll = useCallback((e) => {
            setScrollTop(e.target.scrollTop);
          }, [setScrollTop]);

          useEffect(() => {
            const updateHeight = () => {
              if (containerRef.current) {
                setContainerHeight(containerRef.current.clientHeight);
              }
            };

            updateHeight();
            window.addEventListener('resize', updateHeight);
            return () => window.removeEventListener('resize', updateHeight);
          }, []);

          return (
            <div
              ref={containerRef}
              className="virtual-list-container"
              style={{ height: '100%', overflow: 'auto' }}
              onScroll={handleScroll}
            >
              <div style={{ height: totalHeight, position: 'relative' }}>
                <div
                  style={{
                    transform: \`translateY(\${offsetY}px)\`,
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    right: 0
                  }}
                >
                  {visibleItems.map((product, index) => (
                    <ProductCard
                      key={product.id}
                      product={product}
                      style={{ height: 120 }}
                    />
                  ))}
                </div>
              </div>
            </div>
          );
        };
      `,
    },

    // åˆ†é¡µå’Œæ— é™æ»šåŠ¨
    infiniteScrolling: {
      description: 'æ— é™æ»šåŠ¨å®ç°',
      implementation: `
        // æ— é™æ»šåŠ¨Hook
        const useInfiniteScroll = (fetchMore) => {
          const [isFetching, setIsFetching] = useState(false);

          useEffect(() => {
            const handleScroll = () => {
              if (window.innerHeight + document.documentElement.scrollTop !== document.documentElement.offsetHeight || isFetching) return;
              setIsFetching(true);
            };

            window.addEventListener('scroll', handleScroll);
            return () => window.removeEventListener('scroll', handleScroll);
          }, [isFetching]);

          useEffect(() => {
            if (!isFetching) return;
            fetchMoreData();
          }, [isFetching]);

          const fetchMoreData = async () => {
            await fetchMore();
            setIsFetching(false);
          };

          return [isFetching, setIsFetching];
        };

        // æ— é™æ»šåŠ¨äº§å“åˆ—è¡¨
        const InfiniteProductList = () => {
          const [products, setProducts] = useState([]);
          const [hasMore, setHasMore] = useState(true);
          const [page, setPage] = useState(1);

          const fetchMoreProducts = useCallback(async () => {
            try {
              const response = await fetch(\`/api/products?page=\${page}&limit=20\`);
              const newProducts = await response.json();

              if (newProducts.length === 0) {
                setHasMore(false);
              } else {
                setProducts(prev => [...prev, ...newProducts]);
                setPage(prev => prev + 1);
              }
            } catch (error) {
              console.error('Failed to fetch products:', error);
            }
          }, [page]);

          const [isFetching] = useInfiniteScroll(fetchMoreProducts);

          return (
            <div>
              <div className="product-grid">
                {products.map(product => (
                  <ProductCard key={product.id} product={product} />
                ))}
              </div>

              {isFetching && hasMore && (
                <div className="loading-indicator">
                  <div className="spinner" />
                  <p>åŠ è½½æ›´å¤šäº§å“...</p>
                </div>
              )}

              {!hasMore && (
                <div className="end-indicator">
                  <p>å·²åŠ è½½å…¨éƒ¨äº§å“</p>
                </div>
              )}
            </div>
          );
        };
      `,
    },
  },
};
```

---

## ğŸ¯ é¢è¯•å¸¸è€ƒçŸ¥è¯†ç‚¹

### 1. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

**Q: å‰ç«¯æ€§èƒ½ä¼˜åŒ–æœ‰å“ªäº›ä¸»è¦ç­–ç•¥ï¼Ÿ**

**A: å‰ç«¯æ€§èƒ½ä¼˜åŒ–ç­–ç•¥åˆ†ç±»ï¼š**

```typescript
// æ€§èƒ½ä¼˜åŒ–ç­–ç•¥åˆ†ç±»
const performanceOptimizationStrategies = {
  // åŠ è½½æ—¶æ€§èƒ½ä¼˜åŒ–
  loadingPerformance: {
    strategies: [
      'å‡å°‘HTTPè¯·æ±‚æ•°é‡',
      'å‹ç¼©å’Œåˆå¹¶èµ„æº',
      'ä½¿ç”¨CDNåŠ é€Ÿ',
      'å¯ç”¨æµè§ˆå™¨ç¼“å­˜',
      'ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½',
      'å…³é”®èµ„æºä¼˜å…ˆåŠ è½½',
      'é¢„åŠ è½½å’Œé¢„è·å–',
    ],

    techniques: {
      bundleOptimization: {
        description: 'æ‰“åŒ…ä¼˜åŒ–',
        methods: [
          'Tree Shakingç§»é™¤æ— ç”¨ä»£ç ',
          'Code SplittingæŒ‰éœ€åŠ è½½',
          'Vendor Splittingåˆ†ç¦»ç¬¬ä¸‰æ–¹åº“',
          'Dynamic ImportåŠ¨æ€å¯¼å…¥',
        ],
      },

      resourceOptimization: {
        description: 'èµ„æºä¼˜åŒ–',
        methods: [
          'å›¾ç‰‡å‹ç¼©å’Œæ ¼å¼ä¼˜åŒ–',
          'CSSå’ŒJSå‹ç¼©æ··æ·†',
          'Gzip/Brotliå‹ç¼©',
          'å­—ä½“ä¼˜åŒ–å’Œå­é›†åŒ–',
        ],
      },

      cacheOptimization: {
        description: 'ç¼“å­˜ä¼˜åŒ–',
        methods: [
          'HTTPç¼“å­˜ç­–ç•¥',
          'Service Workerç¼“å­˜',
          'CDNç¼“å­˜',
          'æµè§ˆå™¨ç¼“å­˜',
        ],
      },
    },
  },

  // è¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–
  runtimePerformance: {
    strategies: [
      'å‡å°‘DOMæ“ä½œ',
      'ä¼˜åŒ–é‡æ’å’Œé‡ç»˜',
      'ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨',
      'é˜²æŠ–å’ŒèŠ‚æµ',
      'å†…å­˜æ³„æ¼é˜²æŠ¤',
      'é•¿ä»»åŠ¡æ‹†åˆ†',
      'Web Workersä½¿ç”¨',
    ],

    reactOptimization: {
      description: 'Reactæ€§èƒ½ä¼˜åŒ–',
      methods: [
        'React.memoé˜²æ­¢ä¸å¿…è¦é‡æ¸²æŸ“',
        'useMemoç¼“å­˜è®¡ç®—ç»“æœ',
        'useCallbackç¼“å­˜å‡½æ•°å¼•ç”¨',
        'çŠ¶æ€æå‡å’Œä¸‹æ²‰',
        'ç»„ä»¶æ‡’åŠ è½½',
        'Contextä¼˜åŒ–',
      ],
    },
  },

  // æ„ŸçŸ¥æ€§èƒ½ä¼˜åŒ–
  perceivedPerformance: {
    strategies: [
      'éª¨æ¶å±æ˜¾ç¤º',
      'æ¸è¿›å¼åŠ è½½',
      'ä¼˜åŒ–åŠ¨ç”»æ€§èƒ½',
      'å‡å°‘å¸ƒå±€åç§»',
      'ä¼˜åŒ–å­—ä½“åŠ è½½',
      'é¢„åŠ è½½å…³é”®èµ„æº',
    ],
  },
};
```

### 2. Core Web Vitalsä¼˜åŒ–

**Q: å¦‚ä½•ä¼˜åŒ–Core Web VitalsæŒ‡æ ‡ï¼Ÿ**

**A: Core Web Vitalsä¼˜åŒ–æ–¹æ³•ï¼š**

```typescript
const coreWebVitalsOptimization = {
  // LCPä¼˜åŒ–
  LCP: {
    targetMetric: 'â‰¤ 2.5ç§’',
    optimizationMethods: [
      'ä¼˜åŒ–æœåŠ¡å™¨å“åº”æ—¶é—´',
      'ç§»é™¤é˜»å¡æ¸²æŸ“çš„èµ„æº',
      'ä¼˜åŒ–CSSåŠ è½½',
      'é¢„åŠ è½½å…³é”®èµ„æº',
      'ä½¿ç”¨CDN',
      'å‹ç¼©å›¾ç‰‡å’Œæ–‡æœ¬',
    ],

    implementation: `
      // é¢„åŠ è½½LCPå…ƒç´ 
      <link rel="preload" href="/images/hero.webp" as="image">

      // ä¼˜åŒ–å…³é”®CSS
      <style>
        /* å†…è”å…³é”®CSS */
        .hero { background-image: url('/images/hero.webp'); }
      </style>

      // å¼‚æ­¥åŠ è½½éå…³é”®CSS
      <link rel="preload" href="/css/non-critical.css" as="style"
            onload="this.onload=null;this.rel='stylesheet'">
    `,
  },

  // FIDä¼˜åŒ–
  FID: {
    targetMetric: 'â‰¤ 100æ¯«ç§’',
    optimizationMethods: [
      'å‡å°‘JavaScriptæ‰§è¡Œæ—¶é—´',
      'æ‹†åˆ†é•¿ä»»åŠ¡',
      'ç§»é™¤æ— ç”¨ä»£ç ',
      'ä½¿ç”¨Web Workers',
      'ä¼˜åŒ–ç¬¬ä¸‰æ–¹è„šæœ¬',
      'å»¶è¿Ÿéå…³é”®JavaScript',
    ],

    implementation: `
      // æ‹†åˆ†é•¿ä»»åŠ¡
      function processLargeArray(array) {
        return new Promise(resolve => {
          const batchSize = 1000;
          let index = 0;

          function processBatch() {
            const endIndex = Math.min(index + batchSize, array.length);

            for (let i = index; i < endIndex; i++) {
              // å¤„ç†æ•°ç»„é¡¹
              processItem(array[i]);
            }

            index = endIndex;

            if (index < array.length) {
              // è®©å‡ºä¸»çº¿ç¨‹
              setTimeout(processBatch, 0);
            } else {
              resolve();
            }
          }

          processBatch();
        });
      }

      // ä½¿ç”¨Web Workers
      const worker = new Worker('/js/heavy-computation.js');
      worker.postMessage(data);
      worker.onmessage = (e) => {
        updateUI(e.data);
      };
    `,
  },

  // CLSä¼˜åŒ–
  CLS: {
    targetMetric: 'â‰¤ 0.1',
    optimizationMethods: [
      'ä¸ºå›¾ç‰‡å’Œè§†é¢‘è®¾ç½®å°ºå¯¸',
      'é¢„ç•™å¹¿å‘Šç©ºé—´',
      'é¿å…åœ¨ç°æœ‰å†…å®¹ä¸Šæ–¹æ’å…¥å†…å®¹',
      'ä½¿ç”¨transformåŠ¨ç”»',
      'ä¼˜åŒ–å­—ä½“åŠ è½½',
      'é¿å…æ— å°ºå¯¸å…ƒç´ ',
    ],

    implementation: `
      <!-- ä¸ºå›¾ç‰‡è®¾ç½®å°ºå¯¸ -->
      <img src="/image.jpg" width="400" height="300" alt="Product">

      <!-- ä½¿ç”¨aspect-ratio -->
      <div style="aspect-ratio: 16/9;">
        <img src="/image.jpg" alt="Product" style="width: 100%; height: 100%;">
      </div>

      <!-- é¢„ç•™å¹¿å‘Šç©ºé—´ -->
      <div class="ad-container" style="min-height: 250px;">
        <!-- å¹¿å‘Šå†…å®¹ -->
      </div>

      <!-- ä½¿ç”¨transformåŠ¨ç”»è€Œéæ”¹å˜å¸ƒå±€ -->
      .slide-in {
        transform: translateX(-100%);
        transition: transform 0.3s ease;
      }

      .slide-in.active {
        transform: translateX(0);
      }
    `,
  },
};
```

---

## ğŸ“š å®æˆ˜ç»ƒä¹ 

### ç»ƒä¹ 1ï¼šæ€§èƒ½ç›‘æ§ç³»ç»Ÿ

**ä»»åŠ¡**: ä¸ºMall-Frontendæ„å»ºå®Œæ•´çš„æ€§èƒ½ç›‘æ§ç³»ç»Ÿã€‚

**è¦æ±‚**:

- ç›‘æ§Core Web VitalsæŒ‡æ ‡
- å®ç°Real User Monitoring
- æ„å»ºæ€§èƒ½æ•°æ®åˆ†æé¢æ¿
- è®¾ç½®æ€§èƒ½é¢„è­¦æœºåˆ¶

### ç»ƒä¹ 2ï¼šåŠ è½½æ€§èƒ½ä¼˜åŒ–

**ä»»åŠ¡**: ä¼˜åŒ–Mall-Frontendçš„åŠ è½½æ€§èƒ½ã€‚

**è¦æ±‚**:

- å®ç°ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
- ä¼˜åŒ–å›¾ç‰‡å’Œå­—ä½“åŠ è½½
- é…ç½®Service Workerç¼“å­˜
- ä¼˜åŒ–é¦–å±åŠ è½½æ—¶é—´

### ç»ƒä¹ 3ï¼šè¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–

**ä»»åŠ¡**: ä¼˜åŒ–Mall-Frontendçš„è¿è¡Œæ—¶æ€§èƒ½ã€‚

**è¦æ±‚**:

- å®ç°è™šæ‹Ÿæ»šåŠ¨
- ä¼˜åŒ–Reactç»„ä»¶æ€§èƒ½
- å¤„ç†å†…å­˜æ³„æ¼é—®é¢˜
- ä¼˜åŒ–åŠ¨ç”»æ€§èƒ½

---

## ğŸ“š æœ¬ç« æ€»ç»“

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œæˆ‘ä»¬å…¨é¢æŒæ¡äº†å‰ç«¯æ€§èƒ½ä¼˜åŒ–çš„æ ¸å¿ƒæŠ€æœ¯ï¼š

### ğŸ¯ æ ¸å¿ƒæ”¶è·

1. **æ€§èƒ½æŒ‡æ ‡ä½“ç³»ç²¾é€š** ğŸ“Š
   - æŒæ¡äº†Core Web Vitalsçš„æµ‹é‡å’Œä¼˜åŒ–
   - ç†è§£äº†æ€§èƒ½ç›‘æ§çš„å®ç°æ–¹æ³•
   - å­¦ä¼šäº†æ€§èƒ½æ•°æ®çš„åˆ†æå’Œåº”ç”¨

2. **åŠ è½½æ€§èƒ½ä¼˜åŒ–** ğŸš€
   - æŒæ¡äº†èµ„æºåŠ è½½ä¼˜åŒ–ç­–ç•¥
   - å­¦ä¼šäº†ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½æŠ€æœ¯
   - ç†è§£äº†ç¼“å­˜ç­–ç•¥å’ŒCDNä¼˜åŒ–

3. **è¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–** âš¡
   - æŒæ¡äº†Reactæ€§èƒ½ä¼˜åŒ–æŠ€å·§
   - å­¦ä¼šäº†è™šæ‹Ÿæ»šåŠ¨å’Œæ— é™æ»šåŠ¨
   - ç†è§£äº†å†…å­˜ç®¡ç†å’Œé•¿ä»»åŠ¡ä¼˜åŒ–

4. **å·¥ç¨‹åŒ–æ€§èƒ½ä¼˜åŒ–** ğŸ”§
   - æŒæ¡äº†æ„å»ºå·¥å…·çš„æ€§èƒ½ä¼˜åŒ–
   - å­¦ä¼šäº†å›¾åƒå’Œå­—ä½“ä¼˜åŒ–æŠ€æœ¯
   - ç†è§£äº†ç°ä»£æµè§ˆå™¨çš„æ€§èƒ½ç‰¹æ€§

5. **ç›‘æ§ä¸åˆ†æèƒ½åŠ›** ğŸ“ˆ
   - æŒæ¡äº†æ€§èƒ½ç›‘æ§ç³»ç»Ÿçš„æ„å»º
   - å­¦ä¼šäº†æ€§èƒ½é—®é¢˜çš„è¯Šæ–­æ–¹æ³•
   - ç†è§£äº†æ€§èƒ½ä¼˜åŒ–çš„æŒç»­æ”¹è¿›

### ğŸš€ æŠ€æœ¯è¿›é˜¶

- **ä¸‹ä¸€æ­¥å­¦ä¹ **: æµ‹è¯•ç­–ç•¥ä¸è´¨é‡ä¿è¯
- **å®è·µå»ºè®®**: åœ¨é¡¹ç›®ä¸­å»ºç«‹æ€§èƒ½ä¼˜åŒ–æµç¨‹
- **æ·±å…¥æ–¹å‘**: ç°ä»£æµè§ˆå™¨æ€§èƒ½APIå’Œä¼˜åŒ–æŠ€æœ¯

æ€§èƒ½ä¼˜åŒ–æ˜¯å‰ç«¯å¼€å‘çš„æ°¸æ’ä¸»é¢˜ï¼ŒæŒæ¡ç³»ç»Ÿæ€§çš„æ€§èƒ½ä¼˜åŒ–æ–¹æ³•æ˜¯é«˜çº§å‰ç«¯å·¥ç¨‹å¸ˆçš„å¿…å¤‡æŠ€èƒ½ï¼ ğŸ‰

---

_ä¸‹ä¸€ç« æˆ‘ä»¬å°†å­¦ä¹ ã€Šæµ‹è¯•ç­–ç•¥ä¸è´¨é‡ä¿è¯ã€‹ï¼Œæ¢ç´¢ç°ä»£å‰ç«¯åº”ç”¨çš„æµ‹è¯•ä½“ç³»ï¼_ ğŸš€

```

```
