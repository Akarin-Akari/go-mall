# ç¬¬1ç« ï¼šå‰ç«¯æ¶æ„è®¾è®¡åŸåˆ™ ğŸ—ï¸

> *"ä¼˜ç§€çš„æ¶æ„ä¸æ˜¯è®¾è®¡å‡ºæ¥çš„ï¼Œè€Œæ˜¯æ¼”è¿›å‡ºæ¥çš„ï¼"* ğŸš€

## ğŸ“š æœ¬ç« å¯¼è§ˆ

å‰ç«¯æ¶æ„è®¾è®¡æ˜¯æ„å»ºå¤§å‹ã€å¯ç»´æŠ¤ã€å¯æ‰©å±•Webåº”ç”¨çš„åŸºçŸ³ã€‚éšç€ä¸šåŠ¡å¤æ‚åº¦çš„å¢åŠ ï¼Œå¦‚ä½•è®¾è®¡ä¸€ä¸ªæ—¢èƒ½æ»¡è¶³å½“å‰éœ€æ±‚ï¼Œåˆèƒ½é€‚åº”æœªæ¥å˜åŒ–çš„å‰ç«¯æ¶æ„ï¼Œæˆä¸ºäº†æ¯ä¸ªå‰ç«¯å·¥ç¨‹å¸ˆå¿…é¡»æŒæ¡çš„æ ¸å¿ƒæŠ€èƒ½ã€‚æœ¬ç« å°†ä»æ¶æ„è®¾è®¡çš„åŸºæœ¬åŸåˆ™å‡ºå‘ï¼Œç»“åˆMall-Frontendé¡¹ç›®çš„å®é™…æ¡ˆä¾‹ï¼Œæ·±å…¥æ¢è®¨ç°ä»£å‰ç«¯æ¶æ„çš„è®¾è®¡ç†å¿µå’Œæœ€ä½³å®è·µã€‚

### ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œä½ å°†æŒæ¡ï¼š

- **æ¶æ„è®¾è®¡åŸåˆ™** - ç†è§£SOLIDã€DRYã€KISSç­‰è®¾è®¡åŸåˆ™åœ¨å‰ç«¯çš„åº”ç”¨
- **åˆ†å±‚æ¶æ„æ¨¡å¼** - æŒæ¡è¡¨ç°å±‚ã€ä¸šåŠ¡å±‚ã€æ•°æ®å±‚çš„èŒè´£åˆ’åˆ†
- **æ¨¡å—åŒ–è®¾è®¡** - å­¦ä¼šç»„ä»¶åŒ–ã€æ¨¡å—åŒ–çš„è®¾è®¡æ–¹æ³•å’Œæœ€ä½³å®è·µ
- **ä¾èµ–ç®¡ç†** - ç†è§£ä¾èµ–æ³¨å…¥ã€æ§åˆ¶åè½¬åœ¨å‰ç«¯çš„å®ç°
- **å¯æ‰©å±•æ€§è®¾è®¡** - æŒæ¡æ’ä»¶åŒ–ã€å¾®å‰ç«¯ç­‰æ‰©å±•æ€§æ¶æ„æ¨¡å¼
- **æ€§èƒ½æ¶æ„** - å­¦ä¼šä»æ¶æ„å±‚é¢ä¼˜åŒ–åº”ç”¨æ€§èƒ½
- **æ¶æ„æ¼”è¿›ç­–ç•¥** - ç†è§£æ¶æ„é‡æ„å’Œæ¸è¿›å¼å‡çº§æ–¹æ³•
- **ä¼ä¸šçº§å®è·µ** - å¤§å‹å›¢é˜Ÿçš„å‰ç«¯æ¶æ„æ²»ç†ç»éªŒ

### ğŸ› ï¸ æŠ€æœ¯æ ˆæ¦‚è§ˆ

```typescript
{
  "architecturePatterns": {
    "layered": ["Presentation", "Business", "Data", "Infrastructure"],
    "modular": ["Feature Modules", "Shared Modules", "Core Modules"],
    "component": ["Atomic Design", "Container/Presenter", "Compound Components"]
  },
  "designPrinciples": {
    "solid": ["SRP", "OCP", "LSP", "ISP", "DIP"],
    "others": ["DRY", "KISS", "YAGNI", "Composition over Inheritance"]
  },
  "scalabilityPatterns": {
    "microfrontends": ["Module Federation", "Single-SPA", "Micro Apps"],
    "plugins": ["Plugin Architecture", "Event-Driven", "Hook System"]
  },
  "tools": ["TypeScript", "ESLint", "Prettier", "Husky", "Nx", "Lerna"]
}
```

### ğŸ“– æœ¬ç« ç›®å½•

- [æ¶æ„è®¾è®¡åŸºæœ¬åŸåˆ™](#æ¶æ„è®¾è®¡åŸºæœ¬åŸåˆ™)
- [åˆ†å±‚æ¶æ„æ¨¡å¼](#åˆ†å±‚æ¶æ„æ¨¡å¼)
- [æ¨¡å—åŒ–ä¸ç»„ä»¶åŒ–è®¾è®¡](#æ¨¡å—åŒ–ä¸ç»„ä»¶åŒ–è®¾è®¡)
- [ä¾èµ–ç®¡ç†ä¸æ§åˆ¶åè½¬](#ä¾èµ–ç®¡ç†ä¸æ§åˆ¶åè½¬)
- [å¯æ‰©å±•æ€§æ¶æ„è®¾è®¡](#å¯æ‰©å±•æ€§æ¶æ„è®¾è®¡)
- [æ€§èƒ½å¯¼å‘çš„æ¶æ„è®¾è®¡](#æ€§èƒ½å¯¼å‘çš„æ¶æ„è®¾è®¡)
- [æ¶æ„æ²»ç†ä¸æ¼”è¿›](#æ¶æ„æ²»ç†ä¸æ¼”è¿›)
- [ä¼ä¸šçº§æ¶æ„å®è·µ](#ä¼ä¸šçº§æ¶æ„å®è·µ)
- [Mall-Frontendæ¶æ„åˆ†æ](#mall-frontendæ¶æ„åˆ†æ)
- [é¢è¯•å¸¸è€ƒçŸ¥è¯†ç‚¹](#é¢è¯•å¸¸è€ƒçŸ¥è¯†ç‚¹)
- [å®æˆ˜ç»ƒä¹ ](#å®æˆ˜ç»ƒä¹ )

---

## ğŸ¯ æ¶æ„è®¾è®¡åŸºæœ¬åŸåˆ™

### SOLIDåŸåˆ™åœ¨å‰ç«¯çš„åº”ç”¨

SOLIDåŸåˆ™æ˜¯é¢å‘å¯¹è±¡è®¾è®¡çš„äº”å¤§åŸºæœ¬åŸåˆ™ï¼Œåœ¨å‰ç«¯å¼€å‘ä¸­åŒæ ·å…·æœ‰é‡è¦çš„æŒ‡å¯¼æ„ä¹‰ï¼š

```typescript
// 1. å•ä¸€èŒè´£åŸåˆ™ (Single Responsibility Principle)
// âŒ è¿åSRPçš„ç»„ä»¶ - èŒè´£è¿‡å¤š
class UserProfileComponent {
  // ç”¨æˆ·æ•°æ®ç®¡ç†
  private userData: User;
  
  // UIæ¸²æŸ“
  render() { /* ... */ }
  
  // æ•°æ®éªŒè¯
  validateUserData() { /* ... */ }
  
  // APIè°ƒç”¨
  async saveUser() { /* ... */ }
  
  // æƒé™æ£€æŸ¥
  checkPermissions() { /* ... */ }
  
  // æ—¥å¿—è®°å½•
  logUserAction() { /* ... */ }
}

// âœ… éµå¾ªSRPçš„è®¾è®¡ - èŒè´£åˆ†ç¦»
// ç”¨æˆ·æ•°æ®ç®¡ç†
class UserDataManager {
  private userData: User;
  
  getUserData(): User { return this.userData; }
  setUserData(data: User): void { this.userData = data; }
}

// æ•°æ®éªŒè¯æœåŠ¡
class UserValidator {
  validate(userData: User): ValidationResult {
    // ä¸“æ³¨äºæ•°æ®éªŒè¯é€»è¾‘
    return { isValid: true, errors: [] };
  }
}

// APIæœåŠ¡
class UserApiService {
  async saveUser(userData: User): Promise<User> {
    // ä¸“æ³¨äºAPIè°ƒç”¨
    return fetch('/api/users', {
      method: 'POST',
      body: JSON.stringify(userData)
    }).then(res => res.json());
  }
}

// æƒé™æœåŠ¡
class PermissionService {
  checkUserPermission(user: User, action: string): boolean {
    // ä¸“æ³¨äºæƒé™æ£€æŸ¥é€»è¾‘
    return user.permissions.includes(action);
  }
}

// UIç»„ä»¶ - åªè´Ÿè´£æ¸²æŸ“
function UserProfileComponent({ 
  userManager, 
  validator, 
  apiService, 
  permissionService 
}: {
  userManager: UserDataManager;
  validator: UserValidator;
  apiService: UserApiService;
  permissionService: PermissionService;
}) {
  const [user, setUser] = useState(userManager.getUserData());
  
  const handleSave = async () => {
    const validation = validator.validate(user);
    if (validation.isValid) {
      await apiService.saveUser(user);
    }
  };
  
  return (
    <div>
      {/* ä¸“æ³¨äºUIæ¸²æŸ“ */}
      <UserForm user={user} onSave={handleSave} />
    </div>
  );
}
```

```typescript
// 2. å¼€æ”¾å°é—­åŸåˆ™ (Open/Closed Principle)
// å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å°é—­

// âŒ è¿åOCPçš„è®¾è®¡ - æ¯æ¬¡æ·»åŠ æ–°ç±»å‹éƒ½è¦ä¿®æ”¹åŸæœ‰ä»£ç 
class NotificationManager {
  sendNotification(type: string, message: string) {
    switch (type) {
      case 'email':
        this.sendEmail(message);
        break;
      case 'sms':
        this.sendSMS(message);
        break;
      case 'push':
        this.sendPush(message);
        break;
      // æ¯æ¬¡æ·»åŠ æ–°ç±»å‹éƒ½è¦ä¿®æ”¹è¿™é‡Œ
      default:
        throw new Error('Unsupported notification type');
    }
  }
  
  private sendEmail(message: string) { /* ... */ }
  private sendSMS(message: string) { /* ... */ }
  private sendPush(message: string) { /* ... */ }
}

// âœ… éµå¾ªOCPçš„è®¾è®¡ - é€šè¿‡æ¥å£æ‰©å±•
interface NotificationProvider {
  send(message: string): Promise<void>;
}

class EmailProvider implements NotificationProvider {
  async send(message: string): Promise<void> {
    // é‚®ä»¶å‘é€é€»è¾‘
    console.log('Sending email:', message);
  }
}

class SMSProvider implements NotificationProvider {
  async send(message: string): Promise<void> {
    // çŸ­ä¿¡å‘é€é€»è¾‘
    console.log('Sending SMS:', message);
  }
}

class PushProvider implements NotificationProvider {
  async send(message: string): Promise<void> {
    // æ¨é€å‘é€é€»è¾‘
    console.log('Sending push:', message);
  }
}

// æ–°å¢å¾®ä¿¡é€šçŸ¥ - æ— éœ€ä¿®æ”¹åŸæœ‰ä»£ç 
class WeChatProvider implements NotificationProvider {
  async send(message: string): Promise<void> {
    console.log('Sending WeChat:', message);
  }
}

class NotificationManager {
  private providers = new Map<string, NotificationProvider>();
  
  // æ³¨å†Œé€šçŸ¥æä¾›è€…
  registerProvider(type: string, provider: NotificationProvider) {
    this.providers.set(type, provider);
  }
  
  // å‘é€é€šçŸ¥ - æ— éœ€ä¿®æ”¹
  async sendNotification(type: string, message: string) {
    const provider = this.providers.get(type);
    if (!provider) {
      throw new Error(`No provider registered for type: ${type}`);
    }
    await provider.send(message);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const notificationManager = new NotificationManager();
notificationManager.registerProvider('email', new EmailProvider());
notificationManager.registerProvider('sms', new SMSProvider());
notificationManager.registerProvider('push', new PushProvider());
notificationManager.registerProvider('wechat', new WeChatProvider()); // æ–°å¢ç±»å‹
```

```typescript
// 3. é‡Œæ°æ›¿æ¢åŸåˆ™ (Liskov Substitution Principle)
// å­ç±»å¿…é¡»èƒ½å¤Ÿæ›¿æ¢å…¶åŸºç±»

// âŒ è¿åLSPçš„è®¾è®¡
abstract class Shape {
  abstract calculateArea(): number;
  abstract setWidth(width: number): void;
  abstract setHeight(height: number): void;
}

class Rectangle extends Shape {
  constructor(private width: number, private height: number) {
    super();
  }
  
  calculateArea(): number {
    return this.width * this.height;
  }
  
  setWidth(width: number): void {
    this.width = width;
  }
  
  setHeight(height: number): void {
    this.height = height;
  }
}

class Square extends Rectangle {
  constructor(side: number) {
    super(side, side);
  }
  
  // è¿åLSP - æ”¹å˜äº†åŸºç±»çš„è¡Œä¸º
  setWidth(width: number): void {
    this.width = width;
    this.height = width; // å¼ºåˆ¶ä¿æŒæ­£æ–¹å½¢
  }
  
  setHeight(height: number): void {
    this.width = height; // å¼ºåˆ¶ä¿æŒæ­£æ–¹å½¢
    this.height = height;
  }
}

// è¿™ä¼šå¯¼è‡´æ„å¤–çš„è¡Œä¸º
function resizeShape(shape: Rectangle) {
  shape.setWidth(5);
  shape.setHeight(4);
  // æœŸæœ›é¢ç§¯æ˜¯20ï¼Œä½†å¦‚æœæ˜¯Squareï¼Œé¢ç§¯ä¼šæ˜¯16
  console.log('Area:', shape.calculateArea());
}

// âœ… éµå¾ªLSPçš„è®¾è®¡
interface Drawable {
  draw(): void;
  calculateArea(): number;
}

class Rectangle implements Drawable {
  constructor(private width: number, private height: number) {}
  
  draw(): void {
    console.log(`Drawing rectangle: ${this.width}x${this.height}`);
  }
  
  calculateArea(): number {
    return this.width * this.height;
  }
  
  setDimensions(width: number, height: number): void {
    this.width = width;
    this.height = height;
  }
}

class Square implements Drawable {
  constructor(private side: number) {}
  
  draw(): void {
    console.log(`Drawing square: ${this.side}x${this.side}`);
  }
  
  calculateArea(): number {
    return this.side * this.side;
  }
  
  setSide(side: number): void {
    this.side = side;
  }
}

// ç°åœ¨å¯ä»¥å®‰å…¨åœ°æ›¿æ¢
function drawShapes(shapes: Drawable[]) {
  shapes.forEach(shape => {
    shape.draw();
    console.log('Area:', shape.calculateArea());
  });
}
```

```typescript
// 4. æ¥å£éš”ç¦»åŸåˆ™ (Interface Segregation Principle)
// å®¢æˆ·ç«¯ä¸åº”è¯¥ä¾èµ–å®ƒä¸éœ€è¦çš„æ¥å£

// âŒ è¿åISPçš„è®¾è®¡ - è‡ƒè‚¿çš„æ¥å£
interface Worker {
  work(): void;
  eat(): void;
  sleep(): void;
  code(): void;
  design(): void;
  test(): void;
  deploy(): void;
}

class Developer implements Worker {
  work(): void { console.log('Working...'); }
  eat(): void { console.log('Eating...'); }
  sleep(): void { console.log('Sleeping...'); }
  code(): void { console.log('Coding...'); }
  design(): void { throw new Error('Developers do not design'); } // ä¸éœ€è¦
  test(): void { console.log('Testing...'); }
  deploy(): void { console.log('Deploying...'); }
}

// âœ… éµå¾ªISPçš„è®¾è®¡ - æ¥å£åˆ†ç¦»
interface Workable {
  work(): void;
}

interface Eatable {
  eat(): void;
}

interface Sleepable {
  sleep(): void;
}

interface Codeable {
  code(): void;
}

interface Designable {
  design(): void;
}

interface Testable {
  test(): void;
}

interface Deployable {
  deploy(): void;
}

// å¼€å‘è€…åªå®ç°éœ€è¦çš„æ¥å£
class Developer implements Workable, Eatable, Sleepable, Codeable, Testable, Deployable {
  work(): void { console.log('Working...'); }
  eat(): void { console.log('Eating...'); }
  sleep(): void { console.log('Sleeping...'); }
  code(): void { console.log('Coding...'); }
  test(): void { console.log('Testing...'); }
  deploy(): void { console.log('Deploying...'); }
}

// è®¾è®¡å¸ˆåªå®ç°éœ€è¦çš„æ¥å£
class Designer implements Workable, Eatable, Sleepable, Designable {
  work(): void { console.log('Working...'); }
  eat(): void { console.log('Eating...'); }
  sleep(): void { console.log('Sleeping...'); }
  design(): void { console.log('Designing...'); }
}
```

```typescript
// 5. ä¾èµ–å€’ç½®åŸåˆ™ (Dependency Inversion Principle)
// é«˜å±‚æ¨¡å—ä¸åº”è¯¥ä¾èµ–ä½å±‚æ¨¡å—ï¼Œä¸¤è€…éƒ½åº”è¯¥ä¾èµ–æŠ½è±¡

// âŒ è¿åDIPçš„è®¾è®¡ - é«˜å±‚æ¨¡å—ä¾èµ–å…·ä½“å®ç°
class MySQLDatabase {
  save(data: any): void {
    console.log('Saving to MySQL:', data);
  }
  
  find(id: string): any {
    console.log('Finding in MySQL:', id);
    return { id, name: 'User' };
  }
}

class UserService {
  private database = new MySQLDatabase(); // ç›´æ¥ä¾èµ–å…·ä½“å®ç°
  
  createUser(userData: any): void {
    this.database.save(userData);
  }
  
  getUser(id: string): any {
    return this.database.find(id);
  }
}

// âœ… éµå¾ªDIPçš„è®¾è®¡ - ä¾èµ–æŠ½è±¡
interface Database {
  save(data: any): void;
  find(id: string): any;
}

class MySQLDatabase implements Database {
  save(data: any): void {
    console.log('Saving to MySQL:', data);
  }
  
  find(id: string): any {
    console.log('Finding in MySQL:', id);
    return { id, name: 'User' };
  }
}

class MongoDatabase implements Database {
  save(data: any): void {
    console.log('Saving to MongoDB:', data);
  }
  
  find(id: string): any {
    console.log('Finding in MongoDB:', id);
    return { id, name: 'User' };
  }
}

class UserService {
  constructor(private database: Database) {} // ä¾èµ–æŠ½è±¡
  
  createUser(userData: any): void {
    this.database.save(userData);
  }
  
  getUser(id: string): any {
    return this.database.find(id);
  }
}

// ä½¿ç”¨ä¾èµ–æ³¨å…¥
const mysqlDb = new MySQLDatabase();
const mongoDb = new MongoDatabase();

const userServiceWithMySQL = new UserService(mysqlDb);
const userServiceWithMongo = new UserService(mongoDb);
```

### å…¶ä»–é‡è¦è®¾è®¡åŸåˆ™

```typescript
// DRY (Don't Repeat Yourself) - ä¸è¦é‡å¤è‡ªå·±
// âŒ é‡å¤ä»£ç 
function validateEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

function validateUserEmail(user: User): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(user.email);
}

function validateContactEmail(contact: Contact): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(contact.email);
}

// âœ… æ¶ˆé™¤é‡å¤
class EmailValidator {
  private static readonly EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  
  static validate(email: string): boolean {
    return this.EMAIL_REGEX.test(email);
  }
}

function validateUserEmail(user: User): boolean {
  return EmailValidator.validate(user.email);
}

function validateContactEmail(contact: Contact): boolean {
  return EmailValidator.validate(contact.email);
}

// KISS (Keep It Simple, Stupid) - ä¿æŒç®€å•
// âŒ è¿‡åº¦å¤æ‚çš„è®¾è®¡
class ComplexUserManager {
  private users: Map<string, User> = new Map();
  private userFactories: Map<string, UserFactory> = new Map();
  private userValidators: Map<string, UserValidator> = new Map();
  private userTransformers: Map<string, UserTransformer> = new Map();
  
  createUser(type: string, data: any): User {
    const factory = this.userFactories.get(type);
    const validator = this.userValidators.get(type);
    const transformer = this.userTransformers.get(type);
    
    if (!factory || !validator || !transformer) {
      throw new Error('Invalid user type');
    }
    
    const transformedData = transformer.transform(data);
    const validationResult = validator.validate(transformedData);
    
    if (!validationResult.isValid) {
      throw new Error('Invalid user data');
    }
    
    return factory.create(transformedData);
  }
}

// âœ… ç®€å•ç›´æ¥çš„è®¾è®¡
class SimpleUserManager {
  private users: User[] = [];
  
  createUser(userData: UserData): User {
    if (!this.isValidUserData(userData)) {
      throw new Error('Invalid user data');
    }
    
    const user = new User(userData);
    this.users.push(user);
    return user;
  }
  
  private isValidUserData(data: UserData): boolean {
    return data.email && data.name && data.email.includes('@');
  }
}

// YAGNI (You Aren't Gonna Need It) - ä½ ä¸ä¼šéœ€è¦å®ƒ
// âŒ è¿‡åº¦è®¾è®¡ - æ·»åŠ å¯èƒ½æ°¸è¿œä¸ä¼šç”¨åˆ°çš„åŠŸèƒ½
class OverEngineeredComponent {
  // ä¸ºäº†"å°†æ¥å¯èƒ½çš„éœ€æ±‚"æ·»åŠ çš„å¤æ‚åŠŸèƒ½
  private plugins: Plugin[] = [];
  private eventBus: EventBus = new EventBus();
  private configManager: ConfigManager = new ConfigManager();
  private themeManager: ThemeManager = new ThemeManager();
  private i18nManager: I18nManager = new I18nManager();
  
  // å®é™…ä¸Šåªéœ€è¦ç®€å•çš„æ¸²æŸ“åŠŸèƒ½
  render() {
    return <div>Hello World</div>;
  }
}

// âœ… åªå®ç°å½“å‰éœ€è¦çš„åŠŸèƒ½
function SimpleComponent() {
  return <div>Hello World</div>;
}

// å½“çœŸæ­£éœ€è¦æ—¶å†æ·»åŠ åŠŸèƒ½
function EnhancedComponent({ theme, message }: { theme?: string; message: string }) {
  return <div className={theme}>{message}</div>;
}
```

---

## ğŸ—ï¸ åˆ†å±‚æ¶æ„æ¨¡å¼

### ç»å…¸ä¸‰å±‚æ¶æ„

å‰ç«¯åº”ç”¨çš„åˆ†å±‚æ¶æ„é€šå¸¸åŒ…æ‹¬è¡¨ç°å±‚ã€ä¸šåŠ¡å±‚å’Œæ•°æ®å±‚ï¼Œæ¯å±‚éƒ½æœ‰æ˜ç¡®çš„èŒè´£ï¼š

```typescript
// æ•°æ®å±‚ (Data Layer) - è´Ÿè´£æ•°æ®è·å–å’ŒæŒä¹…åŒ–
interface Repository<T> {
  findById(id: string): Promise<T | null>;
  findAll(): Promise<T[]>;
  create(entity: T): Promise<T>;
  update(id: string, entity: Partial<T>): Promise<T>;
  delete(id: string): Promise<void>;
}

class ProductRepository implements Repository<Product> {
  private apiClient: ApiClient;

  constructor(apiClient: ApiClient) {
    this.apiClient = apiClient;
  }

  async findById(id: string): Promise<Product | null> {
    try {
      return await this.apiClient.get<Product>(`/api/products/${id}`);
    } catch (error) {
      if (error.status === 404) return null;
      throw error;
    }
  }

  async findAll(): Promise<Product[]> {
    const response = await this.apiClient.get<{ data: Product[] }>('/api/products');
    return response.data;
  }

  async create(product: Product): Promise<Product> {
    return await this.apiClient.post<Product>('/api/products', product);
  }

  async update(id: string, product: Partial<Product>): Promise<Product> {
    return await this.apiClient.put<Product>(`/api/products/${id}`, product);
  }

  async delete(id: string): Promise<void> {
    await this.apiClient.delete(`/api/products/${id}`);
  }
}

class UserRepository implements Repository<User> {
  private apiClient: ApiClient;
  private cacheManager: CacheManager;

  constructor(apiClient: ApiClient, cacheManager: CacheManager) {
    this.apiClient = apiClient;
    this.cacheManager = cacheManager;
  }

  async findById(id: string): Promise<User | null> {
    // å…ˆæ£€æŸ¥ç¼“å­˜
    const cacheKey = `user:${id}`;
    const cached = await this.cacheManager.get<User>(cacheKey);
    if (cached) return cached;

    // ä»APIè·å–
    try {
      const user = await this.apiClient.get<User>(`/api/users/${id}`);
      // ç¼“å­˜ç»“æœ
      await this.cacheManager.set(cacheKey, user, { ttl: 5 * 60 * 1000 });
      return user;
    } catch (error) {
      if (error.status === 404) return null;
      throw error;
    }
  }

  async findAll(): Promise<User[]> {
    const response = await this.apiClient.get<{ data: User[] }>('/api/users');
    return response.data;
  }

  async create(user: User): Promise<User> {
    const newUser = await this.apiClient.post<User>('/api/users', user);
    // æ¸…é™¤ç›¸å…³ç¼“å­˜
    await this.cacheManager.invalidate('user:*');
    return newUser;
  }

  async update(id: string, user: Partial<User>): Promise<User> {
    const updatedUser = await this.apiClient.put<User>(`/api/users/${id}`, user);
    // æ›´æ–°ç¼“å­˜
    await this.cacheManager.set(`user:${id}`, updatedUser);
    return updatedUser;
  }

  async delete(id: string): Promise<void> {
    await this.apiClient.delete(`/api/users/${id}`);
    // æ¸…é™¤ç¼“å­˜
    await this.cacheManager.delete(`user:${id}`);
  }
}
```

```typescript
// ä¸šåŠ¡å±‚ (Business Layer) - è´Ÿè´£ä¸šåŠ¡é€»è¾‘å¤„ç†
interface ProductService {
  getProducts(filters?: ProductFilters): Promise<Product[]>;
  getProduct(id: string): Promise<Product>;
  createProduct(productData: CreateProductData): Promise<Product>;
  updateProduct(id: string, updates: Partial<Product>): Promise<Product>;
  deleteProduct(id: string): Promise<void>;
  searchProducts(query: string): Promise<Product[]>;
  getRecommendedProducts(userId: string): Promise<Product[]>;
}

class ProductServiceImpl implements ProductService {
  constructor(
    private productRepository: ProductRepository,
    private userRepository: UserRepository,
    private recommendationService: RecommendationService,
    private eventBus: EventBus
  ) {}

  async getProducts(filters?: ProductFilters): Promise<Product[]> {
    let products = await this.productRepository.findAll();

    // åº”ç”¨è¿‡æ»¤å™¨
    if (filters) {
      products = this.applyFilters(products, filters);
    }

    // åº”ç”¨ä¸šåŠ¡è§„åˆ™
    products = this.applyBusinessRules(products);

    return products;
  }

  async getProduct(id: string): Promise<Product> {
    const product = await this.productRepository.findById(id);
    if (!product) {
      throw new Error(`Product with id ${id} not found`);
    }

    // è®°å½•æŸ¥çœ‹äº‹ä»¶
    this.eventBus.emit('product:viewed', { productId: id, timestamp: new Date() });

    return product;
  }

  async createProduct(productData: CreateProductData): Promise<Product> {
    // ä¸šåŠ¡éªŒè¯
    this.validateProductData(productData);

    // ç”ŸæˆSKU
    const sku = this.generateSKU(productData);

    const product: Product = {
      ...productData,
      id: generateId(),
      sku,
      status: 'active',
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const createdProduct = await this.productRepository.create(product);

    // å‘å¸ƒäº‹ä»¶
    this.eventBus.emit('product:created', createdProduct);

    return createdProduct;
  }

  async updateProduct(id: string, updates: Partial<Product>): Promise<Product> {
    const existingProduct = await this.getProduct(id);

    // ä¸šåŠ¡éªŒè¯
    this.validateProductUpdates(existingProduct, updates);

    const updatedProduct = await this.productRepository.update(id, {
      ...updates,
      updatedAt: new Date()
    });

    // å‘å¸ƒäº‹ä»¶
    this.eventBus.emit('product:updated', { before: existingProduct, after: updatedProduct });

    return updatedProduct;
  }

  async deleteProduct(id: string): Promise<void> {
    const product = await this.getProduct(id);

    // ä¸šåŠ¡è§„åˆ™æ£€æŸ¥
    if (product.status === 'active' && product.stock > 0) {
      throw new Error('Cannot delete active product with stock');
    }

    await this.productRepository.delete(id);

    // å‘å¸ƒäº‹ä»¶
    this.eventBus.emit('product:deleted', product);
  }

  async searchProducts(query: string): Promise<Product[]> {
    // æœç´¢é€»è¾‘
    const products = await this.productRepository.findAll();
    return products.filter(product =>
      product.name.toLowerCase().includes(query.toLowerCase()) ||
      product.description.toLowerCase().includes(query.toLowerCase())
    );
  }

  async getRecommendedProducts(userId: string): Promise<Product[]> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new Error('User not found');
    }

    // ä½¿ç”¨æ¨èæœåŠ¡
    const recommendedIds = await this.recommendationService.getRecommendations(userId);

    const products = await Promise.all(
      recommendedIds.map(id => this.productRepository.findById(id))
    );

    return products.filter(Boolean) as Product[];
  }

  private applyFilters(products: Product[], filters: ProductFilters): Product[] {
    let filtered = products;

    if (filters.category) {
      filtered = filtered.filter(p => p.categoryId === filters.category);
    }

    if (filters.minPrice !== undefined) {
      filtered = filtered.filter(p => parseFloat(p.price) >= filters.minPrice!);
    }

    if (filters.maxPrice !== undefined) {
      filtered = filtered.filter(p => parseFloat(p.price) <= filters.maxPrice!);
    }

    if (filters.inStock) {
      filtered = filtered.filter(p => p.stock > 0);
    }

    return filtered;
  }

  private applyBusinessRules(products: Product[]): Product[] {
    return products
      .filter(p => p.status === 'active') // åªæ˜¾ç¤ºæ´»è·ƒå•†å“
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime()); // æŒ‰åˆ›å»ºæ—¶é—´æ’åº
  }

  private validateProductData(data: CreateProductData): void {
    if (!data.name || data.name.trim().length === 0) {
      throw new Error('Product name is required');
    }

    if (!data.price || parseFloat(data.price) <= 0) {
      throw new Error('Product price must be greater than 0');
    }

    if (!data.categoryId) {
      throw new Error('Product category is required');
    }
  }

  private validateProductUpdates(existing: Product, updates: Partial<Product>): void {
    if (updates.price && parseFloat(updates.price) <= 0) {
      throw new Error('Product price must be greater than 0');
    }

    if (updates.stock && updates.stock < 0) {
      throw new Error('Product stock cannot be negative');
    }
  }

  private generateSKU(productData: CreateProductData): string {
    const categoryPrefix = productData.categoryId.toString().padStart(3, '0');
    const timestamp = Date.now().toString().slice(-6);
    const random = Math.random().toString(36).substr(2, 4).toUpperCase();
    return `${categoryPrefix}-${timestamp}-${random}`;
  }
}
```

```typescript
// è¡¨ç°å±‚ (Presentation Layer) - è´Ÿè´£UIæ¸²æŸ“å’Œç”¨æˆ·äº¤äº’
interface ProductListProps {
  filters?: ProductFilters;
  onProductSelect?: (product: Product) => void;
  onFiltersChange?: (filters: ProductFilters) => void;
}

// å®¹å™¨ç»„ä»¶ - è¿æ¥ä¸šåŠ¡å±‚
function ProductListContainer({ filters, onProductSelect, onFiltersChange }: ProductListProps) {
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const productService = useService<ProductService>('ProductService');

  useEffect(() => {
    loadProducts();
  }, [filters]);

  const loadProducts = async () => {
    setLoading(true);
    setError(null);

    try {
      const products = await productService.getProducts(filters);
      setProducts(products);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load products');
    } finally {
      setLoading(false);
    }
  };

  const handleProductClick = (product: Product) => {
    onProductSelect?.(product);
  };

  const handleFilterChange = (newFilters: ProductFilters) => {
    onFiltersChange?.(newFilters);
  };

  if (loading) {
    return <ProductListSkeleton />;
  }

  if (error) {
    return <ErrorMessage message={error} onRetry={loadProducts} />;
  }

  return (
    <ProductListPresentation
      products={products}
      filters={filters}
      onProductClick={handleProductClick}
      onFiltersChange={handleFilterChange}
    />
  );
}

// å±•ç¤ºç»„ä»¶ - çº¯UIæ¸²æŸ“
interface ProductListPresentationProps {
  products: Product[];
  filters?: ProductFilters;
  onProductClick: (product: Product) => void;
  onFiltersChange: (filters: ProductFilters) => void;
}

function ProductListPresentation({
  products,
  filters,
  onProductClick,
  onFiltersChange
}: ProductListPresentationProps) {
  return (
    <div className="product-list">
      <ProductFilters
        filters={filters}
        onChange={onFiltersChange}
      />

      <div className="product-grid">
        {products.map(product => (
          <ProductCard
            key={product.id}
            product={product}
            onClick={() => onProductClick(product)}
          />
        ))}
      </div>

      {products.length === 0 && (
        <EmptyState message="No products found" />
      )}
    </div>
  );
}

// åŸå­ç»„ä»¶ - æœ€å°UIå•å…ƒ
interface ProductCardProps {
  product: Product;
  onClick: () => void;
}

function ProductCard({ product, onClick }: ProductCardProps) {
  return (
    <div className="product-card" onClick={onClick}>
      <img
        src={product.images[0]}
        alt={product.name}
        className="product-image"
        loading="lazy"
      />

      <div className="product-info">
        <h3 className="product-name">{product.name}</h3>
        <p className="product-price">Â¥{product.price}</p>

        {product.discountPrice && (
          <p className="product-discount">
            <span className="original-price">Â¥{product.price}</span>
            <span className="discount-price">Â¥{product.discountPrice}</span>
          </p>
        )}

        <div className="product-meta">
          <span className="product-stock">
            åº“å­˜: {product.stock}
          </span>

          {product.stock === 0 && (
            <span className="out-of-stock">ç¼ºè´§</span>
          )}
        </div>
      </div>
    </div>
  );
}
```

### ä¾èµ–æ³¨å…¥å®¹å™¨

```typescript
// ä¾èµ–æ³¨å…¥å®¹å™¨å®ç°
type Constructor<T = {}> = new (...args: any[]) => T;
type ServiceFactory<T> = () => T;
type ServiceIdentifier<T> = string | symbol | Constructor<T>;

interface ServiceDescriptor<T> {
  identifier: ServiceIdentifier<T>;
  factory: ServiceFactory<T>;
  singleton: boolean;
  dependencies: ServiceIdentifier<any>[];
}

class DIContainer {
  private services = new Map<ServiceIdentifier<any>, ServiceDescriptor<any>>();
  private instances = new Map<ServiceIdentifier<any>, any>();

  // æ³¨å†ŒæœåŠ¡
  register<T>(
    identifier: ServiceIdentifier<T>,
    factory: ServiceFactory<T>,
    options: { singleton?: boolean; dependencies?: ServiceIdentifier<any>[] } = {}
  ): void {
    const { singleton = true, dependencies = [] } = options;

    this.services.set(identifier, {
      identifier,
      factory,
      singleton,
      dependencies
    });
  }

  // æ³¨å†Œç±»
  registerClass<T>(
    identifier: ServiceIdentifier<T>,
    constructor: Constructor<T>,
    options: { singleton?: boolean; dependencies?: ServiceIdentifier<any>[] } = {}
  ): void {
    const { dependencies = [] } = options;

    this.register(
      identifier,
      () => {
        const deps = dependencies.map(dep => this.resolve(dep));
        return new constructor(...deps);
      },
      options
    );
  }

  // è§£ææœåŠ¡
  resolve<T>(identifier: ServiceIdentifier<T>): T {
    const descriptor = this.services.get(identifier);
    if (!descriptor) {
      throw new Error(`Service ${String(identifier)} not registered`);
    }

    // å•ä¾‹æ¨¡å¼æ£€æŸ¥
    if (descriptor.singleton && this.instances.has(identifier)) {
      return this.instances.get(identifier);
    }

    // è§£æä¾èµ–
    const dependencies = descriptor.dependencies.map(dep => this.resolve(dep));

    // åˆ›å»ºå®ä¾‹
    const instance = descriptor.factory();

    // ç¼“å­˜å•ä¾‹
    if (descriptor.singleton) {
      this.instances.set(identifier, instance);
    }

    return instance;
  }

  // æ£€æŸ¥æœåŠ¡æ˜¯å¦å·²æ³¨å†Œ
  has<T>(identifier: ServiceIdentifier<T>): boolean {
    return this.services.has(identifier);
  }

  // æ¸…é™¤æ‰€æœ‰æœåŠ¡
  clear(): void {
    this.services.clear();
    this.instances.clear();
  }
}

// å…¨å±€å®¹å™¨å®ä¾‹
export const container = new DIContainer();

// æœåŠ¡æ³¨å†Œ
container.register('ApiClient', () => new ApiClient(process.env.NEXT_PUBLIC_API_BASE_URL!));
container.register('CacheManager', () => new CacheManager());
container.register('EventBus', () => new EventBus());

container.registerClass(
  'ProductRepository',
  ProductRepository,
  { dependencies: ['ApiClient'] }
);

container.registerClass(
  'UserRepository',
  UserRepository,
  { dependencies: ['ApiClient', 'CacheManager'] }
);

container.registerClass(
  'ProductService',
  ProductServiceImpl,
  { dependencies: ['ProductRepository', 'UserRepository', 'RecommendationService', 'EventBus'] }
);

// React Hook for dependency injection
export function useService<T>(identifier: ServiceIdentifier<T>): T {
  return useMemo(() => container.resolve(identifier), [identifier]);
}

// è£…é¥°å™¨æ”¯æŒ (å¦‚æœä½¿ç”¨è£…é¥°å™¨)
export function Injectable<T extends Constructor>(constructor: T) {
  return class extends constructor {
    static [Symbol.hasInstance](instance: any) {
      return instance instanceof constructor;
    }
  };
}

export function Inject(identifier: ServiceIdentifier<any>) {
  return function (target: any, propertyKey: string | symbol | undefined, parameterIndex: number) {
    // è£…é¥°å™¨å…ƒæ•°æ®å¤„ç†
    const existingTokens = Reflect.getMetadata('design:paramtypes', target) || [];
    existingTokens[parameterIndex] = identifier;
    Reflect.defineMetadata('design:paramtypes', existingTokens, target);
  };
}
```

---

## ğŸ§© æ¨¡å—åŒ–ä¸ç»„ä»¶åŒ–è®¾è®¡

### ç‰¹æ€§æ¨¡å—è®¾è®¡

```typescript
// ç‰¹æ€§æ¨¡å—ç»“æ„
// features/product/
//   â”œâ”€â”€ components/
//   â”‚   â”œâ”€â”€ ProductCard.tsx
//   â”‚   â”œâ”€â”€ ProductList.tsx
//   â”‚   â””â”€â”€ ProductFilters.tsx
//   â”œâ”€â”€ services/
//   â”‚   â”œâ”€â”€ ProductService.ts
//   â”‚   â””â”€â”€ ProductRepository.ts
//   â”œâ”€â”€ types/
//   â”‚   â””â”€â”€ Product.ts
//   â”œâ”€â”€ hooks/
//   â”‚   â”œâ”€â”€ useProducts.ts
//   â”‚   â””â”€â”€ useProductFilters.ts
//   â”œâ”€â”€ utils/
//   â”‚   â””â”€â”€ productUtils.ts
//   â””â”€â”€ index.ts

// features/product/types/Product.ts
export interface Product {
  id: string;
  name: string;
  description: string;
  price: string;
  discountPrice?: string;
  images: string[];
  categoryId: string;
  stock: number;
  status: 'active' | 'inactive' | 'draft';
  createdAt: Date;
  updatedAt: Date;
}

export interface ProductFilters {
  category?: string;
  minPrice?: number;
  maxPrice?: number;
  inStock?: boolean;
  search?: string;
}

export interface CreateProductData {
  name: string;
  description: string;
  price: string;
  categoryId: string;
  images: string[];
  stock: number;
}

// features/product/hooks/useProducts.ts
export function useProducts(filters?: ProductFilters) {
  const productService = useService<ProductService>('ProductService');

  return useQuery({
    queryKey: ['products', filters],
    queryFn: () => productService.getProducts(filters),
    staleTime: 5 * 60 * 1000,
  });
}

export function useProduct(id: string) {
  const productService = useService<ProductService>('ProductService');

  return useQuery({
    queryKey: ['product', id],
    queryFn: () => productService.getProduct(id),
    enabled: !!id,
    staleTime: 10 * 60 * 1000,
  });
}

export function useProductMutations() {
  const productService = useService<ProductService>('ProductService');
  const queryClient = useQueryClient();

  const createProduct = useMutation({
    mutationFn: (data: CreateProductData) => productService.createProduct(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['products'] });
    },
  });

  const updateProduct = useMutation({
    mutationFn: ({ id, updates }: { id: string; updates: Partial<Product> }) =>
      productService.updateProduct(id, updates),
    onSuccess: (updatedProduct) => {
      queryClient.setQueryData(['product', updatedProduct.id], updatedProduct);
      queryClient.invalidateQueries({ queryKey: ['products'] });
    },
  });

  const deleteProduct = useMutation({
    mutationFn: (id: string) => productService.deleteProduct(id),
    onSuccess: (_, deletedId) => {
      queryClient.removeQueries({ queryKey: ['product', deletedId] });
      queryClient.invalidateQueries({ queryKey: ['products'] });
    },
  });

  return {
    createProduct,
    updateProduct,
    deleteProduct,
  };
}

// features/product/utils/productUtils.ts
export class ProductUtils {
  static formatPrice(price: string): string {
    const num = parseFloat(price);
    return new Intl.NumberFormat('zh-CN', {
      style: 'currency',
      currency: 'CNY'
    }).format(num);
  }

  static calculateDiscount(originalPrice: string, discountPrice: string): number {
    const original = parseFloat(originalPrice);
    const discount = parseFloat(discountPrice);
    return Math.round(((original - discount) / original) * 100);
  }

  static isInStock(product: Product): boolean {
    return product.stock > 0 && product.status === 'active';
  }

  static getMainImage(product: Product): string {
    return product.images[0] || '/images/placeholder.jpg';
  }

  static generateSEOTitle(product: Product): string {
    return `${product.name} - ä¼˜è´¨å•†å“ - Mallå•†åŸ`;
  }

  static generateSEODescription(product: Product): string {
    return `${product.description.substring(0, 150)}...`;
  }
}

// features/product/index.ts - æ¨¡å—å¯¼å‡º
export * from './types/Product';
export * from './components/ProductCard';
export * from './components/ProductList';
export * from './components/ProductFilters';
export * from './hooks/useProducts';
export * from './utils/productUtils';

// é»˜è®¤å¯¼å‡ºæ¨¡å—é…ç½®
export default {
  name: 'Product',
  version: '1.0.0',
  dependencies: ['User', 'Category'],
  routes: [
    { path: '/products', component: 'ProductList' },
    { path: '/products/:id', component: 'ProductDetail' },
  ],
  services: ['ProductService', 'ProductRepository'],
};
```

### åŸå­è®¾è®¡æ¨¡å¼

```typescript
// åŸå­è®¾è®¡å±‚æ¬¡ç»“æ„
// atoms/ - åŸå­ç»„ä»¶
//   â”œâ”€â”€ Button.tsx
//   â”œâ”€â”€ Input.tsx
//   â”œâ”€â”€ Label.tsx
//   â””â”€â”€ Image.tsx
// molecules/ - åˆ†å­ç»„ä»¶
//   â”œâ”€â”€ SearchBox.tsx
//   â”œâ”€â”€ PriceDisplay.tsx
//   â””â”€â”€ ImageGallery.tsx
// organisms/ - æœ‰æœºä½“ç»„ä»¶
//   â”œâ”€â”€ ProductCard.tsx
//   â”œâ”€â”€ ProductGrid.tsx
//   â””â”€â”€ Header.tsx
// templates/ - æ¨¡æ¿
//   â”œâ”€â”€ ProductListTemplate.tsx
//   â””â”€â”€ ProductDetailTemplate.tsx
// pages/ - é¡µé¢
//   â”œâ”€â”€ ProductListPage.tsx
//   â””â”€â”€ ProductDetailPage.tsx

// atoms/Button.tsx - åŸå­ç»„ä»¶
interface ButtonProps {
  variant: 'primary' | 'secondary' | 'danger' | 'ghost';
  size: 'small' | 'medium' | 'large';
  disabled?: boolean;
  loading?: boolean;
  children: React.ReactNode;
  onClick?: () => void;
}

export function Button({
  variant = 'primary',
  size = 'medium',
  disabled = false,
  loading = false,
  children,
  onClick
}: ButtonProps) {
  const baseClasses = 'inline-flex items-center justify-center font-medium rounded-md transition-colors';

  const variantClasses = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700',
    secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300',
    danger: 'bg-red-600 text-white hover:bg-red-700',
    ghost: 'text-gray-600 hover:text-gray-900 hover:bg-gray-100'
  };

  const sizeClasses = {
    small: 'px-3 py-1.5 text-sm',
    medium: 'px-4 py-2 text-base',
    large: 'px-6 py-3 text-lg'
  };

  const className = `
    ${baseClasses}
    ${variantClasses[variant]}
    ${sizeClasses[size]}
    ${disabled || loading ? 'opacity-50 cursor-not-allowed' : ''}
  `.trim();

  return (
    <button
      className={className}
      disabled={disabled || loading}
      onClick={onClick}
    >
      {loading && <Spinner className="mr-2" />}
      {children}
    </button>
  );
}

// molecules/PriceDisplay.tsx - åˆ†å­ç»„ä»¶
interface PriceDisplayProps {
  price: string;
  discountPrice?: string;
  currency?: string;
  size?: 'small' | 'medium' | 'large';
}

export function PriceDisplay({
  price,
  discountPrice,
  currency = 'CNY',
  size = 'medium'
}: PriceDisplayProps) {
  const hasDiscount = discountPrice && discountPrice !== price;
  const discount = hasDiscount ? ProductUtils.calculateDiscount(price, discountPrice) : 0;

  const sizeClasses = {
    small: 'text-sm',
    medium: 'text-base',
    large: 'text-lg'
  };

  return (
    <div className={`price-display ${sizeClasses[size]}`}>
      {hasDiscount ? (
        <div className="flex items-center space-x-2">
          <span className="text-red-600 font-bold">
            {ProductUtils.formatPrice(discountPrice)}
          </span>
          <span className="text-gray-500 line-through">
            {ProductUtils.formatPrice(price)}
          </span>
          <span className="bg-red-100 text-red-800 px-2 py-1 rounded text-xs">
            -{discount}%
          </span>
        </div>
      ) : (
        <span className="text-gray-900 font-bold">
          {ProductUtils.formatPrice(price)}
        </span>
      )}
    </div>
  );
}

// organisms/ProductCard.tsx - æœ‰æœºä½“ç»„ä»¶
interface ProductCardProps {
  product: Product;
  onAddToCart?: (product: Product) => void;
  onQuickView?: (product: Product) => void;
  onClick?: (product: Product) => void;
}

export function ProductCard({
  product,
  onAddToCart,
  onQuickView,
  onClick
}: ProductCardProps) {
  const [imageLoaded, setImageLoaded] = useState(false);
  const [imageError, setImageError] = useState(false);

  const handleAddToCart = (e: React.MouseEvent) => {
    e.stopPropagation();
    onAddToCart?.(product);
  };

  const handleQuickView = (e: React.MouseEvent) => {
    e.stopPropagation();
    onQuickView?.(product);
  };

  const handleClick = () => {
    onClick?.(product);
  };

  return (
    <div
      className="product-card bg-white rounded-lg shadow-md hover:shadow-lg transition-shadow cursor-pointer"
      onClick={handleClick}
    >
      {/* å›¾ç‰‡åŒºåŸŸ */}
      <div className="relative aspect-square overflow-hidden rounded-t-lg">
        {!imageLoaded && !imageError && (
          <div className="absolute inset-0 bg-gray-200 animate-pulse" />
        )}

        <img
          src={imageError ? '/images/placeholder.jpg' : ProductUtils.getMainImage(product)}
          alt={product.name}
          className={`w-full h-full object-cover transition-opacity ${
            imageLoaded ? 'opacity-100' : 'opacity-0'
          }`}
          onLoad={() => setImageLoaded(true)}
          onError={() => setImageError(true)}
          loading="lazy"
        />

        {/* æ‚¬æµ®æ“ä½œæŒ‰é’® */}
        <div className="absolute inset-0 bg-black bg-opacity-0 hover:bg-opacity-20 transition-all">
          <div className="absolute top-2 right-2 opacity-0 hover:opacity-100 transition-opacity">
            <Button
              variant="ghost"
              size="small"
              onClick={handleQuickView}
            >
              å¿«é€ŸæŸ¥çœ‹
            </Button>
          </div>
        </div>

        {/* åº“å­˜çŠ¶æ€ */}
        {!ProductUtils.isInStock(product) && (
          <div className="absolute inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center">
            <span className="text-white font-bold">ç¼ºè´§</span>
          </div>
        )}
      </div>

      {/* å†…å®¹åŒºåŸŸ */}
      <div className="p-4">
        <h3 className="text-lg font-semibold text-gray-900 mb-2 line-clamp-2">
          {product.name}
        </h3>

        <p className="text-gray-600 text-sm mb-3 line-clamp-2">
          {product.description}
        </p>

        <PriceDisplay
          price={product.price}
          discountPrice={product.discountPrice}
          size="medium"
        />

        <div className="mt-4 flex items-center justify-between">
          <span className="text-sm text-gray-500">
            åº“å­˜: {product.stock}
          </span>

          <Button
            variant="primary"
            size="small"
            disabled={!ProductUtils.isInStock(product)}
            onClick={handleAddToCart}
          >
            åŠ å…¥è´­ç‰©è½¦
          </Button>
        </div>
      </div>
    </div>
  );
}
```

---

## ğŸ¯ é¢è¯•å¸¸è€ƒçŸ¥è¯†ç‚¹

### 1. å‰ç«¯æ¶æ„è®¾è®¡åŸåˆ™

**Q: å¦‚ä½•è®¾è®¡ä¸€ä¸ªå¯æ‰©å±•çš„å‰ç«¯æ¶æ„ï¼Ÿ**

**A: å¯æ‰©å±•å‰ç«¯æ¶æ„çš„æ ¸å¿ƒè¦ç´ ï¼š**

```typescript
// å¯æ‰©å±•æ¶æ„è®¾è®¡è¦ç‚¹
const scalableArchitecturePrinciples = {
  // 1. æ¨¡å—åŒ–è®¾è®¡
  modularity: {
    principle: 'é«˜å†…èšï¼Œä½è€¦åˆ',
    implementation: [
      'æŒ‰åŠŸèƒ½åˆ’åˆ†æ¨¡å—',
      'æ˜ç¡®æ¨¡å—è¾¹ç•Œ',
      'å®šä¹‰æ¸…æ™°çš„æ¥å£',
      'é¿å…å¾ªç¯ä¾èµ–'
    ],
    example: `
      // æ¨¡å—ç»“æ„
      features/
        user/
          components/
          services/
          types/
          index.ts
        product/
          components/
          services/
          types/
          index.ts
    `
  },

  // 2. åˆ†å±‚æ¶æ„
  layeredArchitecture: {
    layers: ['Presentation', 'Business', 'Data', 'Infrastructure'],
    benefits: [
      'èŒè´£åˆ†ç¦»',
      'æ˜“äºæµ‹è¯•',
      'ä¾¿äºç»´æŠ¤',
      'æ”¯æŒæ›¿æ¢'
    ],
    implementation: `
      // åˆ†å±‚ç¤ºä¾‹
      presentation/    // UIç»„ä»¶
      business/        // ä¸šåŠ¡é€»è¾‘
      data/           // æ•°æ®è®¿é—®
      infrastructure/ // åŸºç¡€è®¾æ–½
    `
  },

  // 3. ä¾èµ–æ³¨å…¥
  dependencyInjection: {
    benefits: [
      'é™ä½è€¦åˆåº¦',
      'æé«˜å¯æµ‹è¯•æ€§',
      'æ”¯æŒé…ç½®åŒ–',
      'ä¾¿äºæ‰©å±•'
    ],
    patterns: ['Constructor Injection', 'Property Injection', 'Method Injection']
  },

  // 4. äº‹ä»¶é©±åŠ¨æ¶æ„
  eventDriven: {
    components: ['Event Bus', 'Event Handlers', 'Event Publishers'],
    benefits: [
      'æ¾è€¦åˆ',
      'å¼‚æ­¥å¤„ç†',
      'æ˜“äºæ‰©å±•',
      'æ”¯æŒæ’ä»¶åŒ–'
    ]
  }
};

// æ¶æ„è´¨é‡è¯„ä¼°æŒ‡æ ‡
const architectureQualityMetrics = {
  maintainability: {
    metrics: ['ä»£ç å¤æ‚åº¦', 'é‡å¤ä»£ç ç‡', 'æ¨¡å—è€¦åˆåº¦'],
    tools: ['ESLint', 'SonarQube', 'CodeClimate']
  },

  scalability: {
    metrics: ['æ¨¡å—æ•°é‡', 'ä¾èµ–å…³ç³»', 'æ„å»ºæ—¶é—´'],
    strategies: ['å¾®å‰ç«¯', 'ä»£ç åˆ†å‰²', 'æ‡’åŠ è½½']
  },

  testability: {
    metrics: ['æµ‹è¯•è¦†ç›–ç‡', 'å•å…ƒæµ‹è¯•æ•°é‡', 'é›†æˆæµ‹è¯•æ•°é‡'],
    practices: ['TDD', 'BDD', 'Mock/Stub']
  },

  performance: {
    metrics: ['é¦–å±æ—¶é—´', 'äº¤äº’æ—¶é—´', 'åŒ…ä½“ç§¯'],
    optimizations: ['Tree Shaking', 'Code Splitting', 'Caching']
  }
};
```

### 2. ç»„ä»¶è®¾è®¡æ¨¡å¼

**Q: å¸¸è§çš„Reactç»„ä»¶è®¾è®¡æ¨¡å¼æœ‰å“ªäº›ï¼Ÿ**

**A: Reactç»„ä»¶è®¾è®¡æ¨¡å¼è¯¦è§£ï¼š**

```typescript
// 1. å®¹å™¨/å±•ç¤ºç»„ä»¶æ¨¡å¼
// Container Component - è´Ÿè´£æ•°æ®å’Œé€»è¾‘
function ProductListContainer() {
  const { data: products, loading, error } = useProducts();
  const [filters, setFilters] = useState<ProductFilters>({});

  const handleFilterChange = (newFilters: ProductFilters) => {
    setFilters(newFilters);
  };

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <ProductListPresentation
      products={products}
      filters={filters}
      onFilterChange={handleFilterChange}
    />
  );
}

// Presentation Component - è´Ÿè´£UIæ¸²æŸ“
interface ProductListPresentationProps {
  products: Product[];
  filters: ProductFilters;
  onFilterChange: (filters: ProductFilters) => void;
}

function ProductListPresentation({
  products,
  filters,
  onFilterChange
}: ProductListPresentationProps) {
  return (
    <div>
      <ProductFilters filters={filters} onChange={onFilterChange} />
      <ProductGrid products={products} />
    </div>
  );
}

// 2. é«˜é˜¶ç»„ä»¶æ¨¡å¼ (HOC)
function withLoading<P extends object>(
  Component: React.ComponentType<P>
) {
  return function WithLoadingComponent(props: P & { loading: boolean }) {
    const { loading, ...restProps } = props;

    if (loading) {
      return <LoadingSpinner />;
    }

    return <Component {...(restProps as P)} />;
  };
}

// ä½¿ç”¨HOC
const ProductListWithLoading = withLoading(ProductList);

// 3. Render Propsæ¨¡å¼
interface DataFetcherProps<T> {
  url: string;
  children: (data: {
    data: T | null;
    loading: boolean;
    error: Error | null;
  }) => React.ReactNode;
}

function DataFetcher<T>({ url, children }: DataFetcherProps<T>) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [url]);

  return <>{children({ data, loading, error })}</>;
}

// ä½¿ç”¨Render Props
function ProductPage() {
  return (
    <DataFetcher<Product[]> url="/api/products">
      {({ data: products, loading, error }) => {
        if (loading) return <LoadingSpinner />;
        if (error) return <ErrorMessage error={error} />;
        return <ProductList products={products} />;
      }}
    </DataFetcher>
  );
}

// 4. å¤åˆç»„ä»¶æ¨¡å¼
interface TabsContextType {
  activeTab: string;
  setActiveTab: (tab: string) => void;
}

const TabsContext = createContext<TabsContextType | null>(null);

function Tabs({ children, defaultTab }: { children: React.ReactNode; defaultTab: string }) {
  const [activeTab, setActiveTab] = useState(defaultTab);

  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  );
}

function TabList({ children }: { children: React.ReactNode }) {
  return <div className="tab-list">{children}</div>;
}

function Tab({ value, children }: { value: string; children: React.ReactNode }) {
  const context = useContext(TabsContext);
  if (!context) throw new Error('Tab must be used within Tabs');

  const { activeTab, setActiveTab } = context;

  return (
    <button
      className={`tab ${activeTab === value ? 'active' : ''}`}
      onClick={() => setActiveTab(value)}
    >
      {children}
    </button>
  );
}

function TabPanels({ children }: { children: React.ReactNode }) {
  return <div className="tab-panels">{children}</div>;
}

function TabPanel({ value, children }: { value: string; children: React.ReactNode }) {
  const context = useContext(TabsContext);
  if (!context) throw new Error('TabPanel must be used within Tabs');

  const { activeTab } = context;

  if (activeTab !== value) return null;

  return <div className="tab-panel">{children}</div>;
}

// ç»„åˆä½¿ç”¨
Tabs.List = TabList;
Tabs.Tab = Tab;
Tabs.Panels = TabPanels;
Tabs.Panel = TabPanel;

// ä½¿ç”¨å¤åˆç»„ä»¶
function ProductDetailPage() {
  return (
    <Tabs defaultTab="description">
      <Tabs.List>
        <Tabs.Tab value="description">å•†å“æè¿°</Tabs.Tab>
        <Tabs.Tab value="reviews">ç”¨æˆ·è¯„ä»·</Tabs.Tab>
        <Tabs.Tab value="shipping">é…é€ä¿¡æ¯</Tabs.Tab>
      </Tabs.List>

      <Tabs.Panels>
        <Tabs.Panel value="description">
          <ProductDescription />
        </Tabs.Panel>
        <Tabs.Panel value="reviews">
          <ProductReviews />
        </Tabs.Panel>
        <Tabs.Panel value="shipping">
          <ShippingInfo />
        </Tabs.Panel>
      </Tabs.Panels>
    </Tabs>
  );
}

// 5. è‡ªå®šä¹‰Hookæ¨¡å¼
function useToggle(initialValue: boolean = false) {
  const [value, setValue] = useState(initialValue);

  const toggle = useCallback(() => setValue(v => !v), []);
  const setTrue = useCallback(() => setValue(true), []);
  const setFalse = useCallback(() => setValue(false), []);

  return { value, toggle, setTrue, setFalse };
}

function useLocalStorage<T>(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error('Error saving to localStorage:', error);
    }
  };

  return [storedValue, setValue] as const;
}

// ä½¿ç”¨è‡ªå®šä¹‰Hook
function ProductCard({ product }: { product: Product }) {
  const { value: isExpanded, toggle } = useToggle();
  const [favorites, setFavorites] = useLocalStorage<string[]>('favorites', []);

  const isFavorite = favorites.includes(product.id);

  const toggleFavorite = () => {
    setFavorites(prev =>
      isFavorite
        ? prev.filter(id => id !== product.id)
        : [...prev, product.id]
    );
  };

  return (
    <div className="product-card">
      <h3 onClick={toggle}>{product.name}</h3>
      {isExpanded && <p>{product.description}</p>}
      <button onClick={toggleFavorite}>
        {isFavorite ? 'â¤ï¸' : 'ğŸ¤'}
      </button>
    </div>
  );
}
```

### 3. çŠ¶æ€ç®¡ç†æ¶æ„

**Q: å¦‚ä½•é€‰æ‹©åˆé€‚çš„çŠ¶æ€ç®¡ç†æ–¹æ¡ˆï¼Ÿ**

**A: çŠ¶æ€ç®¡ç†æ–¹æ¡ˆé€‰æ‹©æŒ‡å—ï¼š**

```typescript
// çŠ¶æ€ç®¡ç†æ–¹æ¡ˆå¯¹æ¯”
const stateManagementComparison = {
  // 1. æœ¬åœ°çŠ¶æ€ (useState, useReducer)
  localState: {
    useCase: ['ç»„ä»¶å†…éƒ¨çŠ¶æ€', 'ç®€å•è¡¨å•', 'ä¸´æ—¶UIçŠ¶æ€'],
    pros: ['ç®€å•ç›´æ¥', 'æ€§èƒ½å¥½', 'æ— é¢å¤–ä¾èµ–'],
    cons: ['éš¾ä»¥å…±äº«', 'çŠ¶æ€æå‡å¤æ‚', 'ç¼ºä¹æŒä¹…åŒ–'],
    example: `
      function Counter() {
        const [count, setCount] = useState(0);
        return (
          <div>
            <span>{count}</span>
            <button onClick={() => setCount(c => c + 1)}>+</button>
          </div>
        );
      }
    `
  },

  // 2. Context API
  contextAPI: {
    useCase: ['ä¸»é¢˜åˆ‡æ¢', 'ç”¨æˆ·è®¤è¯', 'è¯­è¨€è®¾ç½®', 'ä¸­ç­‰å¤æ‚åº¦åº”ç”¨'],
    pros: ['Reactå†…ç½®', 'é¿å…prop drilling', 'ç±»å‹å®‰å…¨'],
    cons: ['æ€§èƒ½é—®é¢˜', 'é‡æ–°æ¸²æŸ“', 'å¤æ‚çŠ¶æ€ç®¡ç†å›°éš¾'],
    example: `
      const ThemeContext = createContext();

      function ThemeProvider({ children }) {
        const [theme, setTheme] = useState('light');
        return (
          <ThemeContext.Provider value={{ theme, setTheme }}>
            {children}
          </ThemeContext.Provider>
        );
      }
    `
  },

  // 3. Redux Toolkit
  reduxToolkit: {
    useCase: ['å¤§å‹åº”ç”¨', 'å¤æ‚çŠ¶æ€é€»è¾‘', 'æ—¶é—´æ—…è¡Œè°ƒè¯•', 'çŠ¶æ€æŒä¹…åŒ–'],
    pros: ['å¯é¢„æµ‹', 'å¼ºå¤§çš„å¼€å‘å·¥å…·', 'ä¸­é—´ä»¶æ”¯æŒ', 'ç¤¾åŒºæˆç†Ÿ'],
    cons: ['å­¦ä¹ æ›²çº¿', 'æ ·æ¿ä»£ç ', 'è¿‡åº¦å·¥ç¨‹'],
    example: `
      const counterSlice = createSlice({
        name: 'counter',
        initialState: { value: 0 },
        reducers: {
          increment: (state) => {
            state.value += 1;
          }
        }
      });
    `
  },

  // 4. Zustand
  zustand: {
    useCase: ['ä¸­å‹åº”ç”¨', 'ç®€å•å…¨å±€çŠ¶æ€', 'å¿«é€ŸåŸå‹'],
    pros: ['è½»é‡çº§', 'ç®€å•API', 'TypeScriptå‹å¥½', 'æ— æ ·æ¿ä»£ç '],
    cons: ['ç”Ÿæ€è¾ƒå°', 'è°ƒè¯•å·¥å…·æœ‰é™'],
    example: `
      const useStore = create((set) => ({
        count: 0,
        increment: () => set((state) => ({ count: state.count + 1 }))
      }));
    `
  },

  // 5. React Query + Zustand
  hybrid: {
    useCase: ['ç°ä»£åº”ç”¨', 'æœåŠ¡ç«¯çŠ¶æ€ + å®¢æˆ·ç«¯çŠ¶æ€åˆ†ç¦»'],
    pros: ['èŒè´£åˆ†ç¦»', 'æœ€ä½³å®è·µ', 'æ€§èƒ½ä¼˜åŒ–'],
    cons: ['å­¦ä¹ æˆæœ¬', 'å¤šä¸ªä¾èµ–'],
    example: `
      // æœåŠ¡ç«¯çŠ¶æ€ - React Query
      const { data: products } = useQuery(['products'], fetchProducts);

      // å®¢æˆ·ç«¯çŠ¶æ€ - Zustand
      const { cart, addToCart } = useCartStore();
    `
  }
};

// çŠ¶æ€ç®¡ç†å†³ç­–æ ‘
const stateManagementDecisionTree = {
  questions: [
    {
      question: 'çŠ¶æ€æ˜¯å¦éœ€è¦åœ¨å¤šä¸ªç»„ä»¶é—´å…±äº«ï¼Ÿ',
      no: 'ä½¿ç”¨ useState/useReducer',
      yes: 'ç»§ç»­ä¸‹ä¸€ä¸ªé—®é¢˜'
    },
    {
      question: 'åº”ç”¨è§„æ¨¡æ˜¯å¦è¾ƒå¤§ï¼ˆ>50ä¸ªç»„ä»¶ï¼‰ï¼Ÿ',
      no: 'è€ƒè™‘ Context API æˆ– Zustand',
      yes: 'ç»§ç»­ä¸‹ä¸€ä¸ªé—®é¢˜'
    },
    {
      question: 'æ˜¯å¦éœ€è¦å¤æ‚çš„çŠ¶æ€é€»è¾‘å’Œè°ƒè¯•ï¼Ÿ',
      yes: 'ä½¿ç”¨ Redux Toolkit',
      no: 'ç»§ç»­ä¸‹ä¸€ä¸ªé—®é¢˜'
    },
    {
      question: 'æ˜¯å¦æœ‰å¤§é‡æœåŠ¡ç«¯çŠ¶æ€ï¼Ÿ',
      yes: 'ä½¿ç”¨ React Query + Zustand',
      no: 'ä½¿ç”¨ Zustand'
    }
  ]
};
```

---

## ğŸ“š å®æˆ˜ç»ƒä¹ 

### ç»ƒä¹ 1ï¼šè®¾è®¡æ¨¡å—åŒ–æ¶æ„

**ä»»åŠ¡**: ä¸ºMall-Frontendè®¾è®¡ä¸€ä¸ªæ¨¡å—åŒ–çš„æ¶æ„ï¼ŒåŒ…æ‹¬ç”¨æˆ·æ¨¡å—ã€å•†å“æ¨¡å—ã€è®¢å•æ¨¡å—ç­‰ã€‚

**è¦æ±‚**:
- ä½¿ç”¨ç‰¹æ€§æ¨¡å—è®¾è®¡æ¨¡å¼
- å®ç°æ¨¡å—é—´çš„ä¾èµ–ç®¡ç†
- è®¾è®¡æ¸…æ™°çš„æ¨¡å—æ¥å£
- æ”¯æŒæ¨¡å—çš„ç‹¬ç«‹å¼€å‘å’Œæµ‹è¯•

### ç»ƒä¹ 2ï¼šå®ç°ä¾èµ–æ³¨å…¥å®¹å™¨

**ä»»åŠ¡**: å®ç°ä¸€ä¸ªè½»é‡çº§çš„ä¾èµ–æ³¨å…¥å®¹å™¨ï¼Œæ”¯æŒæœåŠ¡æ³¨å†Œã€è§£æå’Œç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚

**è¦æ±‚**:
- æ”¯æŒå•ä¾‹å’Œç¬æ€ç”Ÿå‘½å‘¨æœŸ
- å®ç°å¾ªç¯ä¾èµ–æ£€æµ‹
- æä¾›React Hooké›†æˆ
- æ”¯æŒè£…é¥°å™¨è¯­æ³•

### ç»ƒä¹ 3ï¼šæ„å»ºç»„ä»¶åº“

**ä»»åŠ¡**: åŸºäºåŸå­è®¾è®¡æ¨¡å¼æ„å»ºä¸€ä¸ªå¯å¤ç”¨çš„ç»„ä»¶åº“ã€‚

**è¦æ±‚**:
- å®ç°åŸå­ã€åˆ†å­ã€æœ‰æœºä½“ç»„ä»¶
- æä¾›å®Œæ•´çš„TypeScriptç±»å‹å®šä¹‰
- æ”¯æŒä¸»é¢˜å®šåˆ¶
- åŒ…å«Storybookæ–‡æ¡£

---

## ğŸ“š æœ¬ç« æ€»ç»“

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œæˆ‘ä»¬å…¨é¢æŒæ¡äº†å‰ç«¯æ¶æ„è®¾è®¡çš„æ ¸å¿ƒåŸç†ï¼š

### ğŸ¯ æ ¸å¿ƒæ”¶è·

1. **è®¾è®¡åŸåˆ™ç²¾é€š** ğŸ¯
   - æŒæ¡äº†SOLIDåŸåˆ™åœ¨å‰ç«¯çš„åº”ç”¨
   - å­¦ä¼šäº†DRYã€KISSã€YAGNIç­‰è®¾è®¡åŸåˆ™
   - ç†è§£äº†æ¶æ„è®¾è®¡çš„æƒè¡¡å’Œå–èˆ

2. **åˆ†å±‚æ¶æ„è®¾è®¡** ğŸ—ï¸
   - æŒæ¡äº†è¡¨ç°å±‚ã€ä¸šåŠ¡å±‚ã€æ•°æ®å±‚çš„èŒè´£åˆ’åˆ†
   - å­¦ä¼šäº†ä¾èµ–æ³¨å…¥å’Œæ§åˆ¶åè½¬çš„å®ç°
   - ç†è§£äº†åˆ†å±‚æ¶æ„çš„ä¼˜åŠ¿å’ŒæŒ‘æˆ˜

3. **æ¨¡å—åŒ–è®¾è®¡** ğŸ§©
   - æŒæ¡äº†ç‰¹æ€§æ¨¡å—å’ŒåŸå­è®¾è®¡æ¨¡å¼
   - å­¦ä¼šäº†æ¨¡å—é—´çš„ä¾èµ–ç®¡ç†
   - ç†è§£äº†ç»„ä»¶åŒ–çš„è®¾è®¡æ€æƒ³

4. **æ¶æ„æ¨¡å¼åº”ç”¨** ğŸ”„
   - æŒæ¡äº†å¤šç§Reactç»„ä»¶è®¾è®¡æ¨¡å¼
   - å­¦ä¼šäº†çŠ¶æ€ç®¡ç†æ–¹æ¡ˆçš„é€‰æ‹©
   - ç†è§£äº†æ¶æ„æ¼”è¿›çš„ç­–ç•¥

5. **ä¼ä¸šçº§å®è·µ** ğŸš€
   - å­¦ä¼šäº†å¤§å‹é¡¹ç›®çš„æ¶æ„æ²»ç†
   - æŒæ¡äº†æ¶æ„è´¨é‡çš„è¯„ä¼°æ–¹æ³•
   - ç†è§£äº†å›¢é˜Ÿåä½œçš„æ¶æ„è§„èŒƒ

### ğŸš€ æŠ€æœ¯è¿›é˜¶

- **ä¸‹ä¸€æ­¥å­¦ä¹ **: çŠ¶æ€ç®¡ç†æ¶æ„è®¾è®¡
- **å®è·µå»ºè®®**: åœ¨é¡¹ç›®ä¸­åº”ç”¨åˆ†å±‚æ¶æ„æ¨¡å¼
- **æ·±å…¥æ–¹å‘**: å¾®å‰ç«¯æ¶æ„å’Œæ’ä»¶åŒ–è®¾è®¡

ä¼˜ç§€çš„æ¶æ„æ˜¯åº”ç”¨æˆåŠŸçš„åŸºçŸ³ï¼Œä¹Ÿæ˜¯å›¢é˜Ÿé«˜æ•ˆåä½œçš„ä¿éšœï¼ ğŸ‰

---

*ä¸‹ä¸€ç« æˆ‘ä»¬å°†å­¦ä¹ ã€ŠçŠ¶æ€ç®¡ç†æ¶æ„è®¾è®¡ã€‹ï¼Œæ¢ç´¢å¤æ‚åº”ç”¨çš„çŠ¶æ€ç®¡ç†ç­–ç•¥ï¼* ğŸš€
```
```
```
