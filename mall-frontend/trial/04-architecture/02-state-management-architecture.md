# ç¬¬2ç« ï¼šçŠ¶æ€ç®¡ç†æ¶æ„è®¾è®¡ ğŸ”„

> *"çŠ¶æ€ç®¡ç†ä¸æ˜¯æŠ€æœ¯é—®é¢˜ï¼Œè€Œæ˜¯æ¶æ„é—®é¢˜ï¼"* ğŸš€

## ğŸ“š æœ¬ç« å¯¼è§ˆ

çŠ¶æ€ç®¡ç†æ˜¯ç°ä»£å‰ç«¯åº”ç”¨çš„æ ¸å¿ƒæŒ‘æˆ˜ä¹‹ä¸€ã€‚éšç€åº”ç”¨å¤æ‚åº¦çš„å¢åŠ ï¼Œå¦‚ä½•è®¾è®¡ä¸€ä¸ªæ—¢èƒ½æ»¡è¶³ä¸šåŠ¡éœ€æ±‚ï¼Œåˆèƒ½ä¿æŒä»£ç å¯ç»´æŠ¤æ€§çš„çŠ¶æ€ç®¡ç†æ¶æ„ï¼Œæˆä¸ºäº†å‰ç«¯æ¶æ„å¸ˆå¿…é¡»æŒæ¡çš„æ ¸å¿ƒæŠ€èƒ½ã€‚æœ¬ç« å°†ä»çŠ¶æ€ç®¡ç†çš„åŸºæœ¬æ¦‚å¿µå‡ºå‘ï¼Œæ·±å…¥å¯¹æ¯”å„ç§çŠ¶æ€ç®¡ç†æ–¹æ¡ˆï¼Œç»“åˆMall-Frontendé¡¹ç›®çš„å®é™…æ¡ˆä¾‹ï¼Œæ¢è®¨ä¼ä¸šçº§çŠ¶æ€ç®¡ç†æ¶æ„çš„è®¾è®¡åŸåˆ™å’Œæœ€ä½³å®è·µã€‚

### ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œä½ å°†æŒæ¡ï¼š

- **çŠ¶æ€ç®¡ç†ç†è®º** - ç†è§£çŠ¶æ€çš„åˆ†ç±»ã€ç”Ÿå‘½å‘¨æœŸå’Œç®¡ç†åŸåˆ™
- **æ–¹æ¡ˆæ·±åº¦å¯¹æ¯”** - æŒæ¡Reduxã€Zustandã€Context APIç­‰æ–¹æ¡ˆçš„ä¼˜åŠ£
- **æ¶æ„è®¾è®¡æ¨¡å¼** - å­¦ä¼šè®¾è®¡å¯æ‰©å±•çš„çŠ¶æ€ç®¡ç†æ¶æ„
- **æ•°æ®æµè®¾è®¡** - ç†è§£å•å‘æ•°æ®æµå’ŒåŒå‘ç»‘å®šçš„åº”ç”¨åœºæ™¯
- **æ€§èƒ½ä¼˜åŒ–ç­–ç•¥** - æŒæ¡çŠ¶æ€ç®¡ç†çš„æ€§èƒ½ä¼˜åŒ–æŠ€å·§
- **æµ‹è¯•ç­–ç•¥** - å­¦ä¼šçŠ¶æ€ç®¡ç†çš„æµ‹è¯•æ–¹æ³•å’Œæœ€ä½³å®è·µ
- **ä¼ä¸šçº§å®è·µ** - å¤§å‹é¡¹ç›®çš„çŠ¶æ€ç®¡ç†æ²»ç†ç»éªŒ
- **è¿ç§»ç­–ç•¥** - çŠ¶æ€ç®¡ç†æ–¹æ¡ˆçš„å‡çº§å’Œè¿ç§»æ–¹æ³•

### ğŸ› ï¸ æŠ€æœ¯æ ˆæ¦‚è§ˆ

```typescript
{
  "stateManagement": {
    "global": ["Redux Toolkit", "Zustand", "Valtio", "Jotai"],
    "local": ["useState", "useReducer", "useImmer"],
    "server": ["React Query", "SWR", "Apollo Client"],
    "form": ["React Hook Form", "Formik", "Final Form"]
  },
  "patterns": {
    "flux": ["Redux", "MobX", "Vuex"],
    "atomic": ["Jotai", "Recoil", "Valtio"],
    "proxy": ["MobX", "Valtio", "Vue 3 Reactivity"]
  },
  "tools": {
    "devtools": ["Redux DevTools", "Zustand DevTools"],
    "testing": ["Redux Mock Store", "MSW", "Testing Library"],
    "middleware": ["Redux Thunk", "Redux Saga", "Redux Observable"]
  }
}
```

### ğŸ“– æœ¬ç« ç›®å½•

- [çŠ¶æ€ç®¡ç†åŸºç¡€ç†è®º](#çŠ¶æ€ç®¡ç†åŸºç¡€ç†è®º)
- [çŠ¶æ€ç®¡ç†æ–¹æ¡ˆæ·±åº¦å¯¹æ¯”](#çŠ¶æ€ç®¡ç†æ–¹æ¡ˆæ·±åº¦å¯¹æ¯”)
- [Reduxç”Ÿæ€ç³»ç»Ÿæ¶æ„](#reduxç”Ÿæ€ç³»ç»Ÿæ¶æ„)
- [Zustandè½»é‡çº§æ–¹æ¡ˆ](#zustandè½»é‡çº§æ–¹æ¡ˆ)
- [Context APIä¼ä¸šåº”ç”¨](#context-apiä¼ä¸šåº”ç”¨)
- [åŸå­åŒ–çŠ¶æ€ç®¡ç†](#åŸå­åŒ–çŠ¶æ€ç®¡ç†)
- [æœåŠ¡ç«¯çŠ¶æ€ç®¡ç†](#æœåŠ¡ç«¯çŠ¶æ€ç®¡ç†)
- [çŠ¶æ€ç®¡ç†æ¶æ„è®¾è®¡](#çŠ¶æ€ç®¡ç†æ¶æ„è®¾è®¡)
- [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
- [æµ‹è¯•ç­–ç•¥ä¸å®è·µ](#æµ‹è¯•ç­–ç•¥ä¸å®è·µ)
- [ä¼ä¸šçº§æ²»ç†å®è·µ](#ä¼ä¸šçº§æ²»ç†å®è·µ)
- [Mall-FrontendçŠ¶æ€æ¶æ„](#mall-frontendçŠ¶æ€æ¶æ„)
- [é¢è¯•å¸¸è€ƒçŸ¥è¯†ç‚¹](#é¢è¯•å¸¸è€ƒçŸ¥è¯†ç‚¹)
- [å®æˆ˜ç»ƒä¹ ](#å®æˆ˜ç»ƒä¹ )

---

## ğŸ¯ çŠ¶æ€ç®¡ç†åŸºç¡€ç†è®º

### çŠ¶æ€çš„åˆ†ç±»å’Œç‰¹å¾

åœ¨ç°ä»£å‰ç«¯åº”ç”¨ä¸­ï¼ŒçŠ¶æ€å¯ä»¥æŒ‰ç…§ä¸åŒçš„ç»´åº¦è¿›è¡Œåˆ†ç±»ï¼š

```typescript
// çŠ¶æ€åˆ†ç±»ä½“ç³»
interface StateClassification {
  // æŒ‰ä½œç”¨åŸŸåˆ†ç±»
  scope: {
    local: 'ç»„ä»¶å†…éƒ¨çŠ¶æ€';
    shared: 'ç»„ä»¶é—´å…±äº«çŠ¶æ€';
    global: 'å…¨å±€åº”ç”¨çŠ¶æ€';
  };
  
  // æŒ‰æ•°æ®æºåˆ†ç±»
  source: {
    client: 'å®¢æˆ·ç«¯çŠ¶æ€';
    server: 'æœåŠ¡ç«¯çŠ¶æ€';
    url: 'URLçŠ¶æ€';
    form: 'è¡¨å•çŠ¶æ€';
  };
  
  // æŒ‰ç”Ÿå‘½å‘¨æœŸåˆ†ç±»
  lifecycle: {
    ephemeral: 'ä¸´æ—¶çŠ¶æ€';
    session: 'ä¼šè¯çŠ¶æ€';
    persistent: 'æŒä¹…åŒ–çŠ¶æ€';
  };
  
  // æŒ‰å˜æ›´é¢‘ç‡åˆ†ç±»
  frequency: {
    static: 'é™æ€çŠ¶æ€';
    dynamic: 'åŠ¨æ€çŠ¶æ€';
    realtime: 'å®æ—¶çŠ¶æ€';
  };
}

// çŠ¶æ€ç®¡ç†åŸåˆ™
const stateManagementPrinciples = {
  // 1. å•ä¸€æ•°æ®æº (Single Source of Truth)
  singleSource: {
    principle: 'æ¯ä¸ªçŠ¶æ€éƒ½åº”è¯¥æœ‰å”¯ä¸€çš„æ•°æ®æº',
    benefits: ['é¿å…æ•°æ®ä¸ä¸€è‡´', 'ç®€åŒ–è°ƒè¯•', 'æé«˜å¯é¢„æµ‹æ€§'],
    implementation: `
      // âŒ å¤šä¸ªæ•°æ®æº
      const [userA, setUserA] = useState(user);
      const [userB, setUserB] = useState(user);
      
      // âœ… å•ä¸€æ•°æ®æº
      const user = useUserStore(state => state.user);
    `
  },
  
  // 2. çŠ¶æ€ä¸å¯å˜æ€§ (Immutability)
  immutability: {
    principle: 'çŠ¶æ€åº”è¯¥æ˜¯ä¸å¯å˜çš„ï¼Œé€šè¿‡åˆ›å»ºæ–°çŠ¶æ€æ¥æ›´æ–°',
    benefits: ['æ—¶é—´æ—…è¡Œè°ƒè¯•', 'æ€§èƒ½ä¼˜åŒ–', 'é¿å…å‰¯ä½œç”¨'],
    implementation: `
      // âŒ ç›´æ¥ä¿®æ”¹çŠ¶æ€
      state.user.name = 'New Name';
      
      // âœ… åˆ›å»ºæ–°çŠ¶æ€
      setState(prevState => ({
        ...prevState,
        user: {
          ...prevState.user,
          name: 'New Name'
        }
      }));
    `
  },
  
  // 3. å¯é¢„æµ‹æ€§ (Predictability)
  predictability: {
    principle: 'ç›¸åŒçš„è¾“å…¥åº”è¯¥äº§ç”Ÿç›¸åŒçš„è¾“å‡º',
    benefits: ['æ˜“äºæµ‹è¯•', 'ä¾¿äºè°ƒè¯•', 'æé«˜å¯é æ€§'],
    implementation: `
      // âœ… çº¯å‡½æ•°reducer
      function userReducer(state, action) {
        switch (action.type) {
          case 'UPDATE_NAME':
            return { ...state, name: action.payload };
          default:
            return state;
        }
      }
    `
  },
  
  // 4. æœ€å°åŒ–çŠ¶æ€ (Minimal State)
  minimalState: {
    principle: 'åªå­˜å‚¨å¿…è¦çš„çŠ¶æ€ï¼Œæ´¾ç”ŸçŠ¶æ€åº”è¯¥é€šè¿‡è®¡ç®—å¾—å‡º',
    benefits: ['å‡å°‘å¤æ‚æ€§', 'é¿å…åŒæ­¥é—®é¢˜', 'æé«˜æ€§èƒ½'],
    implementation: `
      // âŒ å­˜å‚¨æ´¾ç”ŸçŠ¶æ€
      interface State {
        items: Item[];
        totalPrice: number; // æ´¾ç”ŸçŠ¶æ€
        itemCount: number;  // æ´¾ç”ŸçŠ¶æ€
      }
      
      // âœ… åªå­˜å‚¨å¿…è¦çŠ¶æ€
      interface State {
        items: Item[];
      }
      
      // æ´¾ç”ŸçŠ¶æ€é€šè¿‡é€‰æ‹©å™¨è®¡ç®—
      const totalPrice = useSelector(state => 
        state.items.reduce((sum, item) => sum + item.price, 0)
      );
    `
  }
};
```

### çŠ¶æ€ç®¡ç†æ¨¡å¼æ¼”è¿›

```typescript
// çŠ¶æ€ç®¡ç†æ¨¡å¼çš„å†å²æ¼”è¿›
const stateManagementEvolution = {
  // 1. åŸå§‹æ—¶ä»£ - ç›´æ¥DOMæ“ä½œ
  primitive: {
    period: '2010å¹´ä»¥å‰',
    approach: 'ç›´æ¥æ“ä½œDOMï¼Œä½¿ç”¨å…¨å±€å˜é‡',
    problems: ['çŠ¶æ€æ•£ä¹±', 'éš¾ä»¥ç»´æŠ¤', 'å®¹æ˜“å‡ºé”™'],
    example: `
      // jQueryæ—¶ä»£çš„çŠ¶æ€ç®¡ç†
      let currentUser = null;
      
      function updateUser(user) {
        currentUser = user;
        $('#username').text(user.name);
        $('#avatar').attr('src', user.avatar);
      }
    `
  },
  
  // 2. MVCæ—¶ä»£ - æ¨¡å‹è§†å›¾åˆ†ç¦»
  mvc: {
    period: '2010-2013',
    approach: 'Backbone.js, Angular 1.xçš„åŒå‘ç»‘å®š',
    problems: ['åŒå‘ç»‘å®šå¤æ‚', 'éš¾ä»¥è°ƒè¯•', 'æ€§èƒ½é—®é¢˜'],
    example: `
      // Backbone.jsæ¨¡å¼
      const UserModel = Backbone.Model.extend({
        defaults: { name: '', email: '' }
      });
      
      const UserView = Backbone.View.extend({
        render: function() {
          this.$el.html(template(this.model.toJSON()));
        }
      });
    `
  },
  
  // 3. Fluxæ—¶ä»£ - å•å‘æ•°æ®æµ
  flux: {
    period: '2014-2015',
    approach: 'Facebook Fluxæ¶æ„ï¼Œå•å‘æ•°æ®æµ',
    benefits: ['å¯é¢„æµ‹æ€§', 'æ˜“äºè°ƒè¯•', 'æ¸…æ™°çš„æ•°æ®æµ'],
    example: `
      // Fluxæ¶æ„
      Action -> Dispatcher -> Store -> View -> Action
      
      // Action
      const UserActions = {
        updateUser: (user) => ({
          type: 'UPDATE_USER',
          payload: user
        })
      };
    `
  },
  
  // 4. Reduxæ—¶ä»£ - å‡½æ•°å¼çŠ¶æ€ç®¡ç†
  redux: {
    period: '2015-2019',
    approach: 'Reduxçš„å‡½æ•°å¼çŠ¶æ€ç®¡ç†',
    benefits: ['æ—¶é—´æ—…è¡Œ', 'ä¸­é—´ä»¶æ”¯æŒ', 'å¼ºå¤§çš„ç”Ÿæ€'],
    problems: ['æ ·æ¿ä»£ç å¤š', 'å­¦ä¹ æ›²çº¿é™¡å³­'],
    example: `
      // Reduxæ¨¡å¼
      const userReducer = (state = initialState, action) => {
        switch (action.type) {
          case 'UPDATE_USER':
            return { ...state, user: action.payload };
          default:
            return state;
        }
      };
    `
  },
  
  // 5. ç°ä»£æ—¶ä»£ - å¤šæ ·åŒ–æ–¹æ¡ˆ
  modern: {
    period: '2019è‡³ä»Š',
    approach: 'Hooksã€Zustandã€Jotaiç­‰è½»é‡åŒ–æ–¹æ¡ˆ',
    benefits: ['ç®€åŒ–API', 'æ›´å¥½çš„TypeScriptæ”¯æŒ', 'æ›´å°çš„åŒ…ä½“ç§¯'],
    trends: ['åŸå­åŒ–çŠ¶æ€', 'æœåŠ¡ç«¯çŠ¶æ€åˆ†ç¦»', 'ç±»å‹å®‰å…¨']
  }
};
```

### çŠ¶æ€ç®¡ç†å†³ç­–æ ‘

```typescript
// çŠ¶æ€ç®¡ç†æ–¹æ¡ˆé€‰æ‹©å†³ç­–æ ‘
const stateManagementDecisionTree = {
  questions: [
    {
      id: 1,
      question: 'çŠ¶æ€æ˜¯å¦éœ€è¦åœ¨å¤šä¸ªç»„ä»¶é—´å…±äº«ï¼Ÿ',
      no: {
        recommendation: 'useState / useReducer',
        reason: 'æœ¬åœ°çŠ¶æ€è¶³å¤Ÿï¼Œæ— éœ€å¼•å…¥å¤æ‚çš„çŠ¶æ€ç®¡ç†'
      },
      yes: { nextQuestion: 2 }
    },
    {
      id: 2,
      question: 'åº”ç”¨è§„æ¨¡æ˜¯å¦è¾ƒå¤§ï¼ˆ>100ä¸ªç»„ä»¶ï¼‰ï¼Ÿ',
      no: {
        recommendation: 'Context API + useReducer',
        reason: 'ä¸­å°å‹åº”ç”¨ï¼ŒContext APIè¶³å¤Ÿåº”å¯¹'
      },
      yes: { nextQuestion: 3 }
    },
    {
      id: 3,
      question: 'å›¢é˜Ÿæ˜¯å¦ç†Ÿæ‚‰å‡½æ•°å¼ç¼–ç¨‹ï¼Ÿ',
      yes: {
        recommendation: 'Redux Toolkit',
        reason: 'å¤§å‹åº”ç”¨ï¼Œéœ€è¦å¼ºå¤§çš„çŠ¶æ€ç®¡ç†å’Œè°ƒè¯•å·¥å…·'
      },
      no: { nextQuestion: 4 }
    },
    {
      id: 4,
      question: 'æ˜¯å¦éœ€è¦å¤æ‚çš„å¼‚æ­¥é€»è¾‘ï¼Ÿ',
      yes: {
        recommendation: 'Redux Toolkit + RTK Query',
        reason: 'å¤æ‚å¼‚æ­¥åœºæ™¯ï¼ŒReduxç”Ÿæ€æ›´æˆç†Ÿ'
      },
      no: {
        recommendation: 'Zustand',
        reason: 'ç®€å•æ˜“ç”¨ï¼Œå­¦ä¹ æˆæœ¬ä½'
      }
    }
  ],
  
  // ç‰¹æ®Šåœºæ™¯æ¨è
  specialCases: {
    formManagement: {
      recommendation: 'React Hook Form + Zod',
      reason: 'ä¸“é—¨çš„è¡¨å•çŠ¶æ€ç®¡ç†ï¼Œæ€§èƒ½æ›´å¥½'
    },
    serverState: {
      recommendation: 'React Query / SWR',
      reason: 'æœåŠ¡ç«¯çŠ¶æ€æœ‰ç‰¹æ®Šéœ€æ±‚ï¼Œéœ€è¦ä¸“é—¨çš„è§£å†³æ–¹æ¡ˆ'
    },
    realTimeData: {
      recommendation: 'Zustand + WebSocket',
      reason: 'å®æ—¶æ•°æ®éœ€è¦å“åº”å¼æ›´æ–°'
    },
    atomicState: {
      recommendation: 'Jotai / Recoil',
      reason: 'ç»†ç²’åº¦çŠ¶æ€ç®¡ç†ï¼Œé¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“'
    }
  }
};
```

### çŠ¶æ€ç®¡ç†æ€§èƒ½è€ƒé‡

```typescript
// æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
const performanceConsiderations = {
  // 1. é‡æ¸²æŸ“ä¼˜åŒ–
  reRenderOptimization: {
    problems: ['ä¸å¿…è¦çš„é‡æ¸²æŸ“', 'æ€§èƒ½ç“¶é¢ˆ', 'ç”¨æˆ·ä½“éªŒå·®'],
    solutions: [
      'React.memo',
      'useMemo',
      'useCallback',
      'çŠ¶æ€åˆ†å‰²',
      'é€‰æ‹©å™¨ä¼˜åŒ–'
    ],
    example: `
      // âŒ ä¼šå¯¼è‡´æ‰€æœ‰ç»„ä»¶é‡æ¸²æŸ“
      const globalState = {
        user: { ... },
        products: [ ... ],
        cart: [ ... ],
        ui: { ... }
      };
      
      // âœ… çŠ¶æ€åˆ†å‰²ï¼Œå‡å°‘é‡æ¸²æŸ“
      const userStore = create((set) => ({ ... }));
      const productStore = create((set) => ({ ... }));
      const cartStore = create((set) => ({ ... }));
    `
  },
  
  // 2. å†…å­˜ä¼˜åŒ–
  memoryOptimization: {
    strategies: [
      'çŠ¶æ€æ¸…ç†',
      'å¼±å¼•ç”¨',
      'åˆ†é¡µåŠ è½½',
      'è™šæ‹Ÿæ»šåŠ¨'
    ],
    example: `
      // ç»„ä»¶å¸è½½æ—¶æ¸…ç†çŠ¶æ€
      useEffect(() => {
        return () => {
          // æ¸…ç†å¤§å‹æ•°æ®
          clearLargeDataSet();
        };
      }, []);
    `
  },
  
  // 3. ç½‘ç»œä¼˜åŒ–
  networkOptimization: {
    techniques: [
      'è¯·æ±‚å»é‡',
      'ç¼“å­˜ç­–ç•¥',
      'ä¹è§‚æ›´æ–°',
      'æ‰¹é‡è¯·æ±‚'
    ]
  }
};
```

---

## ğŸ”„ çŠ¶æ€ç®¡ç†æ–¹æ¡ˆæ·±åº¦å¯¹æ¯”

### ä¸»æµæ–¹æ¡ˆæŠ€æœ¯å¯¹æ¯”

```typescript
// çŠ¶æ€ç®¡ç†æ–¹æ¡ˆå¯¹æ¯”çŸ©é˜µ
interface StateManagementSolution {
  name: string;
  bundleSize: string;
  learningCurve: 'Easy' | 'Medium' | 'Hard';
  typescript: 'Excellent' | 'Good' | 'Basic';
  devtools: boolean;
  middleware: boolean;
  persistence: boolean;
  ssr: boolean;
  performance: 'Excellent' | 'Good' | 'Average';
  ecosystem: 'Rich' | 'Growing' | 'Limited';
  useCase: string[];
}

const stateManagementComparison: StateManagementSolution[] = [
  {
    name: 'Redux Toolkit',
    bundleSize: '~47kb',
    learningCurve: 'Hard',
    typescript: 'Excellent',
    devtools: true,
    middleware: true,
    persistence: true,
    ssr: true,
    performance: 'Good',
    ecosystem: 'Rich',
    useCase: ['å¤§å‹åº”ç”¨', 'å¤æ‚çŠ¶æ€é€»è¾‘', 'æ—¶é—´æ—…è¡Œè°ƒè¯•', 'å›¢é˜Ÿåä½œ']
  },
  {
    name: 'Zustand',
    bundleSize: '~2.5kb',
    learningCurve: 'Easy',
    typescript: 'Excellent',
    devtools: true,
    middleware: true,
    persistence: true,
    ssr: true,
    performance: 'Excellent',
    ecosystem: 'Growing',
    useCase: ['ä¸­å°å‹åº”ç”¨', 'å¿«é€ŸåŸå‹', 'ç®€å•çŠ¶æ€ç®¡ç†', 'æ€§èƒ½æ•æ„Ÿ']
  },
  {
    name: 'Context API',
    bundleSize: '0kb (å†…ç½®)',
    learningCurve: 'Medium',
    typescript: 'Good',
    devtools: false,
    middleware: false,
    persistence: false,
    ssr: true,
    performance: 'Average',
    ecosystem: 'Limited',
    useCase: ['ä¸»é¢˜ç®¡ç†', 'ç”¨æˆ·è®¤è¯', 'ç®€å•å…±äº«çŠ¶æ€', 'é¿å…prop drilling']
  },
  {
    name: 'Jotai',
    bundleSize: '~13kb',
    learningCurve: 'Medium',
    typescript: 'Excellent',
    devtools: true,
    middleware: false,
    persistence: true,
    ssr: true,
    performance: 'Excellent',
    ecosystem: 'Growing',
    useCase: ['åŸå­åŒ–çŠ¶æ€', 'ç»†ç²’åº¦æ›´æ–°', 'å¤æ‚ä¾èµ–å…³ç³»', 'æ€§èƒ½ä¼˜åŒ–']
  },
  {
    name: 'Valtio',
    bundleSize: '~9kb',
    learningCurve: 'Easy',
    typescript: 'Good',
    devtools: true,
    middleware: false,
    persistence: false,
    ssr: false,
    performance: 'Excellent',
    ecosystem: 'Limited',
    useCase: ['ä»£ç†çŠ¶æ€', 'ç®€å•API', 'å¿«é€Ÿå¼€å‘', 'åŸå‹éªŒè¯']
  },
  {
    name: 'React Query',
    bundleSize: '~39kb',
    learningCurve: 'Medium',
    typescript: 'Excellent',
    devtools: true,
    middleware: false,
    persistence: true,
    ssr: true,
    performance: 'Excellent',
    ecosystem: 'Rich',
    useCase: ['æœåŠ¡ç«¯çŠ¶æ€', 'ç¼“å­˜ç®¡ç†', 'æ•°æ®åŒæ­¥', 'APIçŠ¶æ€ç®¡ç†']
  }
];

// è¯¦ç»†åŠŸèƒ½å¯¹æ¯”
const featureComparison = {
  // 1. APIè®¾è®¡å¯¹æ¯”
  apiDesign: {
    redux: {
      complexity: 'High',
      boilerplate: 'Much',
      example: `
        // Redux Toolkit
        const userSlice = createSlice({
          name: 'user',
          initialState: { name: '', email: '' },
          reducers: {
            updateUser: (state, action) => {
              state.name = action.payload.name;
              state.email = action.payload.email;
            }
          }
        });

        // ä½¿ç”¨
        const dispatch = useDispatch();
        const user = useSelector(state => state.user);
        dispatch(userSlice.actions.updateUser({ name: 'John', email: 'john@example.com' }));
      `
    },
    zustand: {
      complexity: 'Low',
      boilerplate: 'Minimal',
      example: `
        // Zustand
        const useUserStore = create((set) => ({
          name: '',
          email: '',
          updateUser: (user) => set({ name: user.name, email: user.email })
        }));

        // ä½¿ç”¨
        const { name, email, updateUser } = useUserStore();
        updateUser({ name: 'John', email: 'john@example.com' });
      `
    },
    context: {
      complexity: 'Medium',
      boilerplate: 'Medium',
      example: `
        // Context API
        const UserContext = createContext();

        function UserProvider({ children }) {
          const [user, setUser] = useState({ name: '', email: '' });

          const updateUser = (newUser) => {
            setUser(prev => ({ ...prev, ...newUser }));
          };

          return (
            <UserContext.Provider value={{ user, updateUser }}>
              {children}
            </UserContext.Provider>
          );
        }

        // ä½¿ç”¨
        const { user, updateUser } = useContext(UserContext);
      `
    },
    jotai: {
      complexity: 'Medium',
      boilerplate: 'Low',
      example: `
        // Jotai
        const nameAtom = atom('');
        const emailAtom = atom('');
        const userAtom = atom(
          (get) => ({ name: get(nameAtom), email: get(emailAtom) }),
          (get, set, user) => {
            set(nameAtom, user.name);
            set(emailAtom, user.email);
          }
        );

        // ä½¿ç”¨
        const [user, setUser] = useAtom(userAtom);
        setUser({ name: 'John', email: 'john@example.com' });
      `
    }
  }
};
```

---

## ğŸ—ï¸ Reduxç”Ÿæ€ç³»ç»Ÿæ¶æ„

### Redux Toolkitç°ä»£åŒ–å®è·µ

Redux Toolkit (RTK) æ˜¯Reduxå®˜æ–¹æ¨èçš„ç°ä»£åŒ–å¼€å‘æ–¹å¼ï¼Œå¤§å¤§ç®€åŒ–äº†Reduxçš„ä½¿ç”¨ï¼š

```typescript
// Redux Toolkit å®Œæ•´æ¶æ„ç¤ºä¾‹
// store/index.ts - Storeé…ç½®
import { configureStore } from '@reduxjs/toolkit';
import { setupListeners } from '@reduxjs/toolkit/query';
import { persistStore, persistReducer } from 'redux-persist';
import storage from 'redux-persist/lib/storage';

import userSlice from './slices/userSlice';
import productSlice from './slices/productSlice';
import cartSlice from './slices/cartSlice';
import { apiSlice } from './api/apiSlice';

// æŒä¹…åŒ–é…ç½®
const persistConfig = {
  key: 'root',
  storage,
  whitelist: ['user', 'cart'], // åªæŒä¹…åŒ–ç”¨æˆ·å’Œè´­ç‰©è½¦çŠ¶æ€
};

const persistedUserReducer = persistReducer(persistConfig, userSlice.reducer);

// é…ç½®Store
export const store = configureStore({
  reducer: {
    user: persistedUserReducer,
    product: productSlice.reducer,
    cart: cartSlice.reducer,
    api: apiSlice.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE'],
      },
    }).concat(apiSlice.middleware),
  devTools: process.env.NODE_ENV !== 'production',
});

// è®¾ç½®RTK Queryç›‘å¬å™¨
setupListeners(store.dispatch);

export const persistor = persistStore(store);
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// store/slices/userSlice.ts - ç”¨æˆ·çŠ¶æ€åˆ‡ç‰‡
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { User, LoginCredentials } from '@/types/user';
import { authApi } from '@/services/authApi';

interface UserState {
  currentUser: User | null;
  isAuthenticated: boolean;
  loading: boolean;
  error: string | null;
  preferences: {
    theme: 'light' | 'dark';
    language: string;
    notifications: boolean;
  };
}

const initialState: UserState = {
  currentUser: null,
  isAuthenticated: false,
  loading: false,
  error: null,
  preferences: {
    theme: 'light',
    language: 'zh-CN',
    notifications: true,
  },
};

// å¼‚æ­¥Thunk
export const loginUser = createAsyncThunk(
  'user/login',
  async (credentials: LoginCredentials, { rejectWithValue }) => {
    try {
      const response = await authApi.login(credentials);
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || 'Login failed');
    }
  }
);

export const fetchUserProfile = createAsyncThunk(
  'user/fetchProfile',
  async (_, { getState, rejectWithValue }) => {
    try {
      const state = getState() as RootState;
      if (!state.user.isAuthenticated) {
        throw new Error('User not authenticated');
      }

      const response = await authApi.getProfile();
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || 'Failed to fetch profile');
    }
  }
);

export const updateUserPreferences = createAsyncThunk(
  'user/updatePreferences',
  async (preferences: Partial<UserState['preferences']>, { getState, rejectWithValue }) => {
    try {
      const state = getState() as RootState;
      const updatedPreferences = { ...state.user.preferences, ...preferences };

      await authApi.updatePreferences(updatedPreferences);
      return updatedPreferences;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || 'Failed to update preferences');
    }
  }
);

// Sliceå®šä¹‰
const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    // åŒæ­¥actions
    logout: (state) => {
      state.currentUser = null;
      state.isAuthenticated = false;
      state.error = null;
    },

    clearError: (state) => {
      state.error = null;
    },

    updateLocalPreferences: (state, action: PayloadAction<Partial<UserState['preferences']>>) => {
      state.preferences = { ...state.preferences, ...action.payload };
    },

    setUser: (state, action: PayloadAction<User>) => {
      state.currentUser = action.payload;
      state.isAuthenticated = true;
    },
  },

  // å¼‚æ­¥actionsçš„å¤„ç†
  extraReducers: (builder) => {
    builder
      // ç™»å½•
      .addCase(loginUser.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.loading = false;
        state.currentUser = action.payload.user;
        state.isAuthenticated = true;
        state.error = null;
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
        state.isAuthenticated = false;
      })

      // è·å–ç”¨æˆ·èµ„æ–™
      .addCase(fetchUserProfile.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchUserProfile.fulfilled, (state, action) => {
        state.loading = false;
        state.currentUser = action.payload;
      })
      .addCase(fetchUserProfile.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })

      // æ›´æ–°åå¥½è®¾ç½®
      .addCase(updateUserPreferences.fulfilled, (state, action) => {
        state.preferences = action.payload;
      });
  },
});

export const { logout, clearError, updateLocalPreferences, setUser } = userSlice.actions;
export default userSlice;

// store/slices/cartSlice.ts - è´­ç‰©è½¦çŠ¶æ€åˆ‡ç‰‡
import { createSlice, createSelector, PayloadAction } from '@reduxjs/toolkit';
import { Product } from '@/types/product';

interface CartItem {
  product: Product;
  quantity: number;
  selectedOptions?: Record<string, string>;
}

interface CartState {
  items: CartItem[];
  isOpen: boolean;
  lastUpdated: number;
}

const initialState: CartState = {
  items: [],
  isOpen: false,
  lastUpdated: Date.now(),
};

const cartSlice = createSlice({
  name: 'cart',
  initialState,
  reducers: {
    addToCart: (state, action: PayloadAction<{ product: Product; quantity?: number; options?: Record<string, string> }>) => {
      const { product, quantity = 1, options = {} } = action.payload;

      // æŸ¥æ‰¾æ˜¯å¦å·²å­˜åœ¨ç›¸åŒå•†å“å’Œé€‰é¡¹çš„é¡¹ç›®
      const existingItemIndex = state.items.findIndex(
        item =>
          item.product.id === product.id &&
          JSON.stringify(item.selectedOptions) === JSON.stringify(options)
      );

      if (existingItemIndex >= 0) {
        // æ›´æ–°æ•°é‡
        state.items[existingItemIndex].quantity += quantity;
      } else {
        // æ·»åŠ æ–°é¡¹ç›®
        state.items.push({
          product,
          quantity,
          selectedOptions: options,
        });
      }

      state.lastUpdated = Date.now();
    },

    removeFromCart: (state, action: PayloadAction<{ productId: string; options?: Record<string, string> }>) => {
      const { productId, options = {} } = action.payload;

      state.items = state.items.filter(
        item => !(
          item.product.id === productId &&
          JSON.stringify(item.selectedOptions) === JSON.stringify(options)
        )
      );

      state.lastUpdated = Date.now();
    },

    updateQuantity: (state, action: PayloadAction<{ productId: string; quantity: number; options?: Record<string, string> }>) => {
      const { productId, quantity, options = {} } = action.payload;

      const itemIndex = state.items.findIndex(
        item =>
          item.product.id === productId &&
          JSON.stringify(item.selectedOptions) === JSON.stringify(options)
      );

      if (itemIndex >= 0) {
        if (quantity <= 0) {
          state.items.splice(itemIndex, 1);
        } else {
          state.items[itemIndex].quantity = quantity;
        }
        state.lastUpdated = Date.now();
      }
    },

    clearCart: (state) => {
      state.items = [];
      state.lastUpdated = Date.now();
    },

    toggleCart: (state) => {
      state.isOpen = !state.isOpen;
    },

    setCartOpen: (state, action: PayloadAction<boolean>) => {
      state.isOpen = action.payload;
    },
  },
});

export const {
  addToCart,
  removeFromCart,
  updateQuantity,
  clearCart,
  toggleCart,
  setCartOpen
} = cartSlice.actions;

export default cartSlice;

// é€‰æ‹©å™¨ (Selectors)
export const selectCartItems = (state: RootState) => state.cart.items;
export const selectCartIsOpen = (state: RootState) => state.cart.isOpen;

// è®°å¿†åŒ–é€‰æ‹©å™¨
export const selectCartTotal = createSelector(
  [selectCartItems],
  (items) => items.reduce((total, item) => total + (parseFloat(item.product.price) * item.quantity), 0)
);

export const selectCartItemCount = createSelector(
  [selectCartItems],
  (items) => items.reduce((count, item) => count + item.quantity, 0)
);

export const selectCartItemsByCategory = createSelector(
  [selectCartItems],
  (items) => {
    const grouped: Record<string, CartItem[]> = {};
    items.forEach(item => {
      const category = item.product.categoryId;
      if (!grouped[category]) {
        grouped[category] = [];
      }
      grouped[category].push(item);
    });
    return grouped;
  }
);
```

---

## âš¡ Zustandè½»é‡çº§æ–¹æ¡ˆ

### Zustandæ ¸å¿ƒæ¶æ„

Zustandæ˜¯ä¸€ä¸ªè½»é‡çº§çš„çŠ¶æ€ç®¡ç†åº“ï¼Œæä¾›äº†ç®€æ´çš„APIå’Œä¼˜ç§€çš„TypeScriptæ”¯æŒï¼š

```typescript
// stores/userStore.ts - Zustandç”¨æˆ·çŠ¶æ€ç®¡ç†
import { create } from 'zustand';
import { devtools, persist, subscribeWithSelector } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import { User, LoginCredentials } from '@/types/user';
import { authApi } from '@/services/authApi';

interface UserState {
  // çŠ¶æ€
  currentUser: User | null;
  isAuthenticated: boolean;
  loading: boolean;
  error: string | null;
  preferences: {
    theme: 'light' | 'dark';
    language: string;
    notifications: boolean;
  };

  // Actions
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  fetchProfile: () => Promise<void>;
  updatePreferences: (preferences: Partial<UserState['preferences']>) => Promise<void>;
  clearError: () => void;
  setUser: (user: User) => void;
}

export const useUserStore = create<UserState>()(
  devtools(
    persist(
      subscribeWithSelector(
        immer((set, get) => ({
          // åˆå§‹çŠ¶æ€
          currentUser: null,
          isAuthenticated: false,
          loading: false,
          error: null,
          preferences: {
            theme: 'light',
            language: 'zh-CN',
            notifications: true,
          },

          // Actions
          login: async (credentials) => {
            set((state) => {
              state.loading = true;
              state.error = null;
            });

            try {
              const response = await authApi.login(credentials);
              set((state) => {
                state.currentUser = response.data.user;
                state.isAuthenticated = true;
                state.loading = false;
              });
            } catch (error: any) {
              set((state) => {
                state.error = error.response?.data?.message || 'Login failed';
                state.loading = false;
                state.isAuthenticated = false;
              });
            }
          },

          logout: () => {
            set((state) => {
              state.currentUser = null;
              state.isAuthenticated = false;
              state.error = null;
            });
          },

          fetchProfile: async () => {
            const { isAuthenticated } = get();
            if (!isAuthenticated) {
              throw new Error('User not authenticated');
            }

            set((state) => {
              state.loading = true;
            });

            try {
              const response = await authApi.getProfile();
              set((state) => {
                state.currentUser = response.data;
                state.loading = false;
              });
            } catch (error: any) {
              set((state) => {
                state.error = error.response?.data?.message || 'Failed to fetch profile';
                state.loading = false;
              });
            }
          },

          updatePreferences: async (newPreferences) => {
            const { preferences } = get();
            const updatedPreferences = { ...preferences, ...newPreferences };

            try {
              await authApi.updatePreferences(updatedPreferences);
              set((state) => {
                state.preferences = updatedPreferences;
              });
            } catch (error: any) {
              set((state) => {
                state.error = error.response?.data?.message || 'Failed to update preferences';
              });
            }
          },

          clearError: () => {
            set((state) => {
              state.error = null;
            });
          },

          setUser: (user) => {
            set((state) => {
              state.currentUser = user;
              state.isAuthenticated = true;
            });
          },
        }))
      ),
      {
        name: 'user-store',
        partialize: (state) => ({
          currentUser: state.currentUser,
          isAuthenticated: state.isAuthenticated,
          preferences: state.preferences,
        }),
      }
    ),
    { name: 'user-store' }
  )
);

// é€‰æ‹©å™¨
export const useUser = () => useUserStore((state) => state.currentUser);
export const useIsAuthenticated = () => useUserStore((state) => state.isAuthenticated);
export const useUserLoading = () => useUserStore((state) => state.loading);
export const useUserError = () => useUserStore((state) => state.error);
export const useUserPreferences = () => useUserStore((state) => state.preferences);

// stores/cartStore.ts - Zustandè´­ç‰©è½¦çŠ¶æ€ç®¡ç†
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import { Product } from '@/types/product';

interface CartItem {
  product: Product;
  quantity: number;
  selectedOptions?: Record<string, string>;
}

interface CartState {
  items: CartItem[];
  isOpen: boolean;
  lastUpdated: number;

  // Actions
  addToCart: (product: Product, quantity?: number, options?: Record<string, string>) => void;
  removeFromCart: (productId: string, options?: Record<string, string>) => void;
  updateQuantity: (productId: string, quantity: number, options?: Record<string, string>) => void;
  clearCart: () => void;
  toggleCart: () => void;
  setCartOpen: (isOpen: boolean) => void;

  // Computed
  getTotalPrice: () => number;
  getItemCount: () => number;
  getItemsByCategory: () => Record<string, CartItem[]>;
}

export const useCartStore = create<CartState>()(
  devtools(
    persist(
      immer((set, get) => ({
        items: [],
        isOpen: false,
        lastUpdated: Date.now(),

        addToCart: (product, quantity = 1, options = {}) => {
          set((state) => {
            const existingItemIndex = state.items.findIndex(
              item =>
                item.product.id === product.id &&
                JSON.stringify(item.selectedOptions) === JSON.stringify(options)
            );

            if (existingItemIndex >= 0) {
              state.items[existingItemIndex].quantity += quantity;
            } else {
              state.items.push({
                product,
                quantity,
                selectedOptions: options,
              });
            }

            state.lastUpdated = Date.now();
          });
        },

        removeFromCart: (productId, options = {}) => {
          set((state) => {
            state.items = state.items.filter(
              item => !(
                item.product.id === productId &&
                JSON.stringify(item.selectedOptions) === JSON.stringify(options)
              )
            );
            state.lastUpdated = Date.now();
          });
        },

        updateQuantity: (productId, quantity, options = {}) => {
          set((state) => {
            const itemIndex = state.items.findIndex(
              item =>
                item.product.id === productId &&
                JSON.stringify(item.selectedOptions) === JSON.stringify(options)
            );

            if (itemIndex >= 0) {
              if (quantity <= 0) {
                state.items.splice(itemIndex, 1);
              } else {
                state.items[itemIndex].quantity = quantity;
              }
              state.lastUpdated = Date.now();
            }
          });
        },

        clearCart: () => {
          set((state) => {
            state.items = [];
            state.lastUpdated = Date.now();
          });
        },

        toggleCart: () => {
          set((state) => {
            state.isOpen = !state.isOpen;
          });
        },

        setCartOpen: (isOpen) => {
          set((state) => {
            state.isOpen = isOpen;
          });
        },

        // Computed values
        getTotalPrice: () => {
          const { items } = get();
          return items.reduce((total, item) => total + (parseFloat(item.product.price) * item.quantity), 0);
        },

        getItemCount: () => {
          const { items } = get();
          return items.reduce((count, item) => count + item.quantity, 0);
        },

        getItemsByCategory: () => {
          const { items } = get();
          const grouped: Record<string, CartItem[]> = {};
          items.forEach(item => {
            const category = item.product.categoryId;
            if (!grouped[category]) {
              grouped[category] = [];
            }
            grouped[category].push(item);
          });
          return grouped;
        },
      })),
      {
        name: 'cart-store',
        partialize: (state) => ({
          items: state.items,
          lastUpdated: state.lastUpdated,
        }),
      }
    ),
    { name: 'cart-store' }
  )
);

// é€‰æ‹©å™¨Hooks
export const useCartItems = () => useCartStore((state) => state.items);
export const useCartIsOpen = () => useCartStore((state) => state.isOpen);
export const useCartTotal = () => useCartStore((state) => state.getTotalPrice());
export const useCartItemCount = () => useCartStore((state) => state.getItemCount());
```

### Zustandé«˜çº§æ¨¡å¼

```typescript
// stores/storeFactory.ts - Storeå·¥å‚æ¨¡å¼
import { create, StateCreator } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

// é€šç”¨Storeæ¥å£
interface BaseState {
  loading: boolean;
  error: string | null;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  clearError: () => void;
}

// åŸºç¡€Storeåˆ›å»ºå™¨
const createBaseSlice: StateCreator<BaseState> = (set) => ({
  loading: false,
  error: null,

  setLoading: (loading) => set({ loading }),
  setError: (error) => set({ error }),
  clearError: () => set({ error: null }),
});

// å¼‚æ­¥æ“ä½œMixin
interface AsyncMixin {
  executeAsync: <T>(asyncFn: () => Promise<T>) => Promise<T>;
}

const createAsyncMixin = <T extends BaseState>(): StateCreator<T & AsyncMixin, [], [], AsyncMixin> =>
  (set, get) => ({
    executeAsync: async (asyncFn) => {
      set({ loading: true, error: null } as Partial<T & AsyncMixin>);

      try {
        const result = await asyncFn();
        set({ loading: false } as Partial<T & AsyncMixin>);
        return result;
      } catch (error: any) {
        set({
          loading: false,
          error: error.message || 'An error occurred'
        } as Partial<T & AsyncMixin>);
        throw error;
      }
    },
  });

// ä½¿ç”¨å·¥å‚åˆ›å»ºç‰¹å®šStore
export function createEntityStore<T>(
  name: string,
  initialState: T,
  actions: (set: any, get: any) => Record<string, any>
) {
  return create(
    devtools(
      persist(
        (set, get) => ({
          ...initialState,
          ...createBaseSlice(set, get),
          ...createAsyncMixin<BaseState>()(set, get, {} as any),
          ...actions(set, get),
        }),
        { name }
      ),
      { name }
    )
  );
}

// stores/productStore.ts - ä½¿ç”¨å·¥å‚åˆ›å»ºäº§å“Store
interface ProductState extends BaseState {
  products: Product[];
  selectedProduct: Product | null;
  filters: ProductFilters;

  fetchProducts: () => Promise<void>;
  fetchProduct: (id: string) => Promise<void>;
  setFilters: (filters: Partial<ProductFilters>) => void;
  clearFilters: () => void;
}

export const useProductStore = createEntityStore<Omit<ProductState, keyof BaseState | keyof AsyncMixin>>(
  'product-store',
  {
    products: [],
    selectedProduct: null,
    filters: {},
  },
  (set, get) => ({
    fetchProducts: async () => {
      const { executeAsync } = get();
      return executeAsync(async () => {
        const response = await productApi.getProducts(get().filters);
        set({ products: response.data });
      });
    },

    fetchProduct: async (id: string) => {
      const { executeAsync } = get();
      return executeAsync(async () => {
        const response = await productApi.getProduct(id);
        set({ selectedProduct: response.data });
      });
    },

    setFilters: (newFilters) => {
      set((state) => ({
        filters: { ...state.filters, ...newFilters }
      }));
    },

    clearFilters: () => {
      set({ filters: {} });
    },
  })
);
```

---

## ğŸ¯ é¢è¯•å¸¸è€ƒçŸ¥è¯†ç‚¹

### 1. çŠ¶æ€ç®¡ç†æ–¹æ¡ˆé€‰æ‹©

**Q: å¦‚ä½•ä¸ºé¡¹ç›®é€‰æ‹©åˆé€‚çš„çŠ¶æ€ç®¡ç†æ–¹æ¡ˆï¼Ÿ**

**A: çŠ¶æ€ç®¡ç†æ–¹æ¡ˆé€‰æ‹©å†³ç­–æ¡†æ¶ï¼š**

```typescript
// çŠ¶æ€ç®¡ç†é€‰æ‹©å†³ç­–çŸ©é˜µ
const stateManagementDecisionMatrix = {
  // é¡¹ç›®è§„æ¨¡ç»´åº¦
  projectScale: {
    small: {
      components: '<50ä¸ªç»„ä»¶',
      developers: '1-3äºº',
      recommendation: 'useState + useContext',
      reason: 'ç®€å•ç›´æ¥ï¼Œæ— éœ€å¼•å…¥é¢å¤–å¤æ‚æ€§'
    },
    medium: {
      components: '50-200ä¸ªç»„ä»¶',
      developers: '3-10äºº',
      recommendation: 'Zustand + React Query',
      reason: 'è½»é‡çº§ï¼Œæ˜“äºå­¦ä¹ ï¼Œæ€§èƒ½ä¼˜ç§€'
    },
    large: {
      components: '>200ä¸ªç»„ä»¶',
      developers: '>10äºº',
      recommendation: 'Redux Toolkit + RTK Query',
      reason: 'æ ‡å‡†åŒ–ï¼Œå¼ºå¤§çš„è°ƒè¯•å·¥å…·ï¼Œå›¢é˜Ÿåä½œå‹å¥½'
    }
  },

  // çŠ¶æ€å¤æ‚åº¦ç»´åº¦
  stateComplexity: {
    simple: {
      description: 'ç®€å•CRUDï¼ŒåŸºç¡€çŠ¶æ€',
      recommendation: 'useState + useReducer',
      features: ['æœ¬åœ°çŠ¶æ€', 'ç®€å•æ›´æ–°', 'æ— å¤æ‚é€»è¾‘']
    },
    moderate: {
      description: 'ä¸­ç­‰å¤æ‚åº¦ï¼Œè·¨ç»„ä»¶çŠ¶æ€',
      recommendation: 'Context API + useReducer',
      features: ['å…±äº«çŠ¶æ€', 'ä¸­ç­‰å¤æ‚é€»è¾‘', 'æœ‰é™çš„å¼‚æ­¥æ“ä½œ']
    },
    complex: {
      description: 'å¤æ‚ä¸šåŠ¡é€»è¾‘ï¼Œå¤§é‡å¼‚æ­¥æ“ä½œ',
      recommendation: 'Redux Toolkit',
      features: ['å¤æ‚çŠ¶æ€é€»è¾‘', 'å¤§é‡å¼‚æ­¥æ“ä½œ', 'æ—¶é—´æ—…è¡Œè°ƒè¯•']
    }
  },

  // æ€§èƒ½è¦æ±‚ç»´åº¦
  performanceRequirements: {
    standard: {
      description: 'æ ‡å‡†æ€§èƒ½è¦æ±‚',
      recommendation: 'Zustand',
      optimizations: ['é€‰æ‹©æ€§è®¢é˜…', 'çŠ¶æ€åˆ†å‰²']
    },
    high: {
      description: 'é«˜æ€§èƒ½è¦æ±‚',
      recommendation: 'Jotai',
      optimizations: ['åŸå­åŒ–æ›´æ–°', 'ç»†ç²’åº¦æ§åˆ¶', 'é¿å…ä¸å¿…è¦é‡æ¸²æŸ“']
    },
    extreme: {
      description: 'æè‡´æ€§èƒ½è¦æ±‚',
      recommendation: 'Valtio + æ‰‹åŠ¨ä¼˜åŒ–',
      optimizations: ['ä»£ç†çŠ¶æ€', 'ç²¾ç¡®æ›´æ–°', 'è‡ªå®šä¹‰ä¼˜åŒ–']
    }
  },

  // å›¢é˜ŸæŠ€èƒ½ç»´åº¦
  teamSkills: {
    beginner: {
      description: 'å›¢é˜ŸReactç»éªŒè¾ƒå°‘',
      recommendation: 'Zustand',
      reason: 'APIç®€å•ï¼Œå­¦ä¹ æ›²çº¿å¹³ç¼“'
    },
    intermediate: {
      description: 'å›¢é˜Ÿæœ‰ä¸€å®šReactç»éªŒ',
      recommendation: 'Redux Toolkit',
      reason: 'æ ‡å‡†åŒ–å®è·µï¼Œä¸°å¯Œçš„å­¦ä¹ èµ„æº'
    },
    advanced: {
      description: 'å›¢é˜ŸReactç»éªŒä¸°å¯Œ',
      recommendation: 'æ ¹æ®å…·ä½“éœ€æ±‚é€‰æ‹©',
      reason: 'å¯ä»¥æ ¹æ®é¡¹ç›®ç‰¹ç‚¹é€‰æ‹©æœ€é€‚åˆçš„æ–¹æ¡ˆ'
    }
  }
};

// å¸¸è§é¢è¯•é—®é¢˜å’Œç­”æ¡ˆ
const commonInterviewQuestions = {
  q1: {
    question: 'Reduxå’ŒZustandçš„ä¸»è¦åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ',
    answer: {
      redux: {
        pros: ['å¼ºå¤§çš„è°ƒè¯•å·¥å…·', 'ä¸°å¯Œçš„ç”Ÿæ€', 'æ ‡å‡†åŒ–å®è·µ', 'æ—¶é—´æ—…è¡Œ'],
        cons: ['æ ·æ¿ä»£ç å¤š', 'å­¦ä¹ æ›²çº¿é™¡å³­', 'åŒ…ä½“ç§¯å¤§'],
        useCase: 'å¤§å‹åº”ç”¨ï¼Œå¤æ‚çŠ¶æ€é€»è¾‘'
      },
      zustand: {
        pros: ['APIç®€å•', 'åŒ…ä½“ç§¯å°', 'æ€§èƒ½ä¼˜ç§€', 'TypeScriptå‹å¥½'],
        cons: ['ç”Ÿæ€ç›¸å¯¹è¾ƒå°', 'è°ƒè¯•å·¥å…·æœ‰é™'],
        useCase: 'ä¸­å°å‹åº”ç”¨ï¼Œå¿«é€Ÿå¼€å‘'
      }
    }
  },

  q2: {
    question: 'ä»€ä¹ˆæ—¶å€™åº”è¯¥ä½¿ç”¨Context APIï¼Ÿ',
    answer: {
      é€‚åˆåœºæ™¯: [
        'ä¸»é¢˜åˆ‡æ¢',
        'ç”¨æˆ·è®¤è¯çŠ¶æ€',
        'è¯­è¨€è®¾ç½®',
        'é¿å…prop drilling'
      ],
      ä¸é€‚åˆåœºæ™¯: [
        'é¢‘ç¹æ›´æ–°çš„çŠ¶æ€',
        'å¤æ‚çš„çŠ¶æ€é€»è¾‘',
        'éœ€è¦æ€§èƒ½ä¼˜åŒ–çš„åœºæ™¯'
      ],
      åŸå› : 'Contextä¼šå¯¼è‡´æ‰€æœ‰æ¶ˆè´¹è€…é‡æ–°æ¸²æŸ“ï¼Œä¸é€‚åˆé¢‘ç¹å˜åŒ–çš„çŠ¶æ€'
    }
  },

  q3: {
    question: 'å¦‚ä½•é¿å…çŠ¶æ€ç®¡ç†ä¸­çš„æ€§èƒ½é—®é¢˜ï¼Ÿ',
    answer: {
      strategies: [
        'çŠ¶æ€åˆ†å‰²ï¼šå°†å¤§çš„çŠ¶æ€å¯¹è±¡æ‹†åˆ†æˆå°çš„ç‹¬ç«‹çŠ¶æ€',
        'é€‰æ‹©æ€§è®¢é˜…ï¼šåªè®¢é˜…éœ€è¦çš„çŠ¶æ€ç‰‡æ®µ',
        'è®°å¿†åŒ–ï¼šä½¿ç”¨useMemoå’ŒuseCallbacké¿å…ä¸å¿…è¦çš„è®¡ç®—',
        'åŸå­åŒ–ï¼šä½¿ç”¨Jotaiç­‰åŸå­åŒ–çŠ¶æ€ç®¡ç†',
        'è™šæ‹ŸåŒ–ï¼šå¯¹å¤§åˆ—è¡¨ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨'
      ],
      example: `
        // âŒ ä¼šå¯¼è‡´æ‰€æœ‰ç»„ä»¶é‡æ¸²æŸ“
        const globalState = {
          user: { ... },
          products: [ ... ],
          ui: { ... }
        };

        // âœ… çŠ¶æ€åˆ†å‰²
        const useUserStore = create(...);
        const useProductStore = create(...);
        const useUIStore = create(...);
      `
    }
  },

  q4: {
    question: 'å¦‚ä½•å¤„ç†å¼‚æ­¥çŠ¶æ€ç®¡ç†ï¼Ÿ',
    answer: {
      approaches: [
        'Redux Thunk: ç®€å•çš„å¼‚æ­¥action',
        'Redux Saga: å¤æ‚çš„å¼‚æ­¥æµç¨‹æ§åˆ¶',
        'RTK Query: ä¸“é—¨çš„æ•°æ®è·å–',
        'React Query: æœåŠ¡ç«¯çŠ¶æ€ç®¡ç†',
        'Zustand: å†…ç½®å¼‚æ­¥æ”¯æŒ'
      ],
      bestPractices: [
        'åˆ†ç¦»å®¢æˆ·ç«¯çŠ¶æ€å’ŒæœåŠ¡ç«¯çŠ¶æ€',
        'ä½¿ç”¨ä¸“é—¨çš„æ•°æ®è·å–åº“',
        'å®ç°ä¹è§‚æ›´æ–°',
        'å¤„ç†åŠ è½½å’Œé”™è¯¯çŠ¶æ€'
      ]
    }
  }
};
```

### 2. çŠ¶æ€ç®¡ç†æ¶æ„è®¾è®¡

**Q: å¦‚ä½•è®¾è®¡å¤§å‹åº”ç”¨çš„çŠ¶æ€ç®¡ç†æ¶æ„ï¼Ÿ**

**A: ä¼ä¸šçº§çŠ¶æ€ç®¡ç†æ¶æ„è®¾è®¡ï¼š**

```typescript
// ä¼ä¸šçº§çŠ¶æ€ç®¡ç†æ¶æ„
const enterpriseStateArchitecture = {
  // 1. åˆ†å±‚æ¶æ„
  layeredArchitecture: {
    presentation: {
      layer: 'è¡¨ç°å±‚',
      responsibility: 'UIç»„ä»¶ï¼Œç”¨æˆ·äº¤äº’',
      stateTypes: ['UIçŠ¶æ€', 'è¡¨å•çŠ¶æ€', 'ä¸´æ—¶çŠ¶æ€'],
      tools: ['useState', 'useReducer', 'React Hook Form']
    },

    business: {
      layer: 'ä¸šåŠ¡å±‚',
      responsibility: 'ä¸šåŠ¡é€»è¾‘ï¼ŒçŠ¶æ€ç®¡ç†',
      stateTypes: ['ä¸šåŠ¡çŠ¶æ€', 'åº”ç”¨çŠ¶æ€', 'ç”¨æˆ·çŠ¶æ€'],
      tools: ['Redux Toolkit', 'Zustand', 'Context API']
    },

    data: {
      layer: 'æ•°æ®å±‚',
      responsibility: 'æ•°æ®è·å–ï¼Œç¼“å­˜ç®¡ç†',
      stateTypes: ['æœåŠ¡ç«¯çŠ¶æ€', 'ç¼“å­˜çŠ¶æ€', 'APIçŠ¶æ€'],
      tools: ['React Query', 'SWR', 'Apollo Client']
    },

    infrastructure: {
      layer: 'åŸºç¡€è®¾æ–½å±‚',
      responsibility: 'æŒä¹…åŒ–ï¼ŒåŒæ­¥ï¼Œç›‘æ§',
      stateTypes: ['æŒä¹…åŒ–çŠ¶æ€', 'åŒæ­¥çŠ¶æ€', 'ç›‘æ§çŠ¶æ€'],
      tools: ['Redux Persist', 'LocalStorage', 'WebSocket']
    }
  },

  // 2. æ¨¡å—åŒ–è®¾è®¡
  modularDesign: {
    featureModules: {
      structure: 'features/[feature]/store/',
      example: `
        features/
          user/
            store/
              userSlice.ts
              userSelectors.ts
              userThunks.ts
          product/
            store/
              productSlice.ts
              productSelectors.ts
          cart/
            store/
              cartSlice.ts
      `,
      benefits: ['ç‹¬ç«‹å¼€å‘', 'æ˜“äºæµ‹è¯•', 'ä»£ç å¤ç”¨']
    },

    sharedModules: {
      structure: 'shared/store/',
      example: `
        shared/
          store/
            rootReducer.ts
            store.ts
            middleware/
            types/
      `,
      purpose: 'å…±äº«çŠ¶æ€ï¼Œé€šç”¨é€»è¾‘'
    }
  },

  // 3. çŠ¶æ€è§„èŒƒåŒ–
  stateNormalization: {
    principle: 'æ‰å¹³åŒ–çŠ¶æ€ç»“æ„ï¼Œé¿å…åµŒå¥—',
    example: `
      // âŒ åµŒå¥—ç»“æ„
      {
        users: {
          1: {
            id: 1,
            name: 'John',
            posts: [
              { id: 1, title: 'Post 1', author: 1 },
              { id: 2, title: 'Post 2', author: 1 }
            ]
          }
        }
      }

      // âœ… è§„èŒƒåŒ–ç»“æ„
      {
        users: {
          byId: {
            1: { id: 1, name: 'John' }
          },
          allIds: [1]
        },
        posts: {
          byId: {
            1: { id: 1, title: 'Post 1', authorId: 1 },
            2: { id: 2, title: 'Post 2', authorId: 1 }
          },
          allIds: [1, 2]
        }
      }
    `,
    benefits: ['é¿å…æ•°æ®é‡å¤', 'æ›´æ–°æ•ˆç‡é«˜', 'æŸ¥è¯¢æ€§èƒ½å¥½']
  },

  // 4. çŠ¶æ€åŒæ­¥ç­–ç•¥
  stateSynchronization: {
    clientToServer: {
      strategies: ['ä¹è§‚æ›´æ–°', 'æ‚²è§‚æ›´æ–°', 'æ··åˆç­–ç•¥'],
      implementation: `
        // ä¹è§‚æ›´æ–°ç¤ºä¾‹
        const updateUser = async (userId, updates) => {
          // ç«‹å³æ›´æ–°æœ¬åœ°çŠ¶æ€
          dispatch(updateUserOptimistic({ userId, updates }));

          try {
            // å‘é€æœåŠ¡å™¨è¯·æ±‚
            const result = await api.updateUser(userId, updates);
            dispatch(updateUserSuccess(result));
          } catch (error) {
            // å›æ»šæœ¬åœ°çŠ¶æ€
            dispatch(updateUserFailure({ userId, error }));
          }
        };
      `
    },

    serverToClient: {
      strategies: ['è½®è¯¢', 'WebSocket', 'SSE', 'GraphQLè®¢é˜…'],
      implementation: `
        // WebSocketå®æ—¶åŒæ­¥
        const useRealtimeSync = () => {
          useEffect(() => {
            const ws = new WebSocket('ws://localhost:3001');

            ws.onmessage = (event) => {
              const update = JSON.parse(event.data);
              dispatch(applyServerUpdate(update));
            };

            return () => ws.close();
          }, []);
        };
      `
    }
  }
};
```

---

## ğŸ“š å®æˆ˜ç»ƒä¹ 

### ç»ƒä¹ 1ï¼šè®¾è®¡ç”µå•†çŠ¶æ€ç®¡ç†æ¶æ„

**ä»»åŠ¡**: ä¸ºMall-Frontendè®¾è®¡å®Œæ•´çš„çŠ¶æ€ç®¡ç†æ¶æ„ï¼ŒåŒ…æ‹¬ç”¨æˆ·ã€å•†å“ã€è´­ç‰©è½¦ã€è®¢å•ç­‰æ¨¡å—ã€‚

**è¦æ±‚**:
- é€‰æ‹©åˆé€‚çš„çŠ¶æ€ç®¡ç†æ–¹æ¡ˆ
- è®¾è®¡æ¨¡å—åŒ–çš„çŠ¶æ€ç»“æ„
- å®ç°çŠ¶æ€æŒä¹…åŒ–
- æ·»åŠ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### ç»ƒä¹ 2ï¼šå®ç°çŠ¶æ€ç®¡ç†è¿ç§»

**ä»»åŠ¡**: å°†ä¸€ä¸ªä½¿ç”¨Context APIçš„åº”ç”¨è¿ç§»åˆ°Zustandã€‚

**è¦æ±‚**:
- åˆ†æç°æœ‰Contextç»“æ„
- è®¾è®¡Zustand storeæ¶æ„
- å®ç°æ¸è¿›å¼è¿ç§»
- ä¿è¯åŠŸèƒ½å®Œæ•´æ€§

### ç»ƒä¹ 3ï¼šæ„å»ºçŠ¶æ€ç®¡ç†æµ‹è¯•å¥—ä»¶

**ä»»åŠ¡**: ä¸ºçŠ¶æ€ç®¡ç†æ¨¡å—ç¼–å†™å®Œæ•´çš„æµ‹è¯•å¥—ä»¶ã€‚

**è¦æ±‚**:
- å•å…ƒæµ‹è¯•ï¼šæµ‹è¯•reducerså’Œactions
- é›†æˆæµ‹è¯•ï¼šæµ‹è¯•ç»„ä»¶ä¸çŠ¶æ€çš„é›†æˆ
- ç«¯åˆ°ç«¯æµ‹è¯•ï¼šæµ‹è¯•å®Œæ•´çš„ç”¨æˆ·æµç¨‹
- æ€§èƒ½æµ‹è¯•ï¼šæµ‹è¯•çŠ¶æ€æ›´æ–°æ€§èƒ½

---

## ğŸ“š æœ¬ç« æ€»ç»“

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œæˆ‘ä»¬å…¨é¢æŒæ¡äº†çŠ¶æ€ç®¡ç†æ¶æ„è®¾è®¡çš„æ ¸å¿ƒæŠ€æœ¯ï¼š

### ğŸ¯ æ ¸å¿ƒæ”¶è·

1. **çŠ¶æ€ç®¡ç†ç†è®ºç²¾é€š** ğŸ¯
   - æŒæ¡äº†çŠ¶æ€åˆ†ç±»å’Œç®¡ç†åŸåˆ™
   - ç†è§£äº†çŠ¶æ€ç®¡ç†æ¨¡å¼çš„æ¼”è¿›å†ç¨‹
   - å­¦ä¼šäº†çŠ¶æ€ç®¡ç†æ–¹æ¡ˆçš„é€‰æ‹©ç­–ç•¥

2. **æ–¹æ¡ˆæ·±åº¦å¯¹æ¯”** ğŸ”„
   - æ·±å…¥å¯¹æ¯”äº†Reduxã€Zustandã€Context APIç­‰æ–¹æ¡ˆ
   - æŒæ¡äº†å„æ–¹æ¡ˆçš„ä¼˜åŠ£å’Œé€‚ç”¨åœºæ™¯
   - ç†è§£äº†ä¼ä¸šçº§é€‰æ‹©ç­–ç•¥

3. **æ¶æ„è®¾è®¡èƒ½åŠ›** ğŸ—ï¸
   - æŒæ¡äº†åˆ†å±‚æ¶æ„å’Œæ¨¡å—åŒ–è®¾è®¡
   - å­¦ä¼šäº†çŠ¶æ€è§„èŒƒåŒ–å’ŒåŒæ­¥ç­–ç•¥
   - ç†è§£äº†å¤§å‹åº”ç”¨çš„çŠ¶æ€æ²»ç†

4. **æ€§èƒ½ä¼˜åŒ–æŠ€å·§** âš¡
   - æŒæ¡äº†çŠ¶æ€ç®¡ç†çš„æ€§èƒ½ä¼˜åŒ–æ–¹æ³•
   - å­¦ä¼šäº†é¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“
   - ç†è§£äº†å†…å­˜å’Œç½‘ç»œä¼˜åŒ–ç­–ç•¥

5. **ä¼ä¸šçº§å®è·µ** ğŸš€
   - å­¦ä¼šäº†å¤§å‹å›¢é˜Ÿçš„çŠ¶æ€ç®¡ç†è§„èŒƒ
   - æŒæ¡äº†çŠ¶æ€ç®¡ç†çš„æµ‹è¯•ç­–ç•¥
   - ç†è§£äº†è¿ç§»å’Œå‡çº§çš„æ–¹æ³•

### ğŸš€ æŠ€æœ¯è¿›é˜¶

- **ä¸‹ä¸€æ­¥å­¦ä¹ **: ç»„ä»¶åº“è®¾è®¡ä¸å¼€å‘
- **å®è·µå»ºè®®**: åœ¨é¡¹ç›®ä¸­åº”ç”¨åˆ†å±‚çŠ¶æ€ç®¡ç†æ¶æ„
- **æ·±å…¥æ–¹å‘**: å¾®å‰ç«¯çŠ¶æ€å…±äº«å’Œè·¨åº”ç”¨çŠ¶æ€åŒæ­¥

çŠ¶æ€ç®¡ç†æ˜¯ç°ä»£å‰ç«¯åº”ç”¨çš„æ ¸å¿ƒï¼Œé€‰æ‹©åˆé€‚çš„æ–¹æ¡ˆå’Œæ¶æ„è®¾è®¡æ˜¯æˆåŠŸçš„å…³é”®ï¼ ğŸ‰

---

*ä¸‹ä¸€ç« æˆ‘ä»¬å°†å­¦ä¹ ã€Šç»„ä»¶åº“è®¾è®¡ä¸å¼€å‘ã€‹ï¼Œæ¢ç´¢å¯å¤ç”¨ç»„ä»¶ç³»ç»Ÿçš„æ„å»ºï¼* ğŸš€
```
```
```
```
