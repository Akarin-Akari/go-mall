# è¿›é˜¶ç¯‡ç¬¬å››ç« ï¼šæ¥å£è®¾è®¡æ¨¡å¼ ğŸ¨

> **"æ¥å£æ˜¯Goè¯­è¨€çš„çµé­‚ï¼Œè®¾è®¡æ¨¡å¼æ˜¯ç¼–ç¨‹çš„è‰ºæœ¯"** ğŸ’«

---

## ğŸ“– ç« èŠ‚å¯¼è¯»

æ¬¢è¿æ¥åˆ°Goè¯­è¨€æ¥å£è®¾è®¡æ¨¡å¼çš„ä¸–ç•Œï¼ğŸŒŸ å¦‚æœè¯´å¹¶å‘æ˜¯Goçš„å¿ƒè„ï¼Œé‚£ä¹ˆæ¥å£å°±æ˜¯Goçš„çµé­‚ã€‚åœ¨è¿™ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢ç´¢Goè¯­è¨€æ¥å£çš„è®¾è®¡å“²å­¦ï¼Œå­¦ä¹ å¦‚ä½•ç”¨Goçš„æ–¹å¼å®ç°ç»å…¸è®¾è®¡æ¨¡å¼ï¼ŒæŒæ¡ä¼ä¸šçº§é¡¹ç›®ä¸­çš„æ¥å£è®¾è®¡æŠ€å·§ã€‚

### ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œä½ å°†æŒæ¡ï¼š

- **ğŸ—ï¸ Goæ¥å£è®¾è®¡å“²å­¦**ï¼šç†è§£"æ¥å—æ¥å£ï¼Œè¿”å›ç»“æ„ä½“"çš„è®¾è®¡åŸåˆ™
- **ğŸ¨ ç»å…¸è®¾è®¡æ¨¡å¼**ï¼šç”¨Goè¯­è¨€å®ç°å·¥å‚ã€ç­–ç•¥ã€è£…é¥°å™¨ç­‰æ¨¡å¼
- **ğŸ’‰ ä¾èµ–æ³¨å…¥**ï¼šæŒæ¡Goè¯­è¨€ä¸­çš„ä¾èµ–æ³¨å…¥å’Œæ§åˆ¶åè½¬
- **ğŸ”— æ¥å£ç»„åˆ**ï¼šå­¦ä¼šæ¥å£åµŒå…¥å’Œç»„åˆçš„é«˜çº§ç”¨æ³•
- **ğŸ­ ç±»å‹ç³»ç»Ÿ**ï¼šæ·±å…¥ç†è§£ç©ºæ¥å£ã€ç±»å‹æ–­è¨€å’Œç±»å‹å¼€å…³
- **ğŸ§ª æµ‹è¯•æŠ€å·§**ï¼šæŒæ¡æ¥å£æµ‹è¯•å’ŒMockçš„æœ€ä½³å®è·µ
- **âš¡ æ€§èƒ½ä¼˜åŒ–**ï¼šäº†è§£æ¥å£ä½¿ç”¨ä¸­çš„æ€§èƒ½è€ƒè™‘

### ğŸ“‹ ç« èŠ‚å¤§çº²

```
04-interface-design-patterns.md
â”œâ”€â”€ ğŸ›ï¸  Goæ¥å£è®¾è®¡å“²å­¦
â”œâ”€â”€ ğŸ­  ç»å…¸è®¾è®¡æ¨¡å¼å®ç°
â”‚   â”œâ”€â”€ å·¥å‚æ¨¡å¼å®¶æ—
â”‚   â”œâ”€â”€ ç­–ç•¥æ¨¡å¼
â”‚   â”œâ”€â”€ è£…é¥°å™¨æ¨¡å¼
â”‚   â”œâ”€â”€ é€‚é…å™¨æ¨¡å¼
â”‚   â”œâ”€â”€ è§‚å¯Ÿè€…æ¨¡å¼
â”‚   â””â”€â”€ å‘½ä»¤æ¨¡å¼
â”œâ”€â”€ ğŸ’‰  ä¾èµ–æ³¨å…¥å’Œæ§åˆ¶åè½¬
â”œâ”€â”€ ğŸ”—  æ¥å£ç»„åˆå’ŒåµŒå…¥
â”œâ”€â”€ ğŸ­  ç©ºæ¥å£å’Œç±»å‹æ–­è¨€
â”œâ”€â”€ ğŸ§ª  æ¥å£æµ‹è¯•å’ŒMock
â”œâ”€â”€ ğŸ¢  å®æˆ˜æ¡ˆä¾‹åˆ†æ
â”œâ”€â”€ ğŸ¯  é¢è¯•å¸¸è€ƒç‚¹
â”œâ”€â”€ âš ï¸   è¸©å‘æé†’
â”œâ”€â”€ ğŸ“  ç»ƒä¹ é¢˜
â””â”€â”€ ğŸ“š  ç« èŠ‚æ€»ç»“
```

---

## ğŸ›ï¸ Goæ¥å£è®¾è®¡å“²å­¦

### Goæ¥å£çš„ç‹¬ç‰¹ä¹‹å¤„

Goè¯­è¨€çš„æ¥å£è®¾è®¡æœ‰ç€ç‹¬ç‰¹çš„å“²å­¦ï¼Œä¸ä¼ ç»Ÿçš„é¢å‘å¯¹è±¡è¯­è¨€æœ‰å¾ˆå¤§ä¸åŒã€‚

```go
// æ¥è‡ª mall-go/pkg/design/philosophy.go
package design

import (
    "fmt"
    "io"
    "strings"
)

/*
Goæ¥å£è®¾è®¡çš„æ ¸å¿ƒåŸåˆ™ï¼š

1. æ¥å£éš”ç¦»åŸåˆ™ (Interface Segregation Principle)
   - æ¥å£åº”è¯¥å°è€Œä¸“ä¸€
   - å®¢æˆ·ç«¯ä¸åº”è¯¥ä¾èµ–å®ƒä¸éœ€è¦çš„æ¥å£

2. "æ¥å—æ¥å£ï¼Œè¿”å›ç»“æ„ä½“" (Accept interfaces, return structs)
   - å‡½æ•°å‚æ•°ä½¿ç”¨æ¥å£ç±»å‹ï¼Œå¢åŠ çµæ´»æ€§
   - å‡½æ•°è¿”å›å€¼ä½¿ç”¨å…·ä½“ç±»å‹ï¼Œæä¾›æ˜ç¡®çš„API

3. éšå¼å®ç° (Implicit Implementation)
   - æ— éœ€æ˜¾å¼å£°æ˜å®ç°æ¥å£
   - åªè¦å®ç°äº†æ¥å£çš„æ‰€æœ‰æ–¹æ³•å°±è‡ªåŠ¨æ»¡è¶³æ¥å£

4. ç»„åˆä¼˜äºç»§æ‰¿ (Composition over Inheritance)
   - é€šè¿‡æ¥å£ç»„åˆå®ç°å¤æ‚åŠŸèƒ½
   - é¿å…æ·±å±‚æ¬¡çš„ç»§æ‰¿å…³ç³»
*/

// ç¤ºä¾‹1ï¼šå°æ¥å£è®¾è®¡
// âŒ é”™è¯¯ç¤ºä¾‹ï¼šæ¥å£è¿‡äºåºå¤§
type BadUserService interface {
    CreateUser(user User) error
    UpdateUser(user User) error
    DeleteUser(id int64) error
    GetUser(id int64) (*User, error)
    ListUsers(page, size int) ([]*User, error)
    AuthenticateUser(username, password string) (*User, error)
    ChangePassword(userID int64, oldPassword, newPassword string) error
    SendEmail(userID int64, subject, body string) error
    UploadAvatar(userID int64, avatar []byte) error
    GetUserStatistics(userID int64) (*UserStats, error)
}

// âœ… æ­£ç¡®ç¤ºä¾‹ï¼šæ¥å£èŒè´£åˆ†ç¦»
type UserRepository interface {
    Create(user User) error
    Update(user User) error
    Delete(id int64) error
    GetByID(id int64) (*User, error)
    List(page, size int) ([]*User, error)
}

type UserAuthenticator interface {
    Authenticate(username, password string) (*User, error)
    ChangePassword(userID int64, oldPassword, newPassword string) error
}

type UserNotifier interface {
    SendEmail(userID int64, subject, body string) error
}

type UserAvatarManager interface {
    UploadAvatar(userID int64, avatar []byte) error
}

// ç¤ºä¾‹2ï¼š"æ¥å—æ¥å£ï¼Œè¿”å›ç»“æ„ä½“"åŸåˆ™
type User struct {
    ID       int64  `json:"id"`
    Username string `json:"username"`
    Email    string `json:"email"`
    Avatar   string `json:"avatar"`
}

type UserStats struct {
    LoginCount    int64 `json:"login_count"`
    LastLoginTime int64 `json:"last_login_time"`
}

// âœ… æ­£ç¡®ç¤ºä¾‹ï¼šæ¥å—æ¥å£å‚æ•°
func ProcessUserData(reader io.Reader, writer io.Writer) error {
    // æ¥å—æ¥å£ï¼Œæä¾›æœ€å¤§çš„çµæ´»æ€§
    data, err := io.ReadAll(reader)
    if err != nil {
        return err
    }
    
    // å¤„ç†æ•°æ®
    processed := strings.ToUpper(string(data))
    
    _, err = writer.Write([]byte(processed))
    return err
}

// âœ… æ­£ç¡®ç¤ºä¾‹ï¼šè¿”å›å…·ä½“ç»“æ„ä½“
func NewUserService(repo UserRepository, auth UserAuthenticator) *UserService {
    // è¿”å›å…·ä½“ç±»å‹ï¼Œæä¾›æ˜ç¡®çš„API
    return &UserService{
        repo: repo,
        auth: auth,
    }
}

type UserService struct {
    repo UserRepository
    auth UserAuthenticator
}

func (s *UserService) CreateUser(user User) error {
    // å®ç°ç”¨æˆ·åˆ›å»ºé€»è¾‘
    return s.repo.Create(user)
}

func (s *UserService) AuthenticateUser(username, password string) (*User, error) {
    return s.auth.Authenticate(username, password)
}
```

### ä¸Java/Pythonæ¥å£è®¾è®¡å¯¹æ¯”

```java
// Javaæ¥å£è®¾è®¡
public interface UserService {
    // Javaéœ€è¦æ˜¾å¼å£°æ˜å®ç°æ¥å£
    void createUser(User user) throws UserException;
    User getUser(Long id) throws UserException;
}

// æ˜¾å¼å®ç°æ¥å£
public class UserServiceImpl implements UserService {
    @Override
    public void createUser(User user) throws UserException {
        // å®ç°é€»è¾‘
    }
    
    @Override
    public User getUser(Long id) throws UserException {
        // å®ç°é€»è¾‘
        return user;
    }
}

/*
Java vs Goæ¥å£å¯¹æ¯”ï¼š

1. å£°æ˜æ–¹å¼ï¼š
   - Java: æ˜¾å¼implementså£°æ˜
   - Go: éšå¼å®ç°ï¼Œduck typing

2. æ¥å£å¤§å°ï¼š
   - Java: å€¾å‘äºå¤§æ¥å£ï¼Œå¦‚JPAçš„Repository
   - Go: æ¨å´‡å°æ¥å£ï¼Œå•ä¸€èŒè´£

3. ç»§æ‰¿vsç»„åˆï¼š
   - Java: æ”¯æŒæ¥å£ç»§æ‰¿ï¼Œextendså…³é”®å­—
   - Go: æ¥å£åµŒå…¥ï¼Œç»„åˆä¼˜äºç»§æ‰¿

4. æ³›å‹æ”¯æŒï¼š
   - Java: åŸç”Ÿæ”¯æŒæ³›å‹æ¥å£
   - Go: 1.18+æ”¯æŒæ³›å‹ï¼Œä½†è®¾è®¡æ›´ç®€æ´
*/
```

```python
# Pythonæ¥å£è®¾è®¡ï¼ˆä½¿ç”¨ABCæŠ½è±¡åŸºç±»ï¼‰
from abc import ABC, abstractmethod
from typing import List, Optional

class UserRepository(ABC):
    @abstractmethod
    def create(self, user: 'User') -> None:
        pass
    
    @abstractmethod
    def get_by_id(self, user_id: int) -> Optional['User']:
        pass

class DatabaseUserRepository(UserRepository):
    def create(self, user: 'User') -> None:
        # å®ç°æ•°æ®åº“æ“ä½œ
        pass
    
    def get_by_id(self, user_id: int) -> Optional['User']:
        # å®ç°æŸ¥è¯¢é€»è¾‘
        return user

"""
Python vs Goæ¥å£å¯¹æ¯”ï¼š

1. æŠ½è±¡æœºåˆ¶ï¼š
   - Python: ABCæŠ½è±¡åŸºç±»ï¼Œéœ€è¦ç»§æ‰¿
   - Go: æ¥å£ç±»å‹ï¼Œéšå¼å®ç°

2. ç±»å‹æ£€æŸ¥ï¼š
   - Python: è¿è¡Œæ—¶æ£€æŸ¥ï¼Œtypingæä¾›é™æ€æ£€æŸ¥
   - Go: ç¼–è¯‘æ—¶æ£€æŸ¥ï¼Œç±»å‹å®‰å…¨

3. å¤šé‡ç»§æ‰¿ï¼š
   - Python: æ”¯æŒå¤šé‡ç»§æ‰¿ï¼Œä½†å®¹æ˜“äº§ç”Ÿé—®é¢˜
   - Go: æ¥å£ç»„åˆï¼Œé¿å…ç»§æ‰¿é—®é¢˜

4. åŠ¨æ€ç‰¹æ€§ï¼š
   - Python: åŠ¨æ€è¯­è¨€ï¼Œè¿è¡Œæ—¶å¯ä¿®æ”¹
   - Go: é™æ€è¯­è¨€ï¼Œç¼–è¯‘æ—¶ç¡®å®š
"""
```

---

## ğŸ­ ç»å…¸è®¾è®¡æ¨¡å¼å®ç°

### å·¥å‚æ¨¡å¼å®¶æ—

å·¥å‚æ¨¡å¼æ˜¯åˆ›å»ºå‹è®¾è®¡æ¨¡å¼çš„ä»£è¡¨ï¼ŒGoè¯­è¨€ä¸­çš„å®ç°æ›´åŠ ç®€æ´å’Œçµæ´»ã€‚

#### 1. ç®€å•å·¥å‚æ¨¡å¼

```go
// æ¥è‡ª mall-go/internal/factory/simple_factory.go
package factory

import (
    "fmt"
    "strings"
)

// äº§å“æ¥å£
type Product interface {
    GetName() string
    GetPrice() float64
    GetDescription() string
}

// å…·ä½“äº§å“ï¼šç”µå­äº§å“
type ElectronicProduct struct {
    name        string
    price       float64
    description string
    warranty    int // ä¿ä¿®æœŸï¼ˆæœˆï¼‰
}

func (e *ElectronicProduct) GetName() string {
    return e.name
}

func (e *ElectronicProduct) GetPrice() float64 {
    return e.price
}

func (e *ElectronicProduct) GetDescription() string {
    return fmt.Sprintf("%s (ä¿ä¿®%dä¸ªæœˆ)", e.description, e.warranty)
}

// å…·ä½“äº§å“ï¼šæœè£…äº§å“
type ClothingProduct struct {
    name        string
    price       float64
    description string
    size        string
    material    string
}

func (c *ClothingProduct) GetName() string {
    return c.name
}

func (c *ClothingProduct) GetPrice() float64 {
    return c.price
}

func (c *ClothingProduct) GetDescription() string {
    return fmt.Sprintf("%s (å°ºç :%s, æè´¨:%s)", c.description, c.size, c.material)
}

// å…·ä½“äº§å“ï¼šå›¾ä¹¦äº§å“
type BookProduct struct {
    name        string
    price       float64
    description string
    author      string
    isbn        string
}

func (b *BookProduct) GetName() string {
    return b.name
}

func (b *BookProduct) GetPrice() float64 {
    return b.price
}

func (b *BookProduct) GetDescription() string {
    return fmt.Sprintf("%s - ä½œè€…:%s (ISBN:%s)", b.description, b.author, b.isbn)
}

// äº§å“ç±»å‹æšä¸¾
type ProductType string

const (
    ElectronicType ProductType = "electronic"
    ClothingType   ProductType = "clothing"
    BookType       ProductType = "book"
)

// ç®€å•å·¥å‚
type SimpleProductFactory struct{}

func NewSimpleProductFactory() *SimpleProductFactory {
    return &SimpleProductFactory{}
}

func (f *SimpleProductFactory) CreateProduct(productType ProductType, params map[string]interface{}) (Product, error) {
    switch productType {
    case ElectronicType:
        return &ElectronicProduct{
            name:        params["name"].(string),
            price:       params["price"].(float64),
            description: params["description"].(string),
            warranty:    params["warranty"].(int),
        }, nil
        
    case ClothingType:
        return &ClothingProduct{
            name:        params["name"].(string),
            price:       params["price"].(float64),
            description: params["description"].(string),
            size:        params["size"].(string),
            material:    params["material"].(string),
        }, nil
        
    case BookType:
        return &BookProduct{
            name:        params["name"].(string),
            price:       params["price"].(float64),
            description: params["description"].(string),
            author:      params["author"].(string),
            isbn:        params["isbn"].(string),
        }, nil
        
    default:
        return nil, fmt.Errorf("ä¸æ”¯æŒçš„äº§å“ç±»å‹: %s", productType)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func DemonstrateSimpleFactory() {
    fmt.Println("=== ç®€å•å·¥å‚æ¨¡å¼æ¼”ç¤º ===")
    
    factory := NewSimpleProductFactory()
    
    // åˆ›å»ºç”µå­äº§å“
    electronic, err := factory.CreateProduct(ElectronicType, map[string]interface{}{
        "name":        "iPhone 15",
        "price":       7999.0,
        "description": "è‹¹æœæœ€æ–°æ¬¾æ™ºèƒ½æ‰‹æœº",
        "warranty":    12,
    })
    if err != nil {
        fmt.Printf("åˆ›å»ºç”µå­äº§å“å¤±è´¥: %v\n", err)
        return
    }
    
    fmt.Printf("ç”µå­äº§å“: %s - Â¥%.2f\n", electronic.GetName(), electronic.GetPrice())
    fmt.Printf("æè¿°: %s\n", electronic.GetDescription())
    
    // åˆ›å»ºæœè£…äº§å“
    clothing, err := factory.CreateProduct(ClothingType, map[string]interface{}{
        "name":        "ä¼˜è¡£åº“Tæ¤",
        "price":       99.0,
        "description": "çº¯æ£‰èˆ’é€‚Tæ¤",
        "size":        "L",
        "material":    "100%çº¯æ£‰",
    })
    if err != nil {
        fmt.Printf("åˆ›å»ºæœè£…äº§å“å¤±è´¥: %v\n", err)
        return
    }
    
    fmt.Printf("\næœè£…äº§å“: %s - Â¥%.2f\n", clothing.GetName(), clothing.GetPrice())
    fmt.Printf("æè¿°: %s\n", clothing.GetDescription())
    
    // åˆ›å»ºå›¾ä¹¦äº§å“
    book, err := factory.CreateProduct(BookType, map[string]interface{}{
        "name":        "Goè¯­è¨€å®æˆ˜",
        "price":       89.0,
        "description": "æ·±å…¥å­¦ä¹ Goè¯­è¨€ç¼–ç¨‹",
        "author":      "å¼ ä¸‰",
        "isbn":        "978-7-111-12345-6",
    })
    if err != nil {
        fmt.Printf("åˆ›å»ºå›¾ä¹¦äº§å“å¤±è´¥: %v\n", err)
        return
    }
    
    fmt.Printf("\nå›¾ä¹¦äº§å“: %s - Â¥%.2f\n", book.GetName(), book.GetPrice())
    fmt.Printf("æè¿°: %s\n", book.GetDescription())
}
```

#### 2. å·¥å‚æ–¹æ³•æ¨¡å¼

```go
// æ¥è‡ª mall-go/internal/factory/factory_method.go
package factory

import (
    "fmt"
)

// æŠ½è±¡å·¥å‚æ¥å£
type ProductFactory interface {
    CreateProduct(params map[string]interface{}) Product
    GetFactoryType() string
}

// ç”µå­äº§å“å·¥å‚
type ElectronicProductFactory struct{}

func NewElectronicProductFactory() *ElectronicProductFactory {
    return &ElectronicProductFactory{}
}

func (f *ElectronicProductFactory) CreateProduct(params map[string]interface{}) Product {
    return &ElectronicProduct{
        name:        params["name"].(string),
        price:       params["price"].(float64),
        description: params["description"].(string),
        warranty:    params["warranty"].(int),
    }
}

func (f *ElectronicProductFactory) GetFactoryType() string {
    return "ç”µå­äº§å“å·¥å‚"
}

// æœè£…äº§å“å·¥å‚
type ClothingProductFactory struct{}

func NewClothingProductFactory() *ClothingProductFactory {
    return &ClothingProductFactory{}
}

func (f *ClothingProductFactory) CreateProduct(params map[string]interface{}) Product {
    return &ClothingProduct{
        name:        params["name"].(string),
        price:       params["price"].(float64),
        description: params["description"].(string),
        size:        params["size"].(string),
        material:    params["material"].(string),
    }
}

func (f *ClothingProductFactory) GetFactoryType() string {
    return "æœè£…äº§å“å·¥å‚"
}

// å›¾ä¹¦äº§å“å·¥å‚
type BookProductFactory struct{}

func NewBookProductFactory() *BookProductFactory {
    return &BookProductFactory{}
}

func (f *BookProductFactory) CreateProduct(params map[string]interface{}) Product {
    return &BookProduct{
        name:        params["name"].(string),
        price:       params["price"].(float64),
        description: params["description"].(string),
        author:      params["author"].(string),
        isbn:        params["isbn"].(string),
    }
}

func (f *BookProductFactory) GetFactoryType() string {
    return "å›¾ä¹¦äº§å“å·¥å‚"
}

// å·¥å‚æ³¨å†Œå™¨
type FactoryRegistry struct {
    factories map[ProductType]ProductFactory
}

func NewFactoryRegistry() *FactoryRegistry {
    registry := &FactoryRegistry{
        factories: make(map[ProductType]ProductFactory),
    }

    // æ³¨å†Œå·¥å‚
    registry.RegisterFactory(ElectronicType, NewElectronicProductFactory())
    registry.RegisterFactory(ClothingType, NewClothingProductFactory())
    registry.RegisterFactory(BookType, NewBookProductFactory())

    return registry
}

func (r *FactoryRegistry) RegisterFactory(productType ProductType, factory ProductFactory) {
    r.factories[productType] = factory
    fmt.Printf("æ³¨å†Œå·¥å‚: %s -> %s\n", productType, factory.GetFactoryType())
}

func (r *FactoryRegistry) GetFactory(productType ProductType) (ProductFactory, error) {
    factory, exists := r.factories[productType]
    if !exists {
        return nil, fmt.Errorf("æœªæ‰¾åˆ°äº§å“ç±»å‹ %s çš„å·¥å‚", productType)
    }
    return factory, nil
}

func (r *FactoryRegistry) CreateProduct(productType ProductType, params map[string]interface{}) (Product, error) {
    factory, err := r.GetFactory(productType)
    if err != nil {
        return nil, err
    }

    return factory.CreateProduct(params), nil
}

// ä½¿ç”¨ç¤ºä¾‹
func DemonstrateFactoryMethod() {
    fmt.Println("\n=== å·¥å‚æ–¹æ³•æ¨¡å¼æ¼”ç¤º ===")

    registry := NewFactoryRegistry()

    // ä½¿ç”¨ä¸åŒçš„å·¥å‚åˆ›å»ºäº§å“
    products := []struct {
        productType ProductType
        params      map[string]interface{}
    }{
        {
            ElectronicType,
            map[string]interface{}{
                "name":        "MacBook Pro",
                "price":       15999.0,
                "description": "è‹¹æœä¸“ä¸šç¬”è®°æœ¬ç”µè„‘",
                "warranty":    24,
            },
        },
        {
            ClothingType,
            map[string]interface{}{
                "name":        "Nikeè¿åŠ¨é‹",
                "price":       899.0,
                "description": "ä¸“ä¸šè·‘æ­¥é‹",
                "size":        "42",
                "material":    "åˆæˆææ–™",
            },
        },
        {
            BookType,
            map[string]interface{}{
                "name":        "è®¾è®¡æ¨¡å¼",
                "price":       79.0,
                "description": "ç»å…¸è®¾è®¡æ¨¡å¼è¯¦è§£",
                "author":      "GoF",
                "isbn":        "978-7-111-98765-4",
            },
        },
    }

    fmt.Println("\nåˆ›å»ºçš„äº§å“:")
    for i, productInfo := range products {
        product, err := registry.CreateProduct(productInfo.productType, productInfo.params)
        if err != nil {
            fmt.Printf("åˆ›å»ºäº§å“å¤±è´¥: %v\n", err)
            continue
        }

        fmt.Printf("%d. %s - Â¥%.2f\n", i+1, product.GetName(), product.GetPrice())
        fmt.Printf("   %s\n", product.GetDescription())
    }
}
```

#### 3. æŠ½è±¡å·¥å‚æ¨¡å¼

```go
// æ¥è‡ª mall-go/internal/factory/abstract_factory.go
package factory

import (
    "fmt"
)

// æŠ½è±¡äº§å“æ—æ¥å£
type UIComponent interface {
    Render() string
}

type Button interface {
    UIComponent
    Click() string
}

type TextField interface {
    UIComponent
    SetText(text string)
    GetText() string
}

type Dialog interface {
    UIComponent
    Show() string
    Hide() string
}

// Windowsé£æ ¼ç»„ä»¶
type WindowsButton struct {
    text string
}

func (b *WindowsButton) Render() string {
    return fmt.Sprintf("[WindowsæŒ‰é’®: %s]", b.text)
}

func (b *WindowsButton) Click() string {
    return fmt.Sprintf("WindowsæŒ‰é’® '%s' è¢«ç‚¹å‡»", b.text)
}

type WindowsTextField struct {
    text string
}

func (t *WindowsTextField) Render() string {
    return fmt.Sprintf("[Windowsæ–‡æœ¬æ¡†: %s]", t.text)
}

func (t *WindowsTextField) SetText(text string) {
    t.text = text
}

func (t *WindowsTextField) GetText() string {
    return t.text
}

type WindowsDialog struct {
    title string
}

func (d *WindowsDialog) Render() string {
    return fmt.Sprintf("[Windowså¯¹è¯æ¡†: %s]", d.title)
}

func (d *WindowsDialog) Show() string {
    return fmt.Sprintf("æ˜¾ç¤ºWindowså¯¹è¯æ¡†: %s", d.title)
}

func (d *WindowsDialog) Hide() string {
    return fmt.Sprintf("éšè—Windowså¯¹è¯æ¡†: %s", d.title)
}

// macOSé£æ ¼ç»„ä»¶
type MacOSButton struct {
    text string
}

func (b *MacOSButton) Render() string {
    return fmt.Sprintf("â—‰ macOSæŒ‰é’®: %s", b.text)
}

func (b *MacOSButton) Click() string {
    return fmt.Sprintf("macOSæŒ‰é’® '%s' è¢«ç‚¹å‡»", b.text)
}

type MacOSTextField struct {
    text string
}

func (t *MacOSTextField) Render() string {
    return fmt.Sprintf("â—‰ macOSæ–‡æœ¬æ¡†: %s", t.text)
}

func (t *MacOSTextField) SetText(text string) {
    t.text = text
}

func (t *MacOSTextField) GetText() string {
    return t.text
}

type MacOSDialog struct {
    title string
}

func (d *MacOSDialog) Render() string {
    return fmt.Sprintf("â—‰ macOSå¯¹è¯æ¡†: %s", d.title)
}

func (d *MacOSDialog) Show() string {
    return fmt.Sprintf("æ˜¾ç¤ºmacOSå¯¹è¯æ¡†: %s", d.title)
}

func (d *MacOSDialog) Hide() string {
    return fmt.Sprintf("éšè—macOSå¯¹è¯æ¡†: %s", d.title)
}

// æŠ½è±¡å·¥å‚æ¥å£
type UIFactory interface {
    CreateButton(text string) Button
    CreateTextField(placeholder string) TextField
    CreateDialog(title string) Dialog
    GetTheme() string
}

// Windows UIå·¥å‚
type WindowsUIFactory struct{}

func NewWindowsUIFactory() *WindowsUIFactory {
    return &WindowsUIFactory{}
}

func (f *WindowsUIFactory) CreateButton(text string) Button {
    return &WindowsButton{text: text}
}

func (f *WindowsUIFactory) CreateTextField(placeholder string) TextField {
    return &WindowsTextField{text: placeholder}
}

func (f *WindowsUIFactory) CreateDialog(title string) Dialog {
    return &WindowsDialog{title: title}
}

func (f *WindowsUIFactory) GetTheme() string {
    return "Windowsä¸»é¢˜"
}

// macOS UIå·¥å‚
type MacOSUIFactory struct{}

func NewMacOSUIFactory() *MacOSUIFactory {
    return &MacOSUIFactory{}
}

func (f *MacOSUIFactory) CreateButton(text string) Button {
    return &MacOSButton{text: text}
}

func (f *MacOSUIFactory) CreateTextField(placeholder string) TextField {
    return &MacOSTextField{text: placeholder}
}

func (f *MacOSUIFactory) CreateDialog(title string) Dialog {
    return &MacOSDialog{title: title}
}

func (f *MacOSUIFactory) GetTheme() string {
    return "macOSä¸»é¢˜"
}

// åº”ç”¨ç¨‹åºç±»
type Application struct {
    factory UIFactory
    button  Button
    textField TextField
    dialog  Dialog
}

func NewApplication(factory UIFactory) *Application {
    app := &Application{factory: factory}
    app.createUI()
    return app
}

func (a *Application) createUI() {
    a.button = a.factory.CreateButton("ç¡®å®š")
    a.textField = a.factory.CreateTextField("è¯·è¾“å…¥å†…å®¹...")
    a.dialog = a.factory.CreateDialog("æç¤º")
}

func (a *Application) Run() {
    fmt.Printf("åº”ç”¨ç¨‹åºä½¿ç”¨: %s\n", a.factory.GetTheme())
    fmt.Printf("UIç»„ä»¶æ¸²æŸ“:\n")
    fmt.Printf("  %s\n", a.button.Render())
    fmt.Printf("  %s\n", a.textField.Render())
    fmt.Printf("  %s\n", a.dialog.Render())

    fmt.Printf("\näº¤äº’æ¼”ç¤º:\n")
    fmt.Printf("  %s\n", a.button.Click())

    a.textField.SetText("Hello World")
    fmt.Printf("  è®¾ç½®æ–‡æœ¬: %s\n", a.textField.GetText())

    fmt.Printf("  %s\n", a.dialog.Show())
}

// ä½¿ç”¨ç¤ºä¾‹
func DemonstrateAbstractFactory() {
    fmt.Println("\n=== æŠ½è±¡å·¥å‚æ¨¡å¼æ¼”ç¤º ===")

    // åˆ›å»ºWindowsé£æ ¼çš„åº”ç”¨
    fmt.Println("1. Windowsé£æ ¼åº”ç”¨:")
    windowsFactory := NewWindowsUIFactory()
    windowsApp := NewApplication(windowsFactory)
    windowsApp.Run()

    fmt.Println("\n" + strings.Repeat("-", 50))

    // åˆ›å»ºmacOSé£æ ¼çš„åº”ç”¨
    fmt.Println("2. macOSé£æ ¼åº”ç”¨:")
    macosFactory := NewMacOSUIFactory()
    macosApp := NewApplication(macosFactory)
    macosApp.Run()
}
```

### ç­–ç•¥æ¨¡å¼

ç­–ç•¥æ¨¡å¼å®šä¹‰äº†ç®—æ³•æ—ï¼Œåˆ†åˆ«å°è£…èµ·æ¥ï¼Œè®©å®ƒä»¬ä¹‹é—´å¯ä»¥äº’ç›¸æ›¿æ¢ã€‚

```go
// æ¥è‡ª mall-go/internal/payment/strategy.go
package payment

import (
    "fmt"
    "math/rand"
    "time"
)

// æ”¯ä»˜ç­–ç•¥æ¥å£
type PaymentStrategy interface {
    Pay(amount float64, orderID string) (*PaymentResult, error)
    GetPaymentMethod() string
    ValidatePayment(amount float64) error
}

// æ”¯ä»˜ç»“æœ
type PaymentResult struct {
    TransactionID string    `json:"transaction_id"`
    Amount        float64   `json:"amount"`
    Method        string    `json:"method"`
    Status        string    `json:"status"`
    Message       string    `json:"message"`
    Timestamp     time.Time `json:"timestamp"`
}

// æ”¯ä»˜å®æ”¯ä»˜ç­–ç•¥
type AlipayStrategy struct {
    appID     string
    appSecret string
}

func NewAlipayStrategy(appID, appSecret string) *AlipayStrategy {
    return &AlipayStrategy{
        appID:     appID,
        appSecret: appSecret,
    }
}

func (a *AlipayStrategy) ValidatePayment(amount float64) error {
    if amount <= 0 {
        return fmt.Errorf("æ”¯ä»˜é‡‘é¢å¿…é¡»å¤§äº0")
    }
    if amount > 50000 {
        return fmt.Errorf("æ”¯ä»˜å®å•ç¬”æ”¯ä»˜é‡‘é¢ä¸èƒ½è¶…è¿‡50000å…ƒ")
    }
    return nil
}

func (a *AlipayStrategy) Pay(amount float64, orderID string) (*PaymentResult, error) {
    if err := a.ValidatePayment(amount); err != nil {
        return nil, err
    }

    // æ¨¡æ‹Ÿæ”¯ä»˜å®æ”¯ä»˜æµç¨‹
    fmt.Printf("æ­£åœ¨é€šè¿‡æ”¯ä»˜å®æ”¯ä»˜ Â¥%.2f (è®¢å•: %s)\n", amount, orderID)

    // æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚å»¶è¿Ÿ
    time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)

    // æ¨¡æ‹Ÿ90%æˆåŠŸç‡
    success := rand.Float32() < 0.9

    result := &PaymentResult{
        TransactionID: fmt.Sprintf("alipay_%d", time.Now().UnixNano()),
        Amount:        amount,
        Method:        a.GetPaymentMethod(),
        Timestamp:     time.Now(),
    }

    if success {
        result.Status = "success"
        result.Message = "æ”¯ä»˜å®æ”¯ä»˜æˆåŠŸ"
    } else {
        result.Status = "failed"
        result.Message = "æ”¯ä»˜å®æ”¯ä»˜å¤±è´¥ï¼Œè¯·é‡è¯•"
    }

    return result, nil
}

func (a *AlipayStrategy) GetPaymentMethod() string {
    return "æ”¯ä»˜å®"
}

// å¾®ä¿¡æ”¯ä»˜ç­–ç•¥
type WechatPayStrategy struct {
    merchantID string
    apiKey     string
}

func NewWechatPayStrategy(merchantID, apiKey string) *WechatPayStrategy {
    return &WechatPayStrategy{
        merchantID: merchantID,
        apiKey:     apiKey,
    }
}

func (w *WechatPayStrategy) ValidatePayment(amount float64) error {
    if amount <= 0 {
        return fmt.Errorf("æ”¯ä»˜é‡‘é¢å¿…é¡»å¤§äº0")
    }
    if amount > 20000 {
        return fmt.Errorf("å¾®ä¿¡æ”¯ä»˜å•ç¬”æ”¯ä»˜é‡‘é¢ä¸èƒ½è¶…è¿‡20000å…ƒ")
    }
    return nil
}

func (w *WechatPayStrategy) Pay(amount float64, orderID string) (*PaymentResult, error) {
    if err := w.ValidatePayment(amount); err != nil {
        return nil, err
    }

    fmt.Printf("æ­£åœ¨é€šè¿‡å¾®ä¿¡æ”¯ä»˜ Â¥%.2f (è®¢å•: %s)\n", amount, orderID)

    time.Sleep(time.Duration(rand.Intn(800)) * time.Millisecond)

    success := rand.Float32() < 0.85

    result := &PaymentResult{
        TransactionID: fmt.Sprintf("wechat_%d", time.Now().UnixNano()),
        Amount:        amount,
        Method:        w.GetPaymentMethod(),
        Timestamp:     time.Now(),
    }

    if success {
        result.Status = "success"
        result.Message = "å¾®ä¿¡æ”¯ä»˜æˆåŠŸ"
    } else {
        result.Status = "failed"
        result.Message = "å¾®ä¿¡æ”¯ä»˜å¤±è´¥ï¼Œè¯·é‡è¯•"
    }

    return result, nil
}

func (w *WechatPayStrategy) GetPaymentMethod() string {
    return "å¾®ä¿¡æ”¯ä»˜"
}

// é“¶è¡Œå¡æ”¯ä»˜ç­–ç•¥
type BankCardStrategy struct {
    bankCode string
    gateway  string
}

func NewBankCardStrategy(bankCode, gateway string) *BankCardStrategy {
    return &BankCardStrategy{
        bankCode: bankCode,
        gateway:  gateway,
    }
}

func (b *BankCardStrategy) ValidatePayment(amount float64) error {
    if amount <= 0 {
        return fmt.Errorf("æ”¯ä»˜é‡‘é¢å¿…é¡»å¤§äº0")
    }
    if amount > 100000 {
        return fmt.Errorf("é“¶è¡Œå¡å•ç¬”æ”¯ä»˜é‡‘é¢ä¸èƒ½è¶…è¿‡100000å…ƒ")
    }
    return nil
}

func (b *BankCardStrategy) Pay(amount float64, orderID string) (*PaymentResult, error) {
    if err := b.ValidatePayment(amount); err != nil {
        return nil, err
    }

    fmt.Printf("æ­£åœ¨é€šè¿‡é“¶è¡Œå¡æ”¯ä»˜ Â¥%.2f (è®¢å•: %s)\n", amount, orderID)

    time.Sleep(time.Duration(rand.Intn(1500)) * time.Millisecond)

    success := rand.Float32() < 0.95

    result := &PaymentResult{
        TransactionID: fmt.Sprintf("bank_%d", time.Now().UnixNano()),
        Amount:        amount,
        Method:        b.GetPaymentMethod(),
        Timestamp:     time.Now(),
    }

    if success {
        result.Status = "success"
        result.Message = "é“¶è¡Œå¡æ”¯ä»˜æˆåŠŸ"
    } else {
        result.Status = "failed"
        result.Message = "é“¶è¡Œå¡æ”¯ä»˜å¤±è´¥ï¼Œè¯·è”ç³»é“¶è¡Œ"
    }

    return result, nil
}

func (b *BankCardStrategy) GetPaymentMethod() string {
    return "é“¶è¡Œå¡"
}

// æ”¯ä»˜ä¸Šä¸‹æ–‡
type PaymentContext struct {
    strategy PaymentStrategy
}

func NewPaymentContext(strategy PaymentStrategy) *PaymentContext {
    return &PaymentContext{strategy: strategy}
}

func (p *PaymentContext) SetStrategy(strategy PaymentStrategy) {
    p.strategy = strategy
    fmt.Printf("åˆ‡æ¢æ”¯ä»˜æ–¹å¼ä¸º: %s\n", strategy.GetPaymentMethod())
}

func (p *PaymentContext) ExecutePayment(amount float64, orderID string) (*PaymentResult, error) {
    if p.strategy == nil {
        return nil, fmt.Errorf("æœªè®¾ç½®æ”¯ä»˜ç­–ç•¥")
    }

    return p.strategy.Pay(amount, orderID)
}

// æ”¯ä»˜æœåŠ¡
type PaymentService struct {
    strategies map[string]PaymentStrategy
    context    *PaymentContext
}

func NewPaymentService() *PaymentService {
    service := &PaymentService{
        strategies: make(map[string]PaymentStrategy),
    }

    // æ³¨å†Œæ”¯ä»˜ç­–ç•¥
    service.RegisterStrategy("alipay", NewAlipayStrategy("app123", "secret456"))
    service.RegisterStrategy("wechat", NewWechatPayStrategy("mch789", "key012"))
    service.RegisterStrategy("bankcard", NewBankCardStrategy("ICBC", "gateway.icbc.com"))

    return service
}

func (s *PaymentService) RegisterStrategy(name string, strategy PaymentStrategy) {
    s.strategies[name] = strategy
    fmt.Printf("æ³¨å†Œæ”¯ä»˜ç­–ç•¥: %s -> %s\n", name, strategy.GetPaymentMethod())
}

func (s *PaymentService) Pay(method string, amount float64, orderID string) (*PaymentResult, error) {
    strategy, exists := s.strategies[method]
    if !exists {
        return nil, fmt.Errorf("ä¸æ”¯æŒçš„æ”¯ä»˜æ–¹å¼: %s", method)
    }

    if s.context == nil {
        s.context = NewPaymentContext(strategy)
    } else {
        s.context.SetStrategy(strategy)
    }

    return s.context.ExecutePayment(amount, orderID)
}

func (s *PaymentService) GetSupportedMethods() []string {
    var methods []string
    for name := range s.strategies {
        methods = append(methods, name)
    }
    return methods
}

// ä½¿ç”¨ç¤ºä¾‹
func DemonstrateStrategyPattern() {
    fmt.Println("\n=== ç­–ç•¥æ¨¡å¼æ¼”ç¤º ===")

    paymentService := NewPaymentService()

    fmt.Printf("\næ”¯æŒçš„æ”¯ä»˜æ–¹å¼: %v\n", paymentService.GetSupportedMethods())

    // æµ‹è¯•è®¢å•
    orders := []struct {
        orderID string
        amount  float64
        method  string
    }{
        {"ORDER001", 299.99, "alipay"},
        {"ORDER002", 1599.00, "wechat"},
        {"ORDER003", 5999.99, "bankcard"},
        {"ORDER004", 99.99, "alipay"},
    }

    fmt.Println("\nå¼€å§‹å¤„ç†è®¢å•:")
    for _, order := range orders {
        fmt.Printf("\nå¤„ç†è®¢å• %s (Â¥%.2f):\n", order.orderID, order.amount)

        result, err := paymentService.Pay(order.method, order.amount, order.orderID)
        if err != nil {
            fmt.Printf("âŒ æ”¯ä»˜å¤±è´¥: %v\n", err)
            continue
        }

        if result.Status == "success" {
            fmt.Printf("âœ… %s\n", result.Message)
            fmt.Printf("   äº¤æ˜“ID: %s\n", result.TransactionID)
        } else {
            fmt.Printf("âŒ %s\n", result.Message)
        }
    }
}
```

### è£…é¥°å™¨æ¨¡å¼

è£…é¥°å™¨æ¨¡å¼å…è®¸å‘ä¸€ä¸ªç°æœ‰çš„å¯¹è±¡æ·»åŠ æ–°çš„åŠŸèƒ½ï¼ŒåŒæ—¶åˆä¸æ”¹å˜å…¶ç»“æ„ã€‚

```go
// æ¥è‡ª mall-go/internal/middleware/decorator.go
package middleware

import (
    "fmt"
    "net/http"
    "time"
)

// HTTPå¤„ç†å™¨æ¥å£
type Handler interface {
    Handle(w http.ResponseWriter, r *http.Request)
}

// åŸºç¡€å¤„ç†å™¨
type BaseHandler struct {
    name string
}

func NewBaseHandler(name string) *BaseHandler {
    return &BaseHandler{name: name}
}

func (h *BaseHandler) Handle(w http.ResponseWriter, r *http.Request) {
    fmt.Printf("åŸºç¡€å¤„ç†å™¨ '%s' å¤„ç†è¯·æ±‚: %s %s\n", h.name, r.Method, r.URL.Path)
    w.WriteHeader(http.StatusOK)
    w.Write([]byte(fmt.Sprintf("Hello from %s", h.name)))
}

// è£…é¥°å™¨åŸºç±»
type HandlerDecorator struct {
    handler Handler
}

// æ—¥å¿—è£…é¥°å™¨
type LoggingDecorator struct {
    HandlerDecorator
    logger string
}

func NewLoggingDecorator(handler Handler, logger string) *LoggingDecorator {
    return &LoggingDecorator{
        HandlerDecorator: HandlerDecorator{handler: handler},
        logger:          logger,
    }
}

func (d *LoggingDecorator) Handle(w http.ResponseWriter, r *http.Request) {
    start := time.Now()

    fmt.Printf("[%s] è¯·æ±‚å¼€å§‹: %s %s\n", d.logger, r.Method, r.URL.Path)

    // è°ƒç”¨è¢«è£…é¥°çš„å¤„ç†å™¨
    d.handler.Handle(w, r)

    duration := time.Since(start)
    fmt.Printf("[%s] è¯·æ±‚å®Œæˆ: è€—æ—¶ %v\n", d.logger, duration)
}

// è®¤è¯è£…é¥°å™¨
type AuthDecorator struct {
    HandlerDecorator
    requiredRole string
}

func NewAuthDecorator(handler Handler, requiredRole string) *AuthDecorator {
    return &AuthDecorator{
        HandlerDecorator: HandlerDecorator{handler: handler},
        requiredRole:     requiredRole,
    }
}

func (d *AuthDecorator) Handle(w http.ResponseWriter, r *http.Request) {
    // æ¨¡æ‹Ÿè®¤è¯æ£€æŸ¥
    userRole := r.Header.Get("X-User-Role")

    fmt.Printf("[è®¤è¯] æ£€æŸ¥ç”¨æˆ·æƒé™: éœ€è¦ '%s', å½“å‰ '%s'\n", d.requiredRole, userRole)

    if userRole != d.requiredRole {
        fmt.Printf("[è®¤è¯] æƒé™ä¸è¶³ï¼Œæ‹’ç»è®¿é—®\n")
        w.WriteHeader(http.StatusForbidden)
        w.Write([]byte("æƒé™ä¸è¶³"))
        return
    }

    fmt.Printf("[è®¤è¯] æƒé™éªŒè¯é€šè¿‡\n")
    d.handler.Handle(w, r)
}

// é™æµè£…é¥°å™¨
type RateLimitDecorator struct {
    HandlerDecorator
    maxRequests int
    window      time.Duration
    requests    map[string][]time.Time
}

func NewRateLimitDecorator(handler Handler, maxRequests int, window time.Duration) *RateLimitDecorator {
    return &RateLimitDecorator{
        HandlerDecorator: HandlerDecorator{handler: handler},
        maxRequests:      maxRequests,
        window:          window,
        requests:        make(map[string][]time.Time),
    }
}

func (d *RateLimitDecorator) Handle(w http.ResponseWriter, r *http.Request) {
    clientIP := r.RemoteAddr
    now := time.Now()

    // æ¸…ç†è¿‡æœŸçš„è¯·æ±‚è®°å½•
    if requests, exists := d.requests[clientIP]; exists {
        var validRequests []time.Time
        for _, reqTime := range requests {
            if now.Sub(reqTime) < d.window {
                validRequests = append(validRequests, reqTime)
            }
        }
        d.requests[clientIP] = validRequests
    }

    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
    if len(d.requests[clientIP]) >= d.maxRequests {
        fmt.Printf("[é™æµ] å®¢æˆ·ç«¯ %s è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œæ‹’ç»æœåŠ¡\n", clientIP)
        w.WriteHeader(http.StatusTooManyRequests)
        w.Write([]byte("è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•"))
        return
    }

    // è®°å½•å½“å‰è¯·æ±‚
    d.requests[clientIP] = append(d.requests[clientIP], now)
    fmt.Printf("[é™æµ] å®¢æˆ·ç«¯ %s è¯·æ±‚é€šè¿‡ (%d/%d)\n", clientIP, len(d.requests[clientIP]), d.maxRequests)

    d.handler.Handle(w, r)
}

// ç¼“å­˜è£…é¥°å™¨
type CacheDecorator struct {
    HandlerDecorator
    cache map[string]CacheEntry
    ttl   time.Duration
}

type CacheEntry struct {
    data      []byte
    timestamp time.Time
}

func NewCacheDecorator(handler Handler, ttl time.Duration) *CacheDecorator {
    return &CacheDecorator{
        HandlerDecorator: HandlerDecorator{handler: handler},
        cache:           make(map[string]CacheEntry),
        ttl:             ttl,
    }
}

func (d *CacheDecorator) Handle(w http.ResponseWriter, r *http.Request) {
    cacheKey := fmt.Sprintf("%s:%s", r.Method, r.URL.Path)

    // æ£€æŸ¥ç¼“å­˜
    if entry, exists := d.cache[cacheKey]; exists {
        if time.Since(entry.timestamp) < d.ttl {
            fmt.Printf("[ç¼“å­˜] ç¼“å­˜å‘½ä¸­: %s\n", cacheKey)
            w.WriteHeader(http.StatusOK)
            w.Write(entry.data)
            return
        } else {
            fmt.Printf("[ç¼“å­˜] ç¼“å­˜è¿‡æœŸ: %s\n", cacheKey)
            delete(d.cache, cacheKey)
        }
    }

    fmt.Printf("[ç¼“å­˜] ç¼“å­˜æœªå‘½ä¸­: %s\n", cacheKey)

    // åˆ›å»ºå“åº”è®°å½•å™¨æ¥æ•è·å“åº”
    recorder := &ResponseRecorder{
        ResponseWriter: w,
        body:          make([]byte, 0),
    }

    d.handler.Handle(recorder, r)

    // ç¼“å­˜å“åº”
    d.cache[cacheKey] = CacheEntry{
        data:      recorder.body,
        timestamp: time.Now(),
    }

    fmt.Printf("[ç¼“å­˜] å“åº”å·²ç¼“å­˜: %s\n", cacheKey)
}

// å“åº”è®°å½•å™¨
type ResponseRecorder struct {
    http.ResponseWriter
    body []byte
}

func (r *ResponseRecorder) Write(data []byte) (int, error) {
    r.body = append(r.body, data...)
    return r.ResponseWriter.Write(data)
}

// è£…é¥°å™¨æ„å»ºå™¨
type DecoratorBuilder struct {
    handler Handler
}

func NewDecoratorBuilder(handler Handler) *DecoratorBuilder {
    return &DecoratorBuilder{handler: handler}
}

func (b *DecoratorBuilder) WithLogging(logger string) *DecoratorBuilder {
    b.handler = NewLoggingDecorator(b.handler, logger)
    return b
}

func (b *DecoratorBuilder) WithAuth(requiredRole string) *DecoratorBuilder {
    b.handler = NewAuthDecorator(b.handler, requiredRole)
    return b
}

func (b *DecoratorBuilder) WithRateLimit(maxRequests int, window time.Duration) *DecoratorBuilder {
    b.handler = NewRateLimitDecorator(b.handler, maxRequests, window)
    return b
}

func (b *DecoratorBuilder) WithCache(ttl time.Duration) *DecoratorBuilder {
    b.handler = NewCacheDecorator(b.handler, ttl)
    return b
}

func (b *DecoratorBuilder) Build() Handler {
    return b.handler
}

// ä½¿ç”¨ç¤ºä¾‹
func DemonstrateDecoratorPattern() {
    fmt.Println("\n=== è£…é¥°å™¨æ¨¡å¼æ¼”ç¤º ===")

    // åˆ›å»ºåŸºç¡€å¤„ç†å™¨
    baseHandler := NewBaseHandler("ç”¨æˆ·æœåŠ¡")

    // ä½¿ç”¨æ„å»ºå™¨æ¨¡å¼ç»„åˆè£…é¥°å™¨
    decoratedHandler := NewDecoratorBuilder(baseHandler).
        WithLogging("UserService").
        WithAuth("admin").
        WithRateLimit(3, time.Minute).
        WithCache(30 * time.Second).
        Build()

    // æ¨¡æ‹ŸHTTPè¯·æ±‚
    fmt.Println("\næ¨¡æ‹ŸHTTPè¯·æ±‚å¤„ç†:")

    // åˆ›å»ºæ¨¡æ‹Ÿè¯·æ±‚
    requests := []*http.Request{
        {
            Method: "GET",
            URL:    &url.URL{Path: "/users"},
            Header: http.Header{"X-User-Role": []string{"admin"}},
            RemoteAddr: "192.168.1.100",
        },
        {
            Method: "GET",
            URL:    &url.URL{Path: "/users"},
            Header: http.Header{"X-User-Role": []string{"user"}},
            RemoteAddr: "192.168.1.101",
        },
        {
            Method: "GET",
            URL:    &url.URL{Path: "/users"},
            Header: http.Header{"X-User-Role": []string{"admin"}},
            RemoteAddr: "192.168.1.100",
        },
    }

    for i, req := range requests {
        fmt.Printf("\n--- è¯·æ±‚ %d ---\n", i+1)

        // åˆ›å»ºæ¨¡æ‹Ÿå“åº”å†™å…¥å™¨
        w := &MockResponseWriter{}

        decoratedHandler.Handle(w, req)

        fmt.Printf("å“åº”çŠ¶æ€: %d\n", w.statusCode)
        if len(w.body) > 0 {
            fmt.Printf("å“åº”å†…å®¹: %s\n", string(w.body))
        }
    }
}

// æ¨¡æ‹Ÿå“åº”å†™å…¥å™¨
type MockResponseWriter struct {
    statusCode int
    body       []byte
    header     http.Header
}

func (w *MockResponseWriter) Header() http.Header {
    if w.header == nil {
        w.header = make(http.Header)
    }
    return w.header
}

func (w *MockResponseWriter) Write(data []byte) (int, error) {
    w.body = append(w.body, data...)
    return len(data), nil
}

func (w *MockResponseWriter) WriteHeader(statusCode int) {
    w.statusCode = statusCode
}
```

### é€‚é…å™¨æ¨¡å¼

é€‚é…å™¨æ¨¡å¼å°†ä¸€ä¸ªç±»çš„æ¥å£è½¬æ¢æˆå®¢æˆ·å¸Œæœ›çš„å¦ä¸€ä¸ªæ¥å£ã€‚

```go
// æ¥è‡ª mall-go/internal/adapter/database_adapter.go
package adapter

import (
    "fmt"
    "time"
)

// ç›®æ ‡æ¥å£ï¼šç»Ÿä¸€çš„æ•°æ®åº“æ“ä½œæ¥å£
type DatabaseInterface interface {
    Connect() error
    Disconnect() error
    Query(sql string) ([]map[string]interface{}, error)
    Execute(sql string) error
    GetConnectionInfo() string
}

// ç¬¬ä¸‰æ–¹MySQLåº“ï¼ˆè¢«é€‚é…è€…ï¼‰
type MySQLClient struct {
    host     string
    port     int
    username string
    password string
    database string
    connected bool
}

func NewMySQLClient(host string, port int, username, password, database string) *MySQLClient {
    return &MySQLClient{
        host:     host,
        port:     port,
        username: username,
        password: password,
        database: database,
    }
}

func (m *MySQLClient) OpenConnection() error {
    fmt.Printf("MySQL: è¿æ¥åˆ° %s:%d/%s\n", m.host, m.port, m.database)
    m.connected = true
    return nil
}

func (m *MySQLClient) CloseConnection() error {
    fmt.Printf("MySQL: å…³é—­è¿æ¥\n")
    m.connected = false
    return nil
}

func (m *MySQLClient) ExecuteQuery(query string) ([]map[string]interface{}, error) {
    if !m.connected {
        return nil, fmt.Errorf("MySQLè¿æ¥æœªå»ºç«‹")
    }

    fmt.Printf("MySQL: æ‰§è¡ŒæŸ¥è¯¢ - %s\n", query)

    // æ¨¡æ‹ŸæŸ¥è¯¢ç»“æœ
    results := []map[string]interface{}{
        {"id": 1, "name": "å¼ ä¸‰", "email": "zhangsan@example.com"},
        {"id": 2, "name": "æå››", "email": "lisi@example.com"},
    }

    return results, nil
}

func (m *MySQLClient) ExecuteCommand(command string) error {
    if !m.connected {
        return fmt.Errorf("MySQLè¿æ¥æœªå»ºç«‹")
    }

    fmt.Printf("MySQL: æ‰§è¡Œå‘½ä»¤ - %s\n", command)
    return nil
}

// ç¬¬ä¸‰æ–¹PostgreSQLåº“ï¼ˆè¢«é€‚é…è€…ï¼‰
type PostgreSQLClient struct {
    connectionString string
    isConnected     bool
}

func NewPostgreSQLClient(connectionString string) *PostgreSQLClient {
    return &PostgreSQLClient{
        connectionString: connectionString,
    }
}

func (p *PostgreSQLClient) EstablishConnection() error {
    fmt.Printf("PostgreSQL: å»ºç«‹è¿æ¥ - %s\n", p.connectionString)
    p.isConnected = true
    return nil
}

func (p *PostgreSQLClient) TerminateConnection() error {
    fmt.Printf("PostgreSQL: ç»ˆæ­¢è¿æ¥\n")
    p.isConnected = false
    return nil
}

func (p *PostgreSQLClient) RunQuery(sql string) ([]map[string]interface{}, error) {
    if !p.isConnected {
        return nil, fmt.Errorf("PostgreSQLè¿æ¥æœªå»ºç«‹")
    }

    fmt.Printf("PostgreSQL: è¿è¡ŒæŸ¥è¯¢ - %s\n", sql)

    // æ¨¡æ‹ŸæŸ¥è¯¢ç»“æœ
    results := []map[string]interface{}{
        {"user_id": 1, "username": "admin", "role": "administrator"},
        {"user_id": 2, "username": "user1", "role": "user"},
    }

    return results, nil
}

func (p *PostgreSQLClient) RunCommand(sql string) error {
    if !p.isConnected {
        return fmt.Errorf("PostgreSQLè¿æ¥æœªå»ºç«‹")
    }

    fmt.Printf("PostgreSQL: è¿è¡Œå‘½ä»¤ - %s\n", sql)
    return nil
}

// MySQLé€‚é…å™¨
type MySQLAdapter struct {
    client *MySQLClient
}

func NewMySQLAdapter(client *MySQLClient) *MySQLAdapter {
    return &MySQLAdapter{client: client}
}

func (a *MySQLAdapter) Connect() error {
    return a.client.OpenConnection()
}

func (a *MySQLAdapter) Disconnect() error {
    return a.client.CloseConnection()
}

func (a *MySQLAdapter) Query(sql string) ([]map[string]interface{}, error) {
    return a.client.ExecuteQuery(sql)
}

func (a *MySQLAdapter) Execute(sql string) error {
    return a.client.ExecuteCommand(sql)
}

func (a *MySQLAdapter) GetConnectionInfo() string {
    return fmt.Sprintf("MySQL - %s:%d/%s", a.client.host, a.client.port, a.client.database)
}

// PostgreSQLé€‚é…å™¨
type PostgreSQLAdapter struct {
    client *PostgreSQLClient
}

func NewPostgreSQLAdapter(client *PostgreSQLClient) *PostgreSQLAdapter {
    return &PostgreSQLAdapter{client: client}
}

func (a *PostgreSQLAdapter) Connect() error {
    return a.client.EstablishConnection()
}

func (a *PostgreSQLAdapter) Disconnect() error {
    return a.client.TerminateConnection()
}

func (a *PostgreSQLAdapter) Query(sql string) ([]map[string]interface{}, error) {
    return a.client.RunQuery(sql)
}

func (a *PostgreSQLAdapter) Execute(sql string) error {
    return a.client.RunCommand(sql)
}

func (a *PostgreSQLAdapter) GetConnectionInfo() string {
    return fmt.Sprintf("PostgreSQL - %s", a.client.connectionString)
}

// æ•°æ®åº“ç®¡ç†å™¨
type DatabaseManager struct {
    databases map[string]DatabaseInterface
}

func NewDatabaseManager() *DatabaseManager {
    return &DatabaseManager{
        databases: make(map[string]DatabaseInterface),
    }
}

func (dm *DatabaseManager) RegisterDatabase(name string, db DatabaseInterface) {
    dm.databases[name] = db
    fmt.Printf("æ³¨å†Œæ•°æ®åº“: %s -> %s\n", name, db.GetConnectionInfo())
}

func (dm *DatabaseManager) GetDatabase(name string) (DatabaseInterface, error) {
    db, exists := dm.databases[name]
    if !exists {
        return nil, fmt.Errorf("æ•°æ®åº“ '%s' æœªæ³¨å†Œ", name)
    }
    return db, nil
}

func (dm *DatabaseManager) ExecuteOnAll(operation func(DatabaseInterface) error) {
    for name, db := range dm.databases {
        fmt.Printf("\nåœ¨æ•°æ®åº“ '%s' ä¸Šæ‰§è¡Œæ“ä½œ:\n", name)
        if err := operation(db); err != nil {
            fmt.Printf("æ“ä½œå¤±è´¥: %v\n", err)
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func DemonstrateAdapterPattern() {
    fmt.Println("\n=== é€‚é…å™¨æ¨¡å¼æ¼”ç¤º ===")

    // åˆ›å»ºæ•°æ®åº“ç®¡ç†å™¨
    manager := NewDatabaseManager()

    // åˆ›å»ºMySQLå®¢æˆ·ç«¯å’Œé€‚é…å™¨
    mysqlClient := NewMySQLClient("localhost", 3306, "root", "password", "mall")
    mysqlAdapter := NewMySQLAdapter(mysqlClient)

    // åˆ›å»ºPostgreSQLå®¢æˆ·ç«¯å’Œé€‚é…å™¨
    pgClient := NewPostgreSQLClient("postgresql://user:pass@localhost:5432/mall")
    pgAdapter := NewPostgreSQLAdapter(pgClient)

    // æ³¨å†Œæ•°æ®åº“
    manager.RegisterDatabase("mysql", mysqlAdapter)
    manager.RegisterDatabase("postgresql", pgAdapter)

    // ç»Ÿä¸€æ“ä½œä¸åŒçš„æ•°æ®åº“
    fmt.Println("\n=== ç»Ÿä¸€æ•°æ®åº“æ“ä½œæ¼”ç¤º ===")

    // è¿æ¥æ‰€æœ‰æ•°æ®åº“
    manager.ExecuteOnAll(func(db DatabaseInterface) error {
        return db.Connect()
    })

    // åœ¨æ‰€æœ‰æ•°æ®åº“ä¸Šæ‰§è¡ŒæŸ¥è¯¢
    manager.ExecuteOnAll(func(db DatabaseInterface) error {
        results, err := db.Query("SELECT * FROM users")
        if err != nil {
            return err
        }

        fmt.Printf("æŸ¥è¯¢ç»“æœ (%d æ¡è®°å½•):\n", len(results))
        for i, result := range results {
            fmt.Printf("  %d: %v\n", i+1, result)
        }

        return nil
    })

    // åœ¨æ‰€æœ‰æ•°æ®åº“ä¸Šæ‰§è¡Œå‘½ä»¤
    manager.ExecuteOnAll(func(db DatabaseInterface) error {
        return db.Execute("UPDATE users SET last_login = NOW()")
    })

    // æ–­å¼€æ‰€æœ‰æ•°æ®åº“è¿æ¥
    manager.ExecuteOnAll(func(db DatabaseInterface) error {
        return db.Disconnect()
    })

    // æ¼”ç¤ºå•ç‹¬ä½¿ç”¨ç‰¹å®šæ•°æ®åº“
    fmt.Println("\n=== å•ç‹¬æ•°æ®åº“æ“ä½œæ¼”ç¤º ===")

    mysql, err := manager.GetDatabase("mysql")
    if err != nil {
        fmt.Printf("è·å–MySQLæ•°æ®åº“å¤±è´¥: %v\n", err)
        return
    }

    fmt.Printf("ä½¿ç”¨æ•°æ®åº“: %s\n", mysql.GetConnectionInfo())
    mysql.Connect()

    results, err := mysql.Query("SELECT COUNT(*) FROM orders")
    if err != nil {
        fmt.Printf("æŸ¥è¯¢å¤±è´¥: %v\n", err)
    } else {
        fmt.Printf("è®¢å•ç»Ÿè®¡: %v\n", results)
    }

    mysql.Disconnect()
}
```

---

## ğŸ’‰ ä¾èµ–æ³¨å…¥å’Œæ§åˆ¶åè½¬

ä¾èµ–æ³¨å…¥æ˜¯ä¸€ç§å®ç°æ§åˆ¶åè½¬çš„æŠ€æœ¯ï¼ŒGoè¯­è¨€ä¸­å¯ä»¥é€šè¿‡æ¥å£å’Œæ„é€ å‡½æ•°å®ç°ã€‚

```go
// æ¥è‡ª mall-go/internal/di/dependency_injection.go
package di

import (
    "fmt"
    "reflect"
    "sync"
)

// æœåŠ¡æ¥å£å®šä¹‰
type UserRepository interface {
    GetUser(id int64) (*User, error)
    SaveUser(user *User) error
}

type EmailService interface {
    SendEmail(to, subject, body string) error
}

type LoggerService interface {
    Log(level string, message string)
    Error(message string)
    Info(message string)
}

// æ•°æ®æ¨¡å‹
type User struct {
    ID    int64  `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

// å…·ä½“å®ç°
type DatabaseUserRepository struct {
    connectionString string
    logger          LoggerService
}

func NewDatabaseUserRepository(connectionString string, logger LoggerService) *DatabaseUserRepository {
    return &DatabaseUserRepository{
        connectionString: connectionString,
        logger:          logger,
    }
}

func (r *DatabaseUserRepository) GetUser(id int64) (*User, error) {
    r.logger.Info(fmt.Sprintf("ä»æ•°æ®åº“è·å–ç”¨æˆ·: %d", id))

    // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
    user := &User{
        ID:    id,
        Name:  fmt.Sprintf("ç”¨æˆ·%d", id),
        Email: fmt.Sprintf("user%d@example.com", id),
    }

    return user, nil
}

func (r *DatabaseUserRepository) SaveUser(user *User) error {
    r.logger.Info(fmt.Sprintf("ä¿å­˜ç”¨æˆ·åˆ°æ•°æ®åº“: %s", user.Name))
    return nil
}

type SMTPEmailService struct {
    host   string
    port   int
    logger LoggerService
}

func NewSMTPEmailService(host string, port int, logger LoggerService) *SMTPEmailService {
    return &SMTPEmailService{
        host:   host,
        port:   port,
        logger: logger,
    }
}

func (s *SMTPEmailService) SendEmail(to, subject, body string) error {
    s.logger.Info(fmt.Sprintf("é€šè¿‡SMTPå‘é€é‚®ä»¶: %s -> %s", subject, to))
    fmt.Printf("ğŸ“§ é‚®ä»¶å·²å‘é€: %s\n", subject)
    return nil
}

type ConsoleLogger struct {
    prefix string
}

func NewConsoleLogger(prefix string) *ConsoleLogger {
    return &ConsoleLogger{prefix: prefix}
}

func (l *ConsoleLogger) Log(level string, message string) {
    fmt.Printf("[%s] %s: %s\n", l.prefix, level, message)
}

func (l *ConsoleLogger) Error(message string) {
    l.Log("ERROR", message)
}

func (l *ConsoleLogger) Info(message string) {
    l.Log("INFO", message)
}

// ç”¨æˆ·æœåŠ¡ - ä¾èµ–æ³¨å…¥çš„ç›®æ ‡
type UserService struct {
    userRepo     UserRepository
    emailService EmailService
    logger       LoggerService
}

// æ„é€ å‡½æ•°æ³¨å…¥
func NewUserService(userRepo UserRepository, emailService EmailService, logger LoggerService) *UserService {
    return &UserService{
        userRepo:     userRepo,
        emailService: emailService,
        logger:       logger,
    }
}

func (s *UserService) RegisterUser(name, email string) (*User, error) {
    s.logger.Info(fmt.Sprintf("æ³¨å†Œæ–°ç”¨æˆ·: %s", name))

    user := &User{
        ID:    time.Now().Unix(),
        Name:  name,
        Email: email,
    }

    // ä¿å­˜ç”¨æˆ·
    if err := s.userRepo.SaveUser(user); err != nil {
        s.logger.Error(fmt.Sprintf("ä¿å­˜ç”¨æˆ·å¤±è´¥: %v", err))
        return nil, err
    }

    // å‘é€æ¬¢è¿é‚®ä»¶
    welcomeSubject := "æ¬¢è¿æ³¨å†Œ"
    welcomeBody := fmt.Sprintf("æ¬¢è¿ %s æ³¨å†Œæˆ‘ä»¬çš„æœåŠ¡ï¼", name)

    if err := s.emailService.SendEmail(email, welcomeSubject, welcomeBody); err != nil {
        s.logger.Error(fmt.Sprintf("å‘é€æ¬¢è¿é‚®ä»¶å¤±è´¥: %v", err))
        // é‚®ä»¶å‘é€å¤±è´¥ä¸å½±å“ç”¨æˆ·æ³¨å†Œ
    }

    s.logger.Info(fmt.Sprintf("ç”¨æˆ·æ³¨å†ŒæˆåŠŸ: %s", name))
    return user, nil
}

func (s *UserService) GetUserProfile(id int64) (*User, error) {
    s.logger.Info(fmt.Sprintf("è·å–ç”¨æˆ·èµ„æ–™: %d", id))
    return s.userRepo.GetUser(id)
}

// ç®€å•çš„ä¾èµ–æ³¨å…¥å®¹å™¨
type DIContainer struct {
    services map[reflect.Type]interface{}
    mu       sync.RWMutex
}

func NewDIContainer() *DIContainer {
    return &DIContainer{
        services: make(map[reflect.Type]interface{}),
    }
}

// æ³¨å†ŒæœåŠ¡
func (c *DIContainer) Register(serviceType interface{}, implementation interface{}) {
    c.mu.Lock()
    defer c.mu.Unlock()

    t := reflect.TypeOf(serviceType).Elem() // è·å–æ¥å£ç±»å‹
    c.services[t] = implementation

    fmt.Printf("æ³¨å†ŒæœåŠ¡: %s -> %T\n", t.Name(), implementation)
}

// è§£ææœåŠ¡
func (c *DIContainer) Resolve(serviceType interface{}) (interface{}, error) {
    c.mu.RLock()
    defer c.mu.RUnlock()

    t := reflect.TypeOf(serviceType).Elem()
    service, exists := c.services[t]
    if !exists {
        return nil, fmt.Errorf("æœåŠ¡ %s æœªæ³¨å†Œ", t.Name())
    }

    return service, nil
}

// è‡ªåŠ¨è£…é…
func (c *DIContainer) Autowire(target interface{}) error {
    targetValue := reflect.ValueOf(target)
    if targetValue.Kind() != reflect.Ptr {
        return fmt.Errorf("ç›®æ ‡å¿…é¡»æ˜¯æŒ‡é’ˆç±»å‹")
    }

    targetValue = targetValue.Elem()
    targetType := targetValue.Type()

    for i := 0; i < targetValue.NumField(); i++ {
        field := targetValue.Field(i)
        fieldType := targetType.Field(i)

        // æ£€æŸ¥æ˜¯å¦æœ‰ä¾èµ–æ³¨å…¥æ ‡ç­¾
        if tag := fieldType.Tag.Get("inject"); tag == "true" {
            if !field.CanSet() {
                continue
            }

            // è§£æä¾èµ–
            service, err := c.Resolve(reflect.New(field.Type()).Interface())
            if err != nil {
                return fmt.Errorf("æ— æ³•è§£æå­—æ®µ %s çš„ä¾èµ–: %v", fieldType.Name, err)
            }

            field.Set(reflect.ValueOf(service))
            fmt.Printf("è‡ªåŠ¨è£…é…: %s.%s\n", targetType.Name(), fieldType.Name)
        }
    }

    return nil
}

// æ”¯æŒè‡ªåŠ¨è£…é…çš„ç”¨æˆ·æœåŠ¡
type AutowiredUserService struct {
    UserRepo     UserRepository `inject:"true"`
    EmailService EmailService   `inject:"true"`
    Logger       LoggerService  `inject:"true"`
}

func (s *AutowiredUserService) ProcessUser(name, email string) {
    s.Logger.Info(fmt.Sprintf("å¤„ç†ç”¨æˆ·: %s", name))

    user := &User{
        ID:    time.Now().Unix(),
        Name:  name,
        Email: email,
    }

    s.UserRepo.SaveUser(user)
    s.EmailService.SendEmail(email, "å¤„ç†å®Œæˆ", "æ‚¨çš„ç”¨æˆ·ä¿¡æ¯å·²å¤„ç†å®Œæˆ")
}

// ä½¿ç”¨ç¤ºä¾‹
func DemonstrateDependencyInjection() {
    fmt.Println("\n=== ä¾èµ–æ³¨å…¥æ¼”ç¤º ===")

    // 1. æ‰‹åŠ¨ä¾èµ–æ³¨å…¥
    fmt.Println("1. æ‰‹åŠ¨ä¾èµ–æ³¨å…¥:")

    logger := NewConsoleLogger("UserService")
    userRepo := NewDatabaseUserRepository("mysql://localhost:3306/mall", logger)
    emailService := NewSMTPEmailService("smtp.example.com", 587, logger)

    userService := NewUserService(userRepo, emailService, logger)

    user, err := userService.RegisterUser("å¼ ä¸‰", "zhangsan@example.com")
    if err != nil {
        fmt.Printf("ç”¨æˆ·æ³¨å†Œå¤±è´¥: %v\n", err)
    } else {
        fmt.Printf("ç”¨æˆ·æ³¨å†ŒæˆåŠŸ: %+v\n", user)
    }

    // 2. ä½¿ç”¨DIå®¹å™¨
    fmt.Println("\n2. ä½¿ç”¨DIå®¹å™¨:")

    container := NewDIContainer()

    // æ³¨å†ŒæœåŠ¡
    container.Register((*LoggerService)(nil), logger)
    container.Register((*UserRepository)(nil), userRepo)
    container.Register((*EmailService)(nil), emailService)

    // è§£ææœåŠ¡
    resolvedLogger, _ := container.Resolve((*LoggerService)(nil))
    resolvedUserRepo, _ := container.Resolve((*UserRepository)(nil))
    resolvedEmailService, _ := container.Resolve((*EmailService)(nil))

    containerUserService := NewUserService(
        resolvedUserRepo.(UserRepository),
        resolvedEmailService.(EmailService),
        resolvedLogger.(LoggerService),
    )

    profile, err := containerUserService.GetUserProfile(12345)
    if err != nil {
        fmt.Printf("è·å–ç”¨æˆ·èµ„æ–™å¤±è´¥: %v\n", err)
    } else {
        fmt.Printf("ç”¨æˆ·èµ„æ–™: %+v\n", profile)
    }

    // 3. è‡ªåŠ¨è£…é…
    fmt.Println("\n3. è‡ªåŠ¨è£…é…:")

    autowiredService := &AutowiredUserService{}

    if err := container.Autowire(autowiredService); err != nil {
        fmt.Printf("è‡ªåŠ¨è£…é…å¤±è´¥: %v\n", err)
    } else {
        autowiredService.ProcessUser("æå››", "lisi@example.com")
    }
}
```

---

## ğŸ”— æ¥å£ç»„åˆå’ŒåµŒå…¥

Goè¯­è¨€é€šè¿‡æ¥å£åµŒå…¥å®ç°ç»„åˆï¼Œè¿™æ˜¯ä¸€ç§å¼ºå¤§çš„è®¾è®¡æŠ€æœ¯ã€‚

```go
// æ¥è‡ª mall-go/internal/composition/interface_composition.go
package composition

import (
    "fmt"
    "time"
)

// åŸºç¡€æ¥å£
type Reader interface {
    Read(data []byte) (int, error)
}

type Writer interface {
    Write(data []byte) (int, error)
}

type Closer interface {
    Close() error
}

type Seeker interface {
    Seek(offset int64, whence int) (int64, error)
}

// ç»„åˆæ¥å£
type ReadWriter interface {
    Reader
    Writer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}

type ReadWriteSeeker interface {
    Reader
    Writer
    Seeker
}

type ReadWriteSeekCloser interface {
    Reader
    Writer
    Seeker
    Closer
}

// æ–‡ä»¶æ“ä½œæ¥å£
type FileOperations interface {
    ReadWriteSeekCloser

    // æ‰©å±•æ–¹æ³•
    GetSize() int64
    GetPath() string
    IsOpen() bool
}

// å…·ä½“å®ç°ï¼šå†…å­˜æ–‡ä»¶
type MemoryFile struct {
    data     []byte
    position int64
    path     string
    isOpen   bool
}

func NewMemoryFile(path string, initialData []byte) *MemoryFile {
    data := make([]byte, len(initialData))
    copy(data, initialData)

    return &MemoryFile{
        data:   data,
        path:   path,
        isOpen: true,
    }
}

func (m *MemoryFile) Read(data []byte) (int, error) {
    if !m.isOpen {
        return 0, fmt.Errorf("æ–‡ä»¶å·²å…³é—­")
    }

    if m.position >= int64(len(m.data)) {
        return 0, fmt.Errorf("å·²åˆ°è¾¾æ–‡ä»¶æœ«å°¾")
    }

    n := copy(data, m.data[m.position:])
    m.position += int64(n)

    fmt.Printf("ä»å†…å­˜æ–‡ä»¶è¯»å– %d å­—èŠ‚\n", n)
    return n, nil
}

func (m *MemoryFile) Write(data []byte) (int, error) {
    if !m.isOpen {
        return 0, fmt.Errorf("æ–‡ä»¶å·²å…³é—­")
    }

    // æ‰©å±•æ•°æ®åˆ‡ç‰‡å¦‚æœéœ€è¦
    needed := m.position + int64(len(data))
    if needed > int64(len(m.data)) {
        newData := make([]byte, needed)
        copy(newData, m.data)
        m.data = newData
    }

    n := copy(m.data[m.position:], data)
    m.position += int64(n)

    fmt.Printf("å‘å†…å­˜æ–‡ä»¶å†™å…¥ %d å­—èŠ‚\n", n)
    return n, nil
}

func (m *MemoryFile) Seek(offset int64, whence int) (int64, error) {
    if !m.isOpen {
        return 0, fmt.Errorf("æ–‡ä»¶å·²å…³é—­")
    }

    var newPosition int64

    switch whence {
    case 0: // ä»æ–‡ä»¶å¼€å§‹
        newPosition = offset
    case 1: // ä»å½“å‰ä½ç½®
        newPosition = m.position + offset
    case 2: // ä»æ–‡ä»¶æœ«å°¾
        newPosition = int64(len(m.data)) + offset
    default:
        return 0, fmt.Errorf("æ— æ•ˆçš„whenceå€¼")
    }

    if newPosition < 0 {
        return 0, fmt.Errorf("æ— æ•ˆçš„æ–‡ä»¶ä½ç½®")
    }

    m.position = newPosition
    fmt.Printf("æ–‡ä»¶ä½ç½®ç§»åŠ¨åˆ°: %d\n", m.position)
    return m.position, nil
}

func (m *MemoryFile) Close() error {
    if !m.isOpen {
        return fmt.Errorf("æ–‡ä»¶å·²ç»å…³é—­")
    }

    m.isOpen = false
    fmt.Printf("å†…å­˜æ–‡ä»¶å·²å…³é—­: %s\n", m.path)
    return nil
}

func (m *MemoryFile) GetSize() int64 {
    return int64(len(m.data))
}

func (m *MemoryFile) GetPath() string {
    return m.path
}

func (m *MemoryFile) IsOpen() bool {
    return m.isOpen
}

// ç½‘ç»œæ–‡ä»¶å®ç°
type NetworkFile struct {
    url      string
    data     []byte
    position int64
    isOpen   bool
}

func NewNetworkFile(url string) *NetworkFile {
    // æ¨¡æ‹Ÿä»ç½‘ç»œåŠ è½½æ•°æ®
    data := []byte(fmt.Sprintf("ç½‘ç»œæ–‡ä»¶å†…å®¹æ¥è‡ª: %s\nè¿™æ˜¯ä¸€äº›ç¤ºä¾‹æ•°æ®...", url))

    return &NetworkFile{
        url:    url,
        data:   data,
        isOpen: true,
    }
}

func (n *NetworkFile) Read(data []byte) (int, error) {
    if !n.isOpen {
        return 0, fmt.Errorf("ç½‘ç»œæ–‡ä»¶è¿æ¥å·²å…³é—­")
    }

    if n.position >= int64(len(n.data)) {
        return 0, fmt.Errorf("å·²åˆ°è¾¾æ–‡ä»¶æœ«å°¾")
    }

    copied := copy(data, n.data[n.position:])
    n.position += int64(copied)

    fmt.Printf("ä»ç½‘ç»œæ–‡ä»¶è¯»å– %d å­—èŠ‚\n", copied)
    return copied, nil
}

func (n *NetworkFile) Write(data []byte) (int, error) {
    return 0, fmt.Errorf("ç½‘ç»œæ–‡ä»¶ä¸æ”¯æŒå†™å…¥æ“ä½œ")
}

func (n *NetworkFile) Seek(offset int64, whence int) (int64, error) {
    if !n.isOpen {
        return 0, fmt.Errorf("ç½‘ç»œæ–‡ä»¶è¿æ¥å·²å…³é—­")
    }

    var newPosition int64

    switch whence {
    case 0:
        newPosition = offset
    case 1:
        newPosition = n.position + offset
    case 2:
        newPosition = int64(len(n.data)) + offset
    default:
        return 0, fmt.Errorf("æ— æ•ˆçš„whenceå€¼")
    }

    if newPosition < 0 || newPosition > int64(len(n.data)) {
        return 0, fmt.Errorf("æ— æ•ˆçš„æ–‡ä»¶ä½ç½®")
    }

    n.position = newPosition
    fmt.Printf("ç½‘ç»œæ–‡ä»¶ä½ç½®ç§»åŠ¨åˆ°: %d\n", n.position)
    return n.position, nil
}

func (n *NetworkFile) Close() error {
    if !n.isOpen {
        return fmt.Errorf("ç½‘ç»œæ–‡ä»¶è¿æ¥å·²ç»å…³é—­")
    }

    n.isOpen = false
    fmt.Printf("ç½‘ç»œæ–‡ä»¶è¿æ¥å·²å…³é—­: %s\n", n.url)
    return nil
}

func (n *NetworkFile) GetSize() int64 {
    return int64(len(n.data))
}

func (n *NetworkFile) GetPath() string {
    return n.url
}

func (n *NetworkFile) IsOpen() bool {
    return n.isOpen
}

// æ–‡ä»¶ç®¡ç†å™¨
type FileManager struct {
    files map[string]FileOperations
}

func NewFileManager() *FileManager {
    return &FileManager{
        files: make(map[string]FileOperations),
    }
}

func (fm *FileManager) RegisterFile(name string, file FileOperations) {
    fm.files[name] = file
    fmt.Printf("æ³¨å†Œæ–‡ä»¶: %s -> %s\n", name, file.GetPath())
}

func (fm *FileManager) GetFile(name string) (FileOperations, error) {
    file, exists := fm.files[name]
    if !exists {
        return nil, fmt.Errorf("æ–‡ä»¶ '%s' æœªæ‰¾åˆ°", name)
    }
    return file, nil
}

func (fm *FileManager) ProcessFile(name string, processor func(FileOperations) error) error {
    file, err := fm.GetFile(name)
    if err != nil {
        return err
    }

    return processor(file)
}

func (fm *FileManager) ProcessAllFiles(processor func(string, FileOperations) error) {
    for name, file := range fm.files {
        if err := processor(name, file); err != nil {
            fmt.Printf("å¤„ç†æ–‡ä»¶ '%s' å¤±è´¥: %v\n", name, err)
        }
    }
}

// æ–‡ä»¶æ“ä½œå·¥å…·
func CopyData(src Reader, dst Writer) (int64, error) {
    buffer := make([]byte, 1024)
    var totalCopied int64

    for {
        n, err := src.Read(buffer)
        if n > 0 {
            written, writeErr := dst.Write(buffer[:n])
            totalCopied += int64(written)

            if writeErr != nil {
                return totalCopied, writeErr
            }
        }

        if err != nil {
            if err.Error() == "å·²åˆ°è¾¾æ–‡ä»¶æœ«å°¾" {
                break
            }
            return totalCopied, err
        }
    }

    return totalCopied, nil
}

// ä½¿ç”¨ç¤ºä¾‹
func DemonstrateInterfaceComposition() {
    fmt.Println("\n=== æ¥å£ç»„åˆæ¼”ç¤º ===")

    // åˆ›å»ºæ–‡ä»¶ç®¡ç†å™¨
    manager := NewFileManager()

    // åˆ›å»ºä¸åŒç±»å‹çš„æ–‡ä»¶
    memFile := NewMemoryFile("/tmp/memory.txt", []byte("Hello, Memory File!"))
    netFile := NewNetworkFile("https://example.com/data.txt")

    // æ³¨å†Œæ–‡ä»¶
    manager.RegisterFile("memory", memFile)
    manager.RegisterFile("network", netFile)

    // æ¼”ç¤ºæ¥å£ç»„åˆçš„ä½¿ç”¨
    fmt.Println("\n=== æ–‡ä»¶ä¿¡æ¯ ===")
    manager.ProcessAllFiles(func(name string, file FileOperations) error {
        fmt.Printf("æ–‡ä»¶: %s\n", name)
        fmt.Printf("  è·¯å¾„: %s\n", file.GetPath())
        fmt.Printf("  å¤§å°: %d å­—èŠ‚\n", file.GetSize())
        fmt.Printf("  çŠ¶æ€: %v\n", file.IsOpen())
        return nil
    })

    // æ¼”ç¤ºè¯»å–æ“ä½œ
    fmt.Println("\n=== è¯»å–æ“ä½œ ===")
    manager.ProcessFile("memory", func(file FileOperations) error {
        buffer := make([]byte, 50)
        n, err := file.Read(buffer)
        if err != nil {
            return err
        }

        fmt.Printf("è¯»å–å†…å®¹: %s\n", string(buffer[:n]))
        return nil
    })

    // æ¼”ç¤ºå†™å…¥æ“ä½œ
    fmt.Println("\n=== å†™å…¥æ“ä½œ ===")
    manager.ProcessFile("memory", func(file FileOperations) error {
        data := []byte(" è¿½åŠ çš„å†…å®¹!")
        n, err := file.Write(data)
        if err != nil {
            return err
        }

        fmt.Printf("å†™å…¥äº† %d å­—èŠ‚\n", n)
        return nil
    })

    // æ¼”ç¤ºå®šä½æ“ä½œ
    fmt.Println("\n=== å®šä½æ“ä½œ ===")
    manager.ProcessFile("memory", func(file FileOperations) error {
        // ç§»åŠ¨åˆ°æ–‡ä»¶å¼€å§‹
        pos, err := file.Seek(0, 0)
        if err != nil {
            return err
        }

        fmt.Printf("å½“å‰ä½ç½®: %d\n", pos)

        // è¯»å–å®Œæ•´å†…å®¹
        buffer := make([]byte, file.GetSize())
        n, err := file.Read(buffer)
        if err != nil && err.Error() != "å·²åˆ°è¾¾æ–‡ä»¶æœ«å°¾" {
            return err
        }

        fmt.Printf("å®Œæ•´å†…å®¹: %s\n", string(buffer[:n]))
        return nil
    })

    // æ¼”ç¤ºæ–‡ä»¶å¤åˆ¶
    fmt.Println("\n=== æ–‡ä»¶å¤åˆ¶ ===")
    srcFile, _ := manager.GetFile("network")
    dstFile := NewMemoryFile("/tmp/copy.txt", nil)

    // é‡ç½®æºæ–‡ä»¶ä½ç½®
    srcFile.Seek(0, 0)

    copied, err := CopyData(srcFile, dstFile)
    if err != nil {
        fmt.Printf("å¤åˆ¶å¤±è´¥: %v\n", err)
    } else {
        fmt.Printf("å¤åˆ¶äº† %d å­—èŠ‚\n", copied)

        // è¯»å–å¤åˆ¶çš„å†…å®¹
        dstFile.Seek(0, 0)
        buffer := make([]byte, dstFile.GetSize())
        n, _ := dstFile.Read(buffer)
        fmt.Printf("å¤åˆ¶çš„å†…å®¹: %s\n", string(buffer[:n]))
    }

    // å…³é—­æ‰€æœ‰æ–‡ä»¶
    fmt.Println("\n=== å…³é—­æ–‡ä»¶ ===")
    manager.ProcessAllFiles(func(name string, file FileOperations) error {
        return file.Close()
    })

    dstFile.Close()
}
```

---

## ğŸ­ ç©ºæ¥å£å’Œç±»å‹æ–­è¨€

ç©ºæ¥å£`interface{}`æ˜¯Goè¯­è¨€ä¸­çš„ç‰¹æ®Šæ¥å£ï¼Œå¯ä»¥è¡¨ç¤ºä»»ä½•ç±»å‹ã€‚

```go
// æ¥è‡ª mall-go/internal/types/empty_interface.go
package types

import (
    "fmt"
    "reflect"
    "strconv"
)

// é€šç”¨æ•°æ®å®¹å™¨
type DataContainer struct {
    data map[string]interface{}
}

func NewDataContainer() *DataContainer {
    return &DataContainer{
        data: make(map[string]interface{}),
    }
}

func (dc *DataContainer) Set(key string, value interface{}) {
    dc.data[key] = value
    fmt.Printf("è®¾ç½® %s = %v (%T)\n", key, value, value)
}

func (dc *DataContainer) Get(key string) (interface{}, bool) {
    value, exists := dc.data[key]
    return value, exists
}

// ç±»å‹æ–­è¨€æ–¹æ³•
func (dc *DataContainer) GetString(key string) (string, error) {
    value, exists := dc.data[key]
    if !exists {
        return "", fmt.Errorf("é”® '%s' ä¸å­˜åœ¨", key)
    }

    // ç±»å‹æ–­è¨€
    if str, ok := value.(string); ok {
        return str, nil
    }

    return "", fmt.Errorf("é”® '%s' çš„å€¼ä¸æ˜¯å­—ç¬¦ä¸²ç±»å‹ï¼Œå®é™…ç±»å‹: %T", key, value)
}

func (dc *DataContainer) GetInt(key string) (int, error) {
    value, exists := dc.data[key]
    if !exists {
        return 0, fmt.Errorf("é”® '%s' ä¸å­˜åœ¨", key)
    }

    // æ”¯æŒå¤šç§æ•°å­—ç±»å‹çš„è½¬æ¢
    switch v := value.(type) {
    case int:
        return v, nil
    case int32:
        return int(v), nil
    case int64:
        return int(v), nil
    case float32:
        return int(v), nil
    case float64:
        return int(v), nil
    case string:
        // å°è¯•ä»å­—ç¬¦ä¸²è§£æ
        if i, err := strconv.Atoi(v); err == nil {
            return i, nil
        }
        return 0, fmt.Errorf("æ— æ³•å°†å­—ç¬¦ä¸² '%s' è½¬æ¢ä¸ºæ•´æ•°", v)
    default:
        return 0, fmt.Errorf("é”® '%s' çš„å€¼æ— æ³•è½¬æ¢ä¸ºæ•´æ•°ï¼Œå®é™…ç±»å‹: %T", key, value)
    }
}

func (dc *DataContainer) GetFloat(key string) (float64, error) {
    value, exists := dc.data[key]
    if !exists {
        return 0, fmt.Errorf("é”® '%s' ä¸å­˜åœ¨", key)
    }

    switch v := value.(type) {
    case float64:
        return v, nil
    case float32:
        return float64(v), nil
    case int:
        return float64(v), nil
    case int32:
        return float64(v), nil
    case int64:
        return float64(v), nil
    case string:
        if f, err := strconv.ParseFloat(v, 64); err == nil {
            return f, nil
        }
        return 0, fmt.Errorf("æ— æ³•å°†å­—ç¬¦ä¸² '%s' è½¬æ¢ä¸ºæµ®ç‚¹æ•°", v)
    default:
        return 0, fmt.Errorf("é”® '%s' çš„å€¼æ— æ³•è½¬æ¢ä¸ºæµ®ç‚¹æ•°ï¼Œå®é™…ç±»å‹: %T", key, value)
    }
}

func (dc *DataContainer) GetBool(key string) (bool, error) {
    value, exists := dc.data[key]
    if !exists {
        return false, fmt.Errorf("é”® '%s' ä¸å­˜åœ¨", key)
    }

    switch v := value.(type) {
    case bool:
        return v, nil
    case string:
        if b, err := strconv.ParseBool(v); err == nil {
            return b, nil
        }
        return false, fmt.Errorf("æ— æ³•å°†å­—ç¬¦ä¸² '%s' è½¬æ¢ä¸ºå¸ƒå°”å€¼", v)
    case int:
        return v != 0, nil
    default:
        return false, fmt.Errorf("é”® '%s' çš„å€¼æ— æ³•è½¬æ¢ä¸ºå¸ƒå°”å€¼ï¼Œå®é™…ç±»å‹: %T", key, value)
    }
}

// ç±»å‹å¼€å…³ç¤ºä¾‹
func (dc *DataContainer) ProcessValue(key string) {
    value, exists := dc.data[key]
    if !exists {
        fmt.Printf("é”® '%s' ä¸å­˜åœ¨\n", key)
        return
    }

    fmt.Printf("å¤„ç†é”® '%s' çš„å€¼: ", key)

    // ä½¿ç”¨ç±»å‹å¼€å…³
    switch v := value.(type) {
    case string:
        fmt.Printf("å­—ç¬¦ä¸²: '%s' (é•¿åº¦: %d)\n", v, len(v))
    case int:
        fmt.Printf("æ•´æ•°: %d (äºŒè¿›åˆ¶: %b)\n", v, v)
    case int32:
        fmt.Printf("32ä½æ•´æ•°: %d\n", v)
    case int64:
        fmt.Printf("64ä½æ•´æ•°: %d\n", v)
    case float32:
        fmt.Printf("32ä½æµ®ç‚¹æ•°: %.2f\n", v)
    case float64:
        fmt.Printf("64ä½æµ®ç‚¹æ•°: %.2f\n", v)
    case bool:
        fmt.Printf("å¸ƒå°”å€¼: %t\n", v)
    case []interface{}:
        fmt.Printf("åˆ‡ç‰‡: %v (é•¿åº¦: %d)\n", v, len(v))
    case map[string]interface{}:
        fmt.Printf("æ˜ å°„: %v (é”®æ•°é‡: %d)\n", v, len(v))
    case nil:
        fmt.Println("ç©ºå€¼")
    default:
        fmt.Printf("æœªçŸ¥ç±»å‹: %T, å€¼: %v\n", v, v)
    }
}

// åå°„è¾…åŠ©æ–¹æ³•
func (dc *DataContainer) GetTypeInfo(key string) {
    value, exists := dc.data[key]
    if !exists {
        fmt.Printf("é”® '%s' ä¸å­˜åœ¨\n", key)
        return
    }

    t := reflect.TypeOf(value)
    v := reflect.ValueOf(value)

    fmt.Printf("é”® '%s' çš„ç±»å‹ä¿¡æ¯:\n", key)
    fmt.Printf("  ç±»å‹: %s\n", t)
    fmt.Printf("  ç§ç±»: %s\n", t.Kind())
    fmt.Printf("  å€¼: %v\n", v)

    if t != nil {
        fmt.Printf("  åŒ…è·¯å¾„: %s\n", t.PkgPath())
        fmt.Printf("  ç±»å‹å: %s\n", t.Name())
    }
}

// å®‰å…¨çš„ç±»å‹æ–­è¨€å‡½æ•°
func SafeTypeAssertion[T any](value interface{}) (T, bool) {
    if v, ok := value.(T); ok {
        return v, true
    }
    var zero T
    return zero, false
}

// é€šç”¨è½¬æ¢å™¨
type TypeConverter struct{}

func NewTypeConverter() *TypeConverter {
    return &TypeConverter{}
}

func (tc *TypeConverter) ToString(value interface{}) string {
    if value == nil {
        return ""
    }

    switch v := value.(type) {
    case string:
        return v
    case int, int32, int64:
        return fmt.Sprintf("%d", v)
    case float32, float64:
        return fmt.Sprintf("%.2f", v)
    case bool:
        return strconv.FormatBool(v)
    default:
        return fmt.Sprintf("%v", v)
    }
}

func (tc *TypeConverter) ToInt(value interface{}) (int, error) {
    if value == nil {
        return 0, fmt.Errorf("å€¼ä¸ºnil")
    }

    switch v := value.(type) {
    case int:
        return v, nil
    case int32:
        return int(v), nil
    case int64:
        return int(v), nil
    case float32:
        return int(v), nil
    case float64:
        return int(v), nil
    case string:
        return strconv.Atoi(v)
    case bool:
        if v {
            return 1, nil
        }
        return 0, nil
    default:
        return 0, fmt.Errorf("æ— æ³•å°† %T è½¬æ¢ä¸ºint", value)
    }
}

func (tc *TypeConverter) ToFloat64(value interface{}) (float64, error) {
    if value == nil {
        return 0, fmt.Errorf("å€¼ä¸ºnil")
    }

    switch v := value.(type) {
    case float64:
        return v, nil
    case float32:
        return float64(v), nil
    case int:
        return float64(v), nil
    case int32:
        return float64(v), nil
    case int64:
        return float64(v), nil
    case string:
        return strconv.ParseFloat(v, 64)
    default:
        return 0, fmt.Errorf("æ— æ³•å°† %T è½¬æ¢ä¸ºfloat64", value)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func DemonstrateEmptyInterface() {
    fmt.Println("\n=== ç©ºæ¥å£å’Œç±»å‹æ–­è¨€æ¼”ç¤º ===")

    container := NewDataContainer()
    converter := NewTypeConverter()

    // å­˜å‚¨ä¸åŒç±»å‹çš„æ•°æ®
    fmt.Println("1. å­˜å‚¨ä¸åŒç±»å‹çš„æ•°æ®:")
    container.Set("name", "å¼ ä¸‰")
    container.Set("age", 25)
    container.Set("height", 175.5)
    container.Set("married", false)
    container.Set("hobbies", []interface{}{"è¯»ä¹¦", "æ¸¸æ³³", "ç¼–ç¨‹"})
    container.Set("address", map[string]interface{}{
        "city":    "åŒ—äº¬",
        "district": "æœé˜³åŒº",
        "zipcode":  100000,
    })
    container.Set("score", int64(95))
    container.Set("empty", nil)

    // ç±»å‹æ–­è¨€è·å–æ•°æ®
    fmt.Println("\n2. ç±»å‹æ–­è¨€è·å–æ•°æ®:")

    if name, err := container.GetString("name"); err == nil {
        fmt.Printf("å§“å: %s\n", name)
    } else {
        fmt.Printf("è·å–å§“åå¤±è´¥: %v\n", err)
    }

    if age, err := container.GetInt("age"); err == nil {
        fmt.Printf("å¹´é¾„: %d\n", age)
    } else {
        fmt.Printf("è·å–å¹´é¾„å¤±è´¥: %v\n", err)
    }

    if height, err := container.GetFloat("height"); err == nil {
        fmt.Printf("èº«é«˜: %.1f cm\n", height)
    } else {
        fmt.Printf("è·å–èº«é«˜å¤±è´¥: %v\n", err)
    }

    if married, err := container.GetBool("married"); err == nil {
        fmt.Printf("å·²å©š: %t\n", married)
    } else {
        fmt.Printf("è·å–å©šå§»çŠ¶æ€å¤±è´¥: %v\n", err)
    }

    // ç±»å‹å¼€å…³å¤„ç†
    fmt.Println("\n3. ç±»å‹å¼€å…³å¤„ç†:")
    keys := []string{"name", "age", "height", "married", "hobbies", "address", "score", "empty"}

    for _, key := range keys {
        container.ProcessValue(key)
    }

    // åå°„ç±»å‹ä¿¡æ¯
    fmt.Println("\n4. åå°„ç±»å‹ä¿¡æ¯:")
    container.GetTypeInfo("address")
    container.GetTypeInfo("hobbies")

    // å®‰å…¨ç±»å‹æ–­è¨€
    fmt.Println("\n5. å®‰å…¨ç±»å‹æ–­è¨€:")
    if value, exists := container.Get("age"); exists {
        if age, ok := SafeTypeAssertion[int](value); ok {
            fmt.Printf("å®‰å…¨è·å–å¹´é¾„: %d\n", age)
        } else {
            fmt.Printf("å¹´é¾„ä¸æ˜¯intç±»å‹\n")
        }
    }

    // é€šç”¨è½¬æ¢å™¨
    fmt.Println("\n6. é€šç”¨è½¬æ¢å™¨:")
    testValues := []interface{}{
        "123",
        456,
        78.9,
        true,
        false,
        nil,
    }

    for _, value := range testValues {
        fmt.Printf("åŸå€¼: %v (%T)\n", value, value)
        fmt.Printf("  -> å­—ç¬¦ä¸²: %s\n", converter.ToString(value))

        if intVal, err := converter.ToInt(value); err == nil {
            fmt.Printf("  -> æ•´æ•°: %d\n", intVal)
        } else {
            fmt.Printf("  -> æ•´æ•°è½¬æ¢å¤±è´¥: %v\n", err)
        }

        if floatVal, err := converter.ToFloat64(value); err == nil {
            fmt.Printf("  -> æµ®ç‚¹æ•°: %.2f\n", floatVal)
        } else {
            fmt.Printf("  -> æµ®ç‚¹æ•°è½¬æ¢å¤±è´¥: %v\n", err)
        }

        fmt.Println()
    }
}
```

---

## ğŸ§ª æ¥å£æµ‹è¯•å’ŒMock

æ¥å£æµ‹è¯•æ˜¯Goè¯­è¨€æµ‹è¯•çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼ŒMockæŠ€æœ¯è®©å•å…ƒæµ‹è¯•æ›´åŠ çµæ´»ã€‚

```go
// æ¥è‡ª mall-go/internal/testing/interface_testing.go
package testing

import (
    "errors"
    "fmt"
    "testing"
    "time"
)

// ä¸šåŠ¡æ¥å£å®šä¹‰
type OrderRepository interface {
    GetOrder(id string) (*Order, error)
    SaveOrder(order *Order) error
    DeleteOrder(id string) error
    ListOrders(userID string) ([]*Order, error)
}

type PaymentService interface {
    ProcessPayment(orderID string, amount float64) (*PaymentResult, error)
    RefundPayment(transactionID string) error
    GetPaymentStatus(transactionID string) (string, error)
}

type NotificationService interface {
    SendOrderConfirmation(userID, orderID string) error
    SendPaymentNotification(userID string, amount float64) error
}

// æ•°æ®æ¨¡å‹
type Order struct {
    ID       string    `json:"id"`
    UserID   string    `json:"user_id"`
    Amount   float64   `json:"amount"`
    Status   string    `json:"status"`
    CreateAt time.Time `json:"create_at"`
}

type PaymentResult struct {
    TransactionID string  `json:"transaction_id"`
    Status        string  `json:"status"`
    Amount        float64 `json:"amount"`
}

// è®¢å•æœåŠ¡ï¼ˆè¢«æµ‹è¯•çš„ä¸šåŠ¡é€»è¾‘ï¼‰
type OrderService struct {
    orderRepo    OrderRepository
    paymentSvc   PaymentService
    notificationSvc NotificationService
}

func NewOrderService(orderRepo OrderRepository, paymentSvc PaymentService, notificationSvc NotificationService) *OrderService {
    return &OrderService{
        orderRepo:       orderRepo,
        paymentSvc:      paymentSvc,
        notificationSvc: notificationSvc,
    }
}

func (s *OrderService) CreateOrder(userID string, amount float64) (*Order, error) {
    if amount <= 0 {
        return nil, errors.New("è®¢å•é‡‘é¢å¿…é¡»å¤§äº0")
    }

    order := &Order{
        ID:       fmt.Sprintf("ORDER_%d", time.Now().UnixNano()),
        UserID:   userID,
        Amount:   amount,
        Status:   "pending",
        CreateAt: time.Now(),
    }

    // ä¿å­˜è®¢å•
    if err := s.orderRepo.SaveOrder(order); err != nil {
        return nil, fmt.Errorf("ä¿å­˜è®¢å•å¤±è´¥: %w", err)
    }

    // å‘é€è®¢å•ç¡®è®¤é€šçŸ¥
    if err := s.notificationSvc.SendOrderConfirmation(userID, order.ID); err != nil {
        // é€šçŸ¥å¤±è´¥ä¸å½±å“è®¢å•åˆ›å»º
        fmt.Printf("å‘é€è®¢å•ç¡®è®¤é€šçŸ¥å¤±è´¥: %v\n", err)
    }

    return order, nil
}

func (s *OrderService) PayOrder(orderID string) error {
    // è·å–è®¢å•
    order, err := s.orderRepo.GetOrder(orderID)
    if err != nil {
        return fmt.Errorf("è·å–è®¢å•å¤±è´¥: %w", err)
    }

    if order.Status != "pending" {
        return fmt.Errorf("è®¢å•çŠ¶æ€ä¸æ­£ç¡®: %s", order.Status)
    }

    // å¤„ç†æ”¯ä»˜
    paymentResult, err := s.paymentSvc.ProcessPayment(orderID, order.Amount)
    if err != nil {
        return fmt.Errorf("æ”¯ä»˜å¤„ç†å¤±è´¥: %w", err)
    }

    // æ›´æ–°è®¢å•çŠ¶æ€
    if paymentResult.Status == "success" {
        order.Status = "paid"
    } else {
        order.Status = "payment_failed"
    }

    if err := s.orderRepo.SaveOrder(order); err != nil {
        return fmt.Errorf("æ›´æ–°è®¢å•çŠ¶æ€å¤±è´¥: %w", err)
    }

    // å‘é€æ”¯ä»˜é€šçŸ¥
    if paymentResult.Status == "success" {
        if err := s.notificationSvc.SendPaymentNotification(order.UserID, order.Amount); err != nil {
            fmt.Printf("å‘é€æ”¯ä»˜é€šçŸ¥å¤±è´¥: %v\n", err)
        }
    }

    return nil
}

// Mockå®ç°
type MockOrderRepository struct {
    orders map[string]*Order
    saveError error
    getError  error
}

func NewMockOrderRepository() *MockOrderRepository {
    return &MockOrderRepository{
        orders: make(map[string]*Order),
    }
}

func (m *MockOrderRepository) GetOrder(id string) (*Order, error) {
    if m.getError != nil {
        return nil, m.getError
    }

    order, exists := m.orders[id]
    if !exists {
        return nil, errors.New("è®¢å•ä¸å­˜åœ¨")
    }

    return order, nil
}

func (m *MockOrderRepository) SaveOrder(order *Order) error {
    if m.saveError != nil {
        return m.saveError
    }

    m.orders[order.ID] = order
    return nil
}

func (m *MockOrderRepository) DeleteOrder(id string) error {
    delete(m.orders, id)
    return nil
}

func (m *MockOrderRepository) ListOrders(userID string) ([]*Order, error) {
    var orders []*Order
    for _, order := range m.orders {
        if order.UserID == userID {
            orders = append(orders, order)
        }
    }
    return orders, nil
}

// Mockè®¾ç½®æ–¹æ³•
func (m *MockOrderRepository) SetSaveError(err error) {
    m.saveError = err
}

func (m *MockOrderRepository) SetGetError(err error) {
    m.getError = err
}

func (m *MockOrderRepository) GetOrderCount() int {
    return len(m.orders)
}

type MockPaymentService struct {
    processError error
    refundError  error
    paymentResult *PaymentResult
}

func NewMockPaymentService() *MockPaymentService {
    return &MockPaymentService{
        paymentResult: &PaymentResult{
            TransactionID: "TXN_123456",
            Status:        "success",
            Amount:        0,
        },
    }
}

func (m *MockPaymentService) ProcessPayment(orderID string, amount float64) (*PaymentResult, error) {
    if m.processError != nil {
        return nil, m.processError
    }

    result := *m.paymentResult
    result.Amount = amount
    return &result, nil
}

func (m *MockPaymentService) RefundPayment(transactionID string) error {
    return m.refundError
}

func (m *MockPaymentService) GetPaymentStatus(transactionID string) (string, error) {
    return m.paymentResult.Status, nil
}

// Mockè®¾ç½®æ–¹æ³•
func (m *MockPaymentService) SetProcessError(err error) {
    m.processError = err
}

func (m *MockPaymentService) SetPaymentResult(result *PaymentResult) {
    m.paymentResult = result
}

type MockNotificationService struct {
    confirmationError error
    paymentError      error
    sentNotifications []string
}

func NewMockNotificationService() *MockNotificationService {
    return &MockNotificationService{
        sentNotifications: make([]string, 0),
    }
}

func (m *MockNotificationService) SendOrderConfirmation(userID, orderID string) error {
    if m.confirmationError != nil {
        return m.confirmationError
    }

    m.sentNotifications = append(m.sentNotifications, fmt.Sprintf("order_confirmation_%s_%s", userID, orderID))
    return nil
}

func (m *MockNotificationService) SendPaymentNotification(userID string, amount float64) error {
    if m.paymentError != nil {
        return m.paymentError
    }

    m.sentNotifications = append(m.sentNotifications, fmt.Sprintf("payment_notification_%s_%.2f", userID, amount))
    return nil
}

// Mockè®¾ç½®æ–¹æ³•
func (m *MockNotificationService) SetConfirmationError(err error) {
    m.confirmationError = err
}

func (m *MockNotificationService) SetPaymentError(err error) {
    m.paymentError = err
}

func (m *MockNotificationService) GetSentNotifications() []string {
    return m.sentNotifications
}

// æµ‹è¯•ç”¨ä¾‹
func TestOrderService_CreateOrder(t *testing.T) {
    // å‡†å¤‡Mockå¯¹è±¡
    mockRepo := NewMockOrderRepository()
    mockPayment := NewMockPaymentService()
    mockNotification := NewMockNotificationService()

    service := NewOrderService(mockRepo, mockPayment, mockNotification)

    // æµ‹è¯•ç”¨ä¾‹1ï¼šæ­£å¸¸åˆ›å»ºè®¢å•
    t.Run("æ­£å¸¸åˆ›å»ºè®¢å•", func(t *testing.T) {
        order, err := service.CreateOrder("user123", 99.99)

        if err != nil {
            t.Errorf("åˆ›å»ºè®¢å•å¤±è´¥: %v", err)
        }

        if order == nil {
            t.Error("è®¢å•ä¸åº”è¯¥ä¸ºnil")
        }

        if order.UserID != "user123" {
            t.Errorf("ç”¨æˆ·IDä¸åŒ¹é…: æœŸæœ› user123, å®é™… %s", order.UserID)
        }

        if order.Amount != 99.99 {
            t.Errorf("è®¢å•é‡‘é¢ä¸åŒ¹é…: æœŸæœ› 99.99, å®é™… %.2f", order.Amount)
        }

        if order.Status != "pending" {
            t.Errorf("è®¢å•çŠ¶æ€ä¸åŒ¹é…: æœŸæœ› pending, å®é™… %s", order.Status)
        }

        // éªŒè¯è®¢å•å·²ä¿å­˜
        if mockRepo.GetOrderCount() != 1 {
            t.Errorf("è®¢å•æ•°é‡ä¸åŒ¹é…: æœŸæœ› 1, å®é™… %d", mockRepo.GetOrderCount())
        }

        // éªŒè¯é€šçŸ¥å·²å‘é€
        notifications := mockNotification.GetSentNotifications()
        if len(notifications) != 1 {
            t.Errorf("é€šçŸ¥æ•°é‡ä¸åŒ¹é…: æœŸæœ› 1, å®é™… %d", len(notifications))
        }
    })

    // æµ‹è¯•ç”¨ä¾‹2ï¼šæ— æ•ˆé‡‘é¢
    t.Run("æ— æ•ˆé‡‘é¢", func(t *testing.T) {
        order, err := service.CreateOrder("user123", -10)

        if err == nil {
            t.Error("åº”è¯¥è¿”å›é”™è¯¯")
        }

        if order != nil {
            t.Error("è®¢å•åº”è¯¥ä¸ºnil")
        }
    })

    // æµ‹è¯•ç”¨ä¾‹3ï¼šä¿å­˜è®¢å•å¤±è´¥
    t.Run("ä¿å­˜è®¢å•å¤±è´¥", func(t *testing.T) {
        mockRepo.SetSaveError(errors.New("æ•°æ®åº“è¿æ¥å¤±è´¥"))

        order, err := service.CreateOrder("user123", 50.0)

        if err == nil {
            t.Error("åº”è¯¥è¿”å›é”™è¯¯")
        }

        if order != nil {
            t.Error("è®¢å•åº”è¯¥ä¸ºnil")
        }

        // é‡ç½®é”™è¯¯
        mockRepo.SetSaveError(nil)
    })
}

func TestOrderService_PayOrder(t *testing.T) {
    // å‡†å¤‡Mockå¯¹è±¡
    mockRepo := NewMockOrderRepository()
    mockPayment := NewMockPaymentService()
    mockNotification := NewMockNotificationService()

    service := NewOrderService(mockRepo, mockPayment, mockNotification)

    // å‡†å¤‡æµ‹è¯•æ•°æ®
    testOrder := &Order{
        ID:     "ORDER_123",
        UserID: "user123",
        Amount: 100.0,
        Status: "pending",
    }
    mockRepo.SaveOrder(testOrder)

    // æµ‹è¯•ç”¨ä¾‹1ï¼šæ­£å¸¸æ”¯ä»˜
    t.Run("æ­£å¸¸æ”¯ä»˜", func(t *testing.T) {
        err := service.PayOrder("ORDER_123")

        if err != nil {
            t.Errorf("æ”¯ä»˜å¤±è´¥: %v", err)
        }

        // éªŒè¯è®¢å•çŠ¶æ€å·²æ›´æ–°
        order, _ := mockRepo.GetOrder("ORDER_123")
        if order.Status != "paid" {
            t.Errorf("è®¢å•çŠ¶æ€ä¸åŒ¹é…: æœŸæœ› paid, å®é™… %s", order.Status)
        }

        // éªŒè¯æ”¯ä»˜é€šçŸ¥å·²å‘é€
        notifications := mockNotification.GetSentNotifications()
        found := false
        for _, notification := range notifications {
            if notification == "payment_notification_user123_100.00" {
                found = true
                break
            }
        }
        if !found {
            t.Error("æ”¯ä»˜é€šçŸ¥æœªå‘é€")
        }
    })

    // æµ‹è¯•ç”¨ä¾‹2ï¼šè®¢å•ä¸å­˜åœ¨
    t.Run("è®¢å•ä¸å­˜åœ¨", func(t *testing.T) {
        err := service.PayOrder("NONEXISTENT")

        if err == nil {
            t.Error("åº”è¯¥è¿”å›é”™è¯¯")
        }
    })

    // æµ‹è¯•ç”¨ä¾‹3ï¼šæ”¯ä»˜å¤±è´¥
    t.Run("æ”¯ä»˜å¤±è´¥", func(t *testing.T) {
        // é‡ç½®è®¢å•çŠ¶æ€
        testOrder.Status = "pending"
        mockRepo.SaveOrder(testOrder)

        // è®¾ç½®æ”¯ä»˜å¤±è´¥
        mockPayment.SetPaymentResult(&PaymentResult{
            TransactionID: "TXN_FAILED",
            Status:        "failed",
            Amount:        100.0,
        })

        err := service.PayOrder("ORDER_123")

        if err != nil {
            t.Errorf("æ”¯ä»˜å¤„ç†ä¸åº”è¯¥è¿”å›é”™è¯¯: %v", err)
        }

        // éªŒè¯è®¢å•çŠ¶æ€
        order, _ := mockRepo.GetOrder("ORDER_123")
        if order.Status != "payment_failed" {
            t.Errorf("è®¢å•çŠ¶æ€ä¸åŒ¹é…: æœŸæœ› payment_failed, å®é™… %s", order.Status)
        }
    })
}

// åŸºå‡†æµ‹è¯•
func BenchmarkOrderService_CreateOrder(b *testing.B) {
    mockRepo := NewMockOrderRepository()
    mockPayment := NewMockPaymentService()
    mockNotification := NewMockNotificationService()

    service := NewOrderService(mockRepo, mockPayment, mockNotification)

    b.ResetTimer()

    for i := 0; i < b.N; i++ {
        userID := fmt.Sprintf("user%d", i)
        amount := float64(i%1000 + 1)

        _, err := service.CreateOrder(userID, amount)
        if err != nil {
            b.Errorf("åˆ›å»ºè®¢å•å¤±è´¥: %v", err)
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func DemonstrateInterfaceTesting() {
    fmt.Println("\n=== æ¥å£æµ‹è¯•å’ŒMockæ¼”ç¤º ===")

    // åˆ›å»ºMockå¯¹è±¡
    mockRepo := NewMockOrderRepository()
    mockPayment := NewMockPaymentService()
    mockNotification := NewMockNotificationService()

    // åˆ›å»ºæœåŠ¡
    service := NewOrderService(mockRepo, mockPayment, mockNotification)

    fmt.Println("1. æ­£å¸¸ä¸šåŠ¡æµç¨‹æµ‹è¯•:")

    // åˆ›å»ºè®¢å•
    order, err := service.CreateOrder("user123", 199.99)
    if err != nil {
        fmt.Printf("âŒ åˆ›å»ºè®¢å•å¤±è´¥: %v\n", err)
    } else {
        fmt.Printf("âœ… è®¢å•åˆ›å»ºæˆåŠŸ: %s\n", order.ID)
    }

    // æ”¯ä»˜è®¢å•
    if order != nil {
        err = service.PayOrder(order.ID)
        if err != nil {
            fmt.Printf("âŒ æ”¯ä»˜å¤±è´¥: %v\n", err)
        } else {
            fmt.Printf("âœ… æ”¯ä»˜æˆåŠŸ\n")
        }
    }

    fmt.Println("\n2. å¼‚å¸¸æƒ…å†µæµ‹è¯•:")

    // æµ‹è¯•ä¿å­˜å¤±è´¥
    mockRepo.SetSaveError(errors.New("æ•°æ®åº“è¿æ¥å¤±è´¥"))
    _, err = service.CreateOrder("user456", 99.99)
    if err != nil {
        fmt.Printf("âœ… æ­£ç¡®å¤„ç†ä¿å­˜å¤±è´¥: %v\n", err)
    }

    // é‡ç½®é”™è¯¯
    mockRepo.SetSaveError(nil)

    // æµ‹è¯•æ”¯ä»˜å¤±è´¥
    mockPayment.SetProcessError(errors.New("æ”¯ä»˜ç½‘å…³ä¸å¯ç”¨"))
    if order != nil {
        // é‡ç½®è®¢å•çŠ¶æ€
        order.Status = "pending"
        mockRepo.SaveOrder(order)

        err = service.PayOrder(order.ID)
        if err != nil {
            fmt.Printf("âœ… æ­£ç¡®å¤„ç†æ”¯ä»˜å¤±è´¥: %v\n", err)
        }
    }

    fmt.Println("\n3. MockçŠ¶æ€æ£€æŸ¥:")
    fmt.Printf("è®¢å•æ•°é‡: %d\n", mockRepo.GetOrderCount())
    fmt.Printf("å‘é€çš„é€šçŸ¥: %v\n", mockNotification.GetSentNotifications())
}
```

---

## ğŸ¢ å®æˆ˜æ¡ˆä¾‹åˆ†æ

è®©æˆ‘ä»¬é€šè¿‡mall-goé¡¹ç›®ä¸­çš„çœŸå®æ¡ˆä¾‹ï¼Œæ·±å…¥ç†è§£ä¼ä¸šçº§Goé¡¹ç›®ä¸­çš„æ¥å£è®¾è®¡å®è·µã€‚

### æ¡ˆä¾‹1ï¼šå•†å“æœåŠ¡çš„æ¥å£è®¾è®¡

```go
// æ¥è‡ª mall-go/internal/service/product_service.go
package service

import (
    "context"
    "fmt"
    "time"
)

// å•†å“æ ¸å¿ƒæ¥å£å®šä¹‰
type ProductRepository interface {
    // åŸºç¡€CRUDæ“ä½œ
    Create(ctx context.Context, product *Product) error
    GetByID(ctx context.Context, id int64) (*Product, error)
    Update(ctx context.Context, product *Product) error
    Delete(ctx context.Context, id int64) error

    // æŸ¥è¯¢æ“ä½œ
    List(ctx context.Context, filter *ProductFilter) ([]*Product, error)
    Search(ctx context.Context, keyword string, limit int) ([]*Product, error)
    GetByCategory(ctx context.Context, categoryID int64) ([]*Product, error)
}

// ç¼“å­˜æ¥å£
type ProductCache interface {
    Get(ctx context.Context, key string) (*Product, error)
    Set(ctx context.Context, key string, product *Product, ttl time.Duration) error
    Delete(ctx context.Context, key string) error
    Clear(ctx context.Context, pattern string) error
}

// æœç´¢å¼•æ“æ¥å£
type ProductSearchEngine interface {
    Index(ctx context.Context, product *Product) error
    Search(ctx context.Context, query *SearchQuery) (*SearchResult, error)
    Delete(ctx context.Context, productID int64) error
    BulkIndex(ctx context.Context, products []*Product) error
}

// åº“å­˜ç®¡ç†æ¥å£
type InventoryManager interface {
    CheckStock(ctx context.Context, productID int64, quantity int) (bool, error)
    ReserveStock(ctx context.Context, productID int64, quantity int) (*Reservation, error)
    ReleaseStock(ctx context.Context, reservationID string) error
    UpdateStock(ctx context.Context, productID int64, quantity int) error
}

// ä»·æ ¼è®¡ç®—æ¥å£
type PriceCalculator interface {
    CalculatePrice(ctx context.Context, productID int64, userID int64) (*PriceInfo, error)
    CalculateDiscount(ctx context.Context, productID int64, couponCode string) (*DiscountInfo, error)
    GetPriceHistory(ctx context.Context, productID int64, days int) ([]*PriceHistory, error)
}

// æ•°æ®æ¨¡å‹
type Product struct {
    ID          int64     `json:"id" db:"id"`
    Name        string    `json:"name" db:"name"`
    Description string    `json:"description" db:"description"`
    CategoryID  int64     `json:"category_id" db:"category_id"`
    Price       float64   `json:"price" db:"price"`
    Stock       int       `json:"stock" db:"stock"`
    Status      string    `json:"status" db:"status"`
    CreatedAt   time.Time `json:"created_at" db:"created_at"`
    UpdatedAt   time.Time `json:"updated_at" db:"updated_at"`
}

type ProductFilter struct {
    CategoryID *int64   `json:"category_id,omitempty"`
    PriceMin   *float64 `json:"price_min,omitempty"`
    PriceMax   *float64 `json:"price_max,omitempty"`
    Status     *string  `json:"status,omitempty"`
    Keyword    *string  `json:"keyword,omitempty"`
    Page       int      `json:"page"`
    PageSize   int      `json:"page_size"`
}

type SearchQuery struct {
    Keyword    string            `json:"keyword"`
    Filters    map[string]string `json:"filters"`
    SortBy     string            `json:"sort_by"`
    SortOrder  string            `json:"sort_order"`
    Page       int               `json:"page"`
    PageSize   int               `json:"page_size"`
}

type SearchResult struct {
    Products   []*Product `json:"products"`
    Total      int64      `json:"total"`
    Page       int        `json:"page"`
    PageSize   int        `json:"page_size"`
    Took       int64      `json:"took"` // æœç´¢è€—æ—¶(ms)
}

type Reservation struct {
    ID        string    `json:"id"`
    ProductID int64     `json:"product_id"`
    Quantity  int       `json:"quantity"`
    ExpiresAt time.Time `json:"expires_at"`
}

type PriceInfo struct {
    OriginalPrice float64 `json:"original_price"`
    CurrentPrice  float64 `json:"current_price"`
    Discount      float64 `json:"discount"`
    Currency      string  `json:"currency"`
}

type DiscountInfo struct {
    CouponCode   string  `json:"coupon_code"`
    DiscountType string  `json:"discount_type"` // percentage, fixed
    DiscountValue float64 `json:"discount_value"`
    FinalPrice   float64 `json:"final_price"`
}

type PriceHistory struct {
    Date  time.Time `json:"date"`
    Price float64   `json:"price"`
}

// å•†å“æœåŠ¡å®ç°
type ProductService struct {
    repo          ProductRepository
    cache         ProductCache
    searchEngine  ProductSearchEngine
    inventory     InventoryManager
    priceCalc     PriceCalculator
}

func NewProductService(
    repo ProductRepository,
    cache ProductCache,
    searchEngine ProductSearchEngine,
    inventory InventoryManager,
    priceCalc PriceCalculator,
) *ProductService {
    return &ProductService{
        repo:         repo,
        cache:        cache,
        searchEngine: searchEngine,
        inventory:    inventory,
        priceCalc:    priceCalc,
    }
}

// åˆ›å»ºå•†å“ - å±•ç¤ºæ¥å£åä½œ
func (s *ProductService) CreateProduct(ctx context.Context, product *Product) (*Product, error) {
    // 1. æ•°æ®éªŒè¯
    if err := s.validateProduct(product); err != nil {
        return nil, fmt.Errorf("å•†å“æ•°æ®éªŒè¯å¤±è´¥: %w", err)
    }

    // 2. ä¿å­˜åˆ°æ•°æ®åº“
    if err := s.repo.Create(ctx, product); err != nil {
        return nil, fmt.Errorf("ä¿å­˜å•†å“å¤±è´¥: %w", err)
    }

    // 3. æ·»åŠ åˆ°æœç´¢å¼•æ“
    if err := s.searchEngine.Index(ctx, product); err != nil {
        // æœç´¢å¼•æ“å¤±è´¥ä¸å½±å“å•†å“åˆ›å»ºï¼Œè®°å½•æ—¥å¿—
        fmt.Printf("æ·»åŠ å•†å“åˆ°æœç´¢å¼•æ“å¤±è´¥: %v\n", err)
    }

    // 4. åˆå§‹åŒ–åº“å­˜
    if product.Stock > 0 {
        if err := s.inventory.UpdateStock(ctx, product.ID, product.Stock); err != nil {
            fmt.Printf("åˆå§‹åŒ–åº“å­˜å¤±è´¥: %v\n", err)
        }
    }

    // 5. ç¼“å­˜å•†å“ä¿¡æ¯
    cacheKey := fmt.Sprintf("product:%d", product.ID)
    if err := s.cache.Set(ctx, cacheKey, product, 30*time.Minute); err != nil {
        fmt.Printf("ç¼“å­˜å•†å“ä¿¡æ¯å¤±è´¥: %v\n", err)
    }

    return product, nil
}

// è·å–å•†å“ - å±•ç¤ºç¼“å­˜ç­–ç•¥
func (s *ProductService) GetProduct(ctx context.Context, id int64, userID int64) (*ProductDetail, error) {
    // 1. å°è¯•ä»ç¼“å­˜è·å–
    cacheKey := fmt.Sprintf("product:%d", id)
    if product, err := s.cache.Get(ctx, cacheKey); err == nil {
        return s.buildProductDetail(ctx, product, userID)
    }

    // 2. ä»æ•°æ®åº“è·å–
    product, err := s.repo.GetByID(ctx, id)
    if err != nil {
        return nil, fmt.Errorf("è·å–å•†å“å¤±è´¥: %w", err)
    }

    // 3. æ›´æ–°ç¼“å­˜
    if err := s.cache.Set(ctx, cacheKey, product, 30*time.Minute); err != nil {
        fmt.Printf("æ›´æ–°ç¼“å­˜å¤±è´¥: %v\n", err)
    }

    return s.buildProductDetail(ctx, product, userID)
}

// æ„å»ºå•†å“è¯¦æƒ… - å±•ç¤ºæ¥å£ç»„åˆä½¿ç”¨
func (s *ProductService) buildProductDetail(ctx context.Context, product *Product, userID int64) (*ProductDetail, error) {
    detail := &ProductDetail{
        Product: product,
    }

    // è·å–ä»·æ ¼ä¿¡æ¯
    if priceInfo, err := s.priceCalc.CalculatePrice(ctx, product.ID, userID); err == nil {
        detail.PriceInfo = priceInfo
    }

    // æ£€æŸ¥åº“å­˜
    if available, err := s.inventory.CheckStock(ctx, product.ID, 1); err == nil {
        detail.Available = available
    }

    return detail, nil
}

// æœç´¢å•†å“ - å±•ç¤ºæœç´¢å¼•æ“é›†æˆ
func (s *ProductService) SearchProducts(ctx context.Context, query *SearchQuery) (*SearchResult, error) {
    // ä½¿ç”¨æœç´¢å¼•æ“
    result, err := s.searchEngine.Search(ctx, query)
    if err != nil {
        // æœç´¢å¼•æ“å¤±è´¥ï¼Œé™çº§åˆ°æ•°æ®åº“æŸ¥è¯¢
        fmt.Printf("æœç´¢å¼•æ“æŸ¥è¯¢å¤±è´¥ï¼Œé™çº§åˆ°æ•°æ®åº“: %v\n", err)
        return s.fallbackSearch(ctx, query)
    }

    return result, nil
}

// é™çº§æœç´¢
func (s *ProductService) fallbackSearch(ctx context.Context, query *SearchQuery) (*SearchResult, error) {
    filter := &ProductFilter{
        Keyword:  &query.Keyword,
        Page:     query.Page,
        PageSize: query.PageSize,
    }

    products, err := s.repo.List(ctx, filter)
    if err != nil {
        return nil, fmt.Errorf("æ•°æ®åº“æŸ¥è¯¢å¤±è´¥: %w", err)
    }

    return &SearchResult{
        Products: products,
        Total:    int64(len(products)),
        Page:     query.Page,
        PageSize: query.PageSize,
        Took:     0,
    }, nil
}

func (s *ProductService) validateProduct(product *Product) error {
    if product.Name == "" {
        return fmt.Errorf("å•†å“åç§°ä¸èƒ½ä¸ºç©º")
    }
    if product.Price < 0 {
        return fmt.Errorf("å•†å“ä»·æ ¼ä¸èƒ½ä¸ºè´Ÿæ•°")
    }
    if product.Stock < 0 {
        return fmt.Errorf("å•†å“åº“å­˜ä¸èƒ½ä¸ºè´Ÿæ•°")
    }
    return nil
}

type ProductDetail struct {
    *Product
    PriceInfo *PriceInfo `json:"price_info,omitempty"`
    Available bool       `json:"available"`
}
```

### æ¡ˆä¾‹2ï¼šè®¢å•å¤„ç†çš„æ¥å£è®¾è®¡

```go
// æ¥è‡ª mall-go/internal/service/order_service.go
package service

import (
    "context"
    "fmt"
    "time"
)

// è®¢å•å¤„ç†ç›¸å…³æ¥å£
type OrderProcessor interface {
    ProcessOrder(ctx context.Context, order *Order) error
    CancelOrder(ctx context.Context, orderID string) error
    RefundOrder(ctx context.Context, orderID string, reason string) error
}

type PaymentProcessor interface {
    ProcessPayment(ctx context.Context, payment *PaymentRequest) (*PaymentResponse, error)
    RefundPayment(ctx context.Context, transactionID string, amount float64) error
    QueryPaymentStatus(ctx context.Context, transactionID string) (*PaymentStatus, error)
}

type ShippingService interface {
    CreateShipment(ctx context.Context, order *Order) (*Shipment, error)
    TrackShipment(ctx context.Context, trackingNumber string) (*TrackingInfo, error)
    CancelShipment(ctx context.Context, shipmentID string) error
}

type NotificationSender interface {
    SendOrderConfirmation(ctx context.Context, order *Order) error
    SendPaymentNotification(ctx context.Context, payment *PaymentResponse) error
    SendShippingNotification(ctx context.Context, shipment *Shipment) error
}

// äº‹ä»¶å‘å¸ƒæ¥å£
type EventPublisher interface {
    PublishOrderCreated(ctx context.Context, order *Order) error
    PublishOrderPaid(ctx context.Context, order *Order) error
    PublishOrderShipped(ctx context.Context, order *Order) error
    PublishOrderCompleted(ctx context.Context, order *Order) error
}

// è®¢å•æœåŠ¡å®ç° - å±•ç¤ºå¤æ‚ä¸šåŠ¡æµç¨‹çš„æ¥å£åä½œ
type OrderService struct {
    orderRepo    OrderRepository
    productSvc   *ProductService
    paymentProc  PaymentProcessor
    shippingSvc  ShippingService
    notifier     NotificationSender
    eventPub     EventPublisher
    inventory    InventoryManager
}

func NewOrderService(
    orderRepo OrderRepository,
    productSvc *ProductService,
    paymentProc PaymentProcessor,
    shippingSvc ShippingService,
    notifier NotificationSender,
    eventPub EventPublisher,
    inventory InventoryManager,
) *OrderService {
    return &OrderService{
        orderRepo:   orderRepo,
        productSvc:  productSvc,
        paymentProc: paymentProc,
        shippingSvc: shippingSvc,
        notifier:    notifier,
        eventPub:    eventPub,
        inventory:   inventory,
    }
}

// åˆ›å»ºè®¢å• - å±•ç¤ºäº‹åŠ¡æ€§æ“ä½œçš„æ¥å£è®¾è®¡
func (s *OrderService) CreateOrder(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    // 1. éªŒè¯å•†å“å’Œåº“å­˜
    var totalAmount float64
    var reservations []*Reservation

    for _, item := range req.Items {
        // æ£€æŸ¥å•†å“å­˜åœ¨æ€§
        product, err := s.productSvc.GetProduct(ctx, item.ProductID, req.UserID)
        if err != nil {
            return nil, fmt.Errorf("å•†å“ä¸å­˜åœ¨: %w", err)
        }

        // æ£€æŸ¥åº“å­˜
        available, err := s.inventory.CheckStock(ctx, item.ProductID, item.Quantity)
        if err != nil || !available {
            return nil, fmt.Errorf("å•†å“åº“å­˜ä¸è¶³: å•†å“ID %d", item.ProductID)
        }

        // é¢„ç•™åº“å­˜
        reservation, err := s.inventory.ReserveStock(ctx, item.ProductID, item.Quantity)
        if err != nil {
            // é‡Šæ”¾å·²é¢„ç•™çš„åº“å­˜
            s.releaseReservations(ctx, reservations)
            return nil, fmt.Errorf("é¢„ç•™åº“å­˜å¤±è´¥: %w", err)
        }
        reservations = append(reservations, reservation)

        totalAmount += product.Price * float64(item.Quantity)
    }

    // 2. åˆ›å»ºè®¢å•
    order := &Order{
        ID:          generateOrderID(),
        UserID:      req.UserID,
        Items:       req.Items,
        TotalAmount: totalAmount,
        Status:      "pending",
        CreatedAt:   time.Now(),
    }

    if err := s.orderRepo.Create(ctx, order); err != nil {
        s.releaseReservations(ctx, reservations)
        return nil, fmt.Errorf("åˆ›å»ºè®¢å•å¤±è´¥: %w", err)
    }

    // 3. å‘é€è®¢å•ç¡®è®¤é€šçŸ¥
    if err := s.notifier.SendOrderConfirmation(ctx, order); err != nil {
        fmt.Printf("å‘é€è®¢å•ç¡®è®¤é€šçŸ¥å¤±è´¥: %v\n", err)
    }

    // 4. å‘å¸ƒè®¢å•åˆ›å»ºäº‹ä»¶
    if err := s.eventPub.PublishOrderCreated(ctx, order); err != nil {
        fmt.Printf("å‘å¸ƒè®¢å•åˆ›å»ºäº‹ä»¶å¤±è´¥: %v\n", err)
    }

    return order, nil
}

// å¤„ç†æ”¯ä»˜ - å±•ç¤ºçŠ¶æ€æœºæ¨¡å¼çš„æ¥å£è®¾è®¡
func (s *OrderService) ProcessPayment(ctx context.Context, orderID string, paymentMethod string) error {
    // 1. è·å–è®¢å•
    order, err := s.orderRepo.GetByID(ctx, orderID)
    if err != nil {
        return fmt.Errorf("è·å–è®¢å•å¤±è´¥: %w", err)
    }

    if order.Status != "pending" {
        return fmt.Errorf("è®¢å•çŠ¶æ€ä¸æ­£ç¡®: %s", order.Status)
    }

    // 2. å¤„ç†æ”¯ä»˜
    paymentReq := &PaymentRequest{
        OrderID:       orderID,
        Amount:        order.TotalAmount,
        PaymentMethod: paymentMethod,
        UserID:        order.UserID,
    }

    paymentResp, err := s.paymentProc.ProcessPayment(ctx, paymentReq)
    if err != nil {
        return fmt.Errorf("æ”¯ä»˜å¤„ç†å¤±è´¥: %w", err)
    }

    // 3. æ›´æ–°è®¢å•çŠ¶æ€
    if paymentResp.Status == "success" {
        order.Status = "paid"
        order.PaymentID = paymentResp.TransactionID
        order.PaidAt = time.Now()

        if err := s.orderRepo.Update(ctx, order); err != nil {
            return fmt.Errorf("æ›´æ–°è®¢å•çŠ¶æ€å¤±è´¥: %w", err)
        }

        // 4. å‘é€æ”¯ä»˜é€šçŸ¥
        if err := s.notifier.SendPaymentNotification(ctx, paymentResp); err != nil {
            fmt.Printf("å‘é€æ”¯ä»˜é€šçŸ¥å¤±è´¥: %v\n", err)
        }

        // 5. å‘å¸ƒæ”¯ä»˜æˆåŠŸäº‹ä»¶
        if err := s.eventPub.PublishOrderPaid(ctx, order); err != nil {
            fmt.Printf("å‘å¸ƒæ”¯ä»˜æˆåŠŸäº‹ä»¶å¤±è´¥: %v\n", err)
        }

        // 6. è‡ªåŠ¨åˆ›å»ºå‘è´§å•
        go s.createShipmentAsync(context.Background(), order)

    } else {
        order.Status = "payment_failed"
        s.orderRepo.Update(ctx, order)
    }

    return nil
}

// å¼‚æ­¥åˆ›å»ºå‘è´§å•
func (s *OrderService) createShipmentAsync(ctx context.Context, order *Order) {
    shipment, err := s.shippingSvc.CreateShipment(ctx, order)
    if err != nil {
        fmt.Printf("åˆ›å»ºå‘è´§å•å¤±è´¥: %v\n", err)
        return
    }

    // æ›´æ–°è®¢å•çŠ¶æ€
    order.Status = "shipped"
    order.ShippingID = shipment.ID
    order.ShippedAt = time.Now()

    if err := s.orderRepo.Update(ctx, order); err != nil {
        fmt.Printf("æ›´æ–°è®¢å•å‘è´§çŠ¶æ€å¤±è´¥: %v\n", err)
        return
    }

    // å‘é€å‘è´§é€šçŸ¥
    if err := s.notifier.SendShippingNotification(ctx, shipment); err != nil {
        fmt.Printf("å‘é€å‘è´§é€šçŸ¥å¤±è´¥: %v\n", err)
    }

    // å‘å¸ƒå‘è´§äº‹ä»¶
    if err := s.eventPub.PublishOrderShipped(ctx, order); err != nil {
        fmt.Printf("å‘å¸ƒå‘è´§äº‹ä»¶å¤±è´¥: %v\n", err)
    }
}

func (s *OrderService) releaseReservations(ctx context.Context, reservations []*Reservation) {
    for _, reservation := range reservations {
        if err := s.inventory.ReleaseStock(ctx, reservation.ID); err != nil {
            fmt.Printf("é‡Šæ”¾åº“å­˜é¢„ç•™å¤±è´¥: %v\n", err)
        }
    }
}

func generateOrderID() string {
    return fmt.Sprintf("ORDER_%d", time.Now().UnixNano())
}

// ç›¸å…³æ•°æ®ç»“æ„
type Order struct {
    ID          string       `json:"id"`
    UserID      int64        `json:"user_id"`
    Items       []*OrderItem `json:"items"`
    TotalAmount float64      `json:"total_amount"`
    Status      string       `json:"status"`
    PaymentID   string       `json:"payment_id,omitempty"`
    ShippingID  string       `json:"shipping_id,omitempty"`
    CreatedAt   time.Time    `json:"created_at"`
    PaidAt      time.Time    `json:"paid_at,omitempty"`
    ShippedAt   time.Time    `json:"shipped_at,omitempty"`
}

type OrderItem struct {
    ProductID int64 `json:"product_id"`
    Quantity  int   `json:"quantity"`
    Price     float64 `json:"price"`
}

type CreateOrderRequest struct {
    UserID int64        `json:"user_id"`
    Items  []*OrderItem `json:"items"`
}

type PaymentRequest struct {
    OrderID       string  `json:"order_id"`
    Amount        float64 `json:"amount"`
    PaymentMethod string  `json:"payment_method"`
    UserID        int64   `json:"user_id"`
}

type PaymentResponse struct {
    TransactionID string  `json:"transaction_id"`
    Status        string  `json:"status"`
    Amount        float64 `json:"amount"`
    Message       string  `json:"message"`
}

type PaymentStatus struct {
    TransactionID string `json:"transaction_id"`
    Status        string `json:"status"`
    Amount        float64 `json:"amount"`
}

type Shipment struct {
    ID             string `json:"id"`
    OrderID        string `json:"order_id"`
    TrackingNumber string `json:"tracking_number"`
    Carrier        string `json:"carrier"`
    Status         string `json:"status"`
}

type TrackingInfo struct {
    TrackingNumber string           `json:"tracking_number"`
    Status         string           `json:"status"`
    Events         []*TrackingEvent `json:"events"`
}

type TrackingEvent struct {
    Time        time.Time `json:"time"`
    Location    string    `json:"location"`
    Description string    `json:"description"`
}

type OrderRepository interface {
    Create(ctx context.Context, order *Order) error
    GetByID(ctx context.Context, id string) (*Order, error)
    Update(ctx context.Context, order *Order) error
    GetByUserID(ctx context.Context, userID int64) ([]*Order, error)
}
```

---

## ğŸ¯ é¢è¯•å¸¸è€ƒç‚¹

Goè¯­è¨€æ¥å£æ˜¯é¢è¯•ä¸­çš„é«˜é¢‘è€ƒç‚¹ï¼Œè®©æˆ‘ä»¬æ·±å…¥åˆ†æå¸¸è§é—®é¢˜å’Œæ ‡å‡†ç­”æ¡ˆã€‚

### 1. æ¥å£çš„åº•å±‚å®ç°åŸç†

**é¢è¯•é¢˜ï¼šè¯·è§£é‡ŠGoè¯­è¨€æ¥å£çš„åº•å±‚å®ç°åŸç†ï¼ŒåŒ…æ‹¬ifaceå’Œefaceçš„åŒºåˆ«ã€‚**

```go
// æ¥è‡ª mall-go/docs/interview/interface_internals.go
package interview

import (
    "fmt"
    "unsafe"
)

/*
Goæ¥å£åº•å±‚å®ç°åŸç†è¯¦è§£ï¼š

1. eface (empty interface)
   - ç”¨äºè¡¨ç¤ºç©ºæ¥å£ interface{}
   - ç»“æ„ï¼štype + data

2. iface (interface with methods)
   - ç”¨äºè¡¨ç¤ºæœ‰æ–¹æ³•çš„æ¥å£
   - ç»“æ„ï¼štab + data

3. itab (interface table)
   - åŒ…å«æ¥å£ç±»å‹ä¿¡æ¯å’Œæ–¹æ³•è¡¨
   - ç”¨äºåŠ¨æ€åˆ†å‘æ–¹æ³•è°ƒç”¨
*/

// æ¨¡æ‹ŸGoè¿è¡Œæ—¶çš„æ¥å£ç»“æ„
type eface struct {
    _type *_type
    data  unsafe.Pointer
}

type iface struct {
    tab  *itab
    data unsafe.Pointer
}

type itab struct {
    inter *interfacetype
    _type *_type
    hash  uint32
    _     [4]byte
    fun   [1]uintptr // æ–¹æ³•è¡¨
}

type _type struct {
    size       uintptr
    ptrdata    uintptr
    hash       uint32
    tflag      uint8
    align      uint8
    fieldAlign uint8
    kind       uint8
    equal      func(unsafe.Pointer, unsafe.Pointer) bool
    gcdata     *byte
    str        int32
    ptrToThis  int32
}

type interfacetype struct {
    typ     _type
    pkgpath string
    mhdr    []imethod
}

type imethod struct {
    name int32
    ityp int32
}

// æ¼”ç¤ºæ¥å£èµ‹å€¼çš„å†…éƒ¨è¿‡ç¨‹
func DemonstrateInterfaceInternals() {
    fmt.Println("=== Goæ¥å£åº•å±‚å®ç°æ¼”ç¤º ===")

    // 1. ç©ºæ¥å£èµ‹å€¼
    fmt.Println("1. ç©ºæ¥å£ (eface) æ¼”ç¤º:")
    var empty interface{}

    // èµ‹å€¼æ•´æ•°
    empty = 42
    fmt.Printf("empty = 42: type=%T, value=%v\n", empty, empty)

    // èµ‹å€¼å­—ç¬¦ä¸²
    empty = "hello"
    fmt.Printf("empty = \"hello\": type=%T, value=%v\n", empty, empty)

    // èµ‹å€¼ç»“æ„ä½“
    type Person struct {
        Name string
        Age  int
    }
    empty = Person{Name: "å¼ ä¸‰", Age: 25}
    fmt.Printf("empty = Person{}: type=%T, value=%v\n", empty, empty)

    // 2. æœ‰æ–¹æ³•æ¥å£èµ‹å€¼
    fmt.Println("\n2. æœ‰æ–¹æ³•æ¥å£ (iface) æ¼”ç¤º:")

    type Speaker interface {
        Speak() string
    }

    type Dog struct {
        Name string
    }

    func (d Dog) Speak() string {
        return fmt.Sprintf("%s: æ±ªæ±ª!", d.Name)
    }

    type Cat struct {
        Name string
    }

    func (c Cat) Speak() string {
        return fmt.Sprintf("%s: å–µå–µ!", c.Name)
    }

    var speaker Speaker

    // èµ‹å€¼Dog
    speaker = Dog{Name: "æ—ºè´¢"}
    fmt.Printf("speaker = Dog: %s\n", speaker.Speak())

    // èµ‹å€¼Cat
    speaker = Cat{Name: "å’ªå’ª"}
    fmt.Printf("speaker = Cat: %s\n", speaker.Speak())

    // 3. æ¥å£æ–¹æ³•è°ƒç”¨çš„åŠ¨æ€åˆ†å‘
    fmt.Println("\n3. åŠ¨æ€åˆ†å‘æ¼”ç¤º:")
    animals := []Speaker{
        Dog{Name: "å°é»„"},
        Cat{Name: "å°ç™½"},
        Dog{Name: "å¤§é»‘"},
    }

    for i, animal := range animals {
        fmt.Printf("åŠ¨ç‰©%d: %s\n", i+1, animal.Speak())
    }
}

// æ ‡å‡†ç­”æ¡ˆæ€»ç»“
func InterfaceInternalsAnswer() {
    fmt.Println(`
Goæ¥å£åº•å±‚å®ç°åŸç†æ ‡å‡†ç­”æ¡ˆï¼š

1. æ•°æ®ç»“æ„ï¼š
   - efaceï¼šç”¨äºç©ºæ¥å£ï¼ŒåŒ…å« _type å’Œ data
   - ifaceï¼šç”¨äºæœ‰æ–¹æ³•æ¥å£ï¼ŒåŒ…å« itab å’Œ data
   - itabï¼šæ¥å£è¡¨ï¼ŒåŒ…å«ç±»å‹ä¿¡æ¯å’Œæ–¹æ³•è¡¨

2. æ–¹æ³•åˆ†å‘ï¼š
   - ç¼–è¯‘æ—¶ç¡®å®šæ–¹æ³•åœ¨itabä¸­çš„ä½ç½®
   - è¿è¡Œæ—¶é€šè¿‡itab.fun[index]è°ƒç”¨å…·ä½“æ–¹æ³•
   - å®ç°äº†å¤šæ€å’ŒåŠ¨æ€åˆ†å‘

3. æ€§èƒ½è€ƒè™‘ï¼š
   - æ¥å£è°ƒç”¨æ¯”ç›´æ¥è°ƒç”¨æ…¢ï¼ˆéœ€è¦æŸ¥è¡¨ï¼‰
   - ç©ºæ¥å£ç±»å‹æ–­è¨€éœ€è¦ç±»å‹æ¯”è¾ƒ
   - æ¥å£èµ‹å€¼å¯èƒ½æ¶‰åŠå†…å­˜åˆ†é…

4. ä¸å…¶ä»–è¯­è¨€å¯¹æ¯”ï¼š
   - Javaï¼šåŸºäºè™šå‡½æ•°è¡¨ï¼Œéœ€è¦æ˜¾å¼å®ç°
   - Pythonï¼šåŸºäºduck typingï¼Œè¿è¡Œæ—¶æ£€æŸ¥
   - Goï¼šç¼–è¯‘æ—¶æ£€æŸ¥+è¿è¡Œæ—¶åˆ†å‘ï¼Œéšå¼å®ç°
    `)
}
```

### 2. æ¥å£ä¸nilçš„å…³ç³»

**é¢è¯•é¢˜ï¼šè§£é‡ŠGoè¯­è¨€ä¸­æ¥å£ä¸nilçš„å…³ç³»ï¼Œä¸ºä»€ä¹ˆæœ‰æ—¶å€™æ¥å£ä¸ç­‰äºnilï¼Ÿ**

```go
// æ¥å£nilåˆ¤æ–­çš„é™·é˜±
func DemonstrateInterfaceNil() {
    fmt.Println("=== æ¥å£ä¸nilå…³ç³»æ¼”ç¤º ===")

    // 1. åŸºæœ¬nilåˆ¤æ–­
    fmt.Println("1. åŸºæœ¬nilåˆ¤æ–­:")
    var i interface{}
    fmt.Printf("var i interface{}: i == nil? %t\n", i == nil)

    // 2. æ¥å£èµ‹å€¼nilæŒ‡é’ˆçš„é™·é˜±
    fmt.Println("\n2. nilæŒ‡é’ˆé™·é˜±:")

    type MyError struct {
        msg string
    }

    func (e *MyError) Error() string {
        if e == nil {
            return "no error"
        }
        return e.msg
    }

    // å‡½æ•°è¿”å›nilæŒ‡é’ˆ
    func getError() error {
        var err *MyError = nil
        return err // è¿™é‡Œè¿”å›çš„ä¸æ˜¯nilæ¥å£ï¼
    }

    err := getError()
    fmt.Printf("err := getError(): err == nil? %t\n", err == nil)
    fmt.Printf("errçš„ç±»å‹: %T\n", err)
    fmt.Printf("errçš„å€¼: %v\n", err)

    // æ­£ç¡®çš„åšæ³•
    func getErrorCorrect() error {
        var err *MyError = nil
        if err != nil {
            return err
        }
        return nil // è¿”å›çœŸæ­£çš„nilæ¥å£
    }

    err2 := getErrorCorrect()
    fmt.Printf("err2 := getErrorCorrect(): err2 == nil? %t\n", err2 == nil)

    // 3. æ¥å£å†…éƒ¨ç»“æ„åˆ†æ
    fmt.Println("\n3. æ¥å£å†…éƒ¨ç»“æ„åˆ†æ:")

    // nilæ¥å£ï¼štype=nil, data=nil
    var nilInterface interface{}
    fmt.Printf("nilæ¥å£: %+v\n", nilInterface)

    // énilæ¥å£ï¼štype=*MyError, data=nil
    var nilPointer *MyError = nil
    var nonNilInterface interface{} = nilPointer
    fmt.Printf("énilæ¥å£(nilæŒ‡é’ˆ): %+v\n", nonNilInterface)
    fmt.Printf("ç±»å‹æ£€æŸ¥: %T\n", nonNilInterface)

    // 4. å®‰å…¨çš„nilæ£€æŸ¥æ–¹æ³•
    fmt.Println("\n4. å®‰å…¨çš„nilæ£€æŸ¥:")

    func isNil(i interface{}) bool {
        if i == nil {
            return true
        }

        // ä½¿ç”¨åå°„æ£€æŸ¥
        v := reflect.ValueOf(i)
        switch v.Kind() {
        case reflect.Ptr, reflect.Interface, reflect.Slice, reflect.Map, reflect.Chan, reflect.Func:
            return v.IsNil()
        default:
            return false
        }
    }

    fmt.Printf("isNil(nilInterface): %t\n", isNil(nilInterface))
    fmt.Printf("isNil(nonNilInterface): %t\n", isNil(nonNilInterface))
    fmt.Printf("isNil(err): %t\n", isNil(err))
}

// æ ‡å‡†ç­”æ¡ˆ
func InterfaceNilAnswer() {
    fmt.Println(`
æ¥å£ä¸nilå…³ç³»æ ‡å‡†ç­”æ¡ˆï¼š

1. æ¥å£çš„nilåˆ¤æ–­ï¼š
   - æ¥å£åŒ…å«typeå’Œdataä¸¤éƒ¨åˆ†
   - åªæœ‰å½“typeå’Œdataéƒ½ä¸ºnilæ—¶ï¼Œæ¥å£æ‰ç­‰äºnil
   - typeä¸ä¸ºnilä½†dataä¸ºnilçš„æ¥å£ä¸ç­‰äºnil

2. å¸¸è§é™·é˜±ï¼š
   - è¿”å›nilæŒ‡é’ˆç»™æ¥å£ç±»å‹
   - æ¥å£ç±»å‹çš„é›¶å€¼åˆ¤æ–­
   - ç±»å‹æ–­è¨€æ—¶çš„nilæ£€æŸ¥

3. è§£å†³æ–¹æ¡ˆï¼š
   - è¿”å›æ˜ç¡®çš„nilè€Œä¸æ˜¯nilæŒ‡é’ˆ
   - ä½¿ç”¨åå°„è¿›è¡Œå®‰å…¨çš„nilæ£€æŸ¥
   - ç†è§£æ¥å£çš„å†…éƒ¨ç»“æ„

4. æœ€ä½³å®è·µï¼š
   - å‡½æ•°è¿”å›erroræ—¶ï¼ŒæˆåŠŸæ—¶è¿”å›nilè€Œä¸æ˜¯nilæŒ‡é’ˆ
   - ä½¿ç”¨ç±»å‹æ–­è¨€å‰å…ˆæ£€æŸ¥æ¥å£æ˜¯å¦ä¸ºnil
   - é¿å…å°†nilæŒ‡é’ˆèµ‹å€¼ç»™æ¥å£ç±»å‹
    `)
}
```

### 3. æ¥å£æ–­è¨€çš„æ€§èƒ½è€ƒè™‘

**é¢è¯•é¢˜ï¼šç±»å‹æ–­è¨€å’Œç±»å‹å¼€å…³çš„æ€§èƒ½å¦‚ä½•ï¼Ÿä»€ä¹ˆæ—¶å€™ä½¿ç”¨å“ªç§æ–¹å¼ï¼Ÿ**

```go
// æ€§èƒ½æµ‹è¯•å’Œå¯¹æ¯”
func DemonstrateTypeAssertionPerformance() {
    fmt.Println("=== ç±»å‹æ–­è¨€æ€§èƒ½æ¼”ç¤º ===")

    // å‡†å¤‡æµ‹è¯•æ•°æ®
    values := []interface{}{
        "string1", "string2", "string3",
        123, 456, 789,
        12.34, 56.78, 90.12,
        true, false, true,
    }

    // 1. ç±»å‹æ–­è¨€æ–¹å¼
    fmt.Println("1. ç±»å‹æ–­è¨€æ–¹å¼:")
    start := time.Now()
    var stringCount, intCount, floatCount, boolCount int

    for i := 0; i < 1000000; i++ {
        for _, v := range values {
            if _, ok := v.(string); ok {
                stringCount++
            } else if _, ok := v.(int); ok {
                intCount++
            } else if _, ok := v.(float64); ok {
                floatCount++
            } else if _, ok := v.(bool); ok {
                boolCount++
            }
        }
    }

    duration1 := time.Since(start)
    fmt.Printf("ç±»å‹æ–­è¨€è€—æ—¶: %v\n", duration1)
    fmt.Printf("ç»Ÿè®¡: string=%d, int=%d, float=%d, bool=%d\n",
        stringCount, intCount, floatCount, boolCount)

    // 2. ç±»å‹å¼€å…³æ–¹å¼
    fmt.Println("\n2. ç±»å‹å¼€å…³æ–¹å¼:")
    start = time.Now()
    stringCount, intCount, floatCount, boolCount = 0, 0, 0, 0

    for i := 0; i < 1000000; i++ {
        for _, v := range values {
            switch v.(type) {
            case string:
                stringCount++
            case int:
                intCount++
            case float64:
                floatCount++
            case bool:
                boolCount++
            }
        }
    }

    duration2 := time.Since(start)
    fmt.Printf("ç±»å‹å¼€å…³è€—æ—¶: %v\n", duration2)
    fmt.Printf("ç»Ÿè®¡: string=%d, int=%d, float=%d, bool=%d\n",
        stringCount, intCount, floatCount, boolCount)

    // 3. åå°„æ–¹å¼
    fmt.Println("\n3. åå°„æ–¹å¼:")
    start = time.Now()
    stringCount, intCount, floatCount, boolCount = 0, 0, 0, 0

    for i := 0; i < 1000000; i++ {
        for _, v := range values {
            t := reflect.TypeOf(v)
            switch t.Kind() {
            case reflect.String:
                stringCount++
            case reflect.Int:
                intCount++
            case reflect.Float64:
                floatCount++
            case reflect.Bool:
                boolCount++
            }
        }
    }

    duration3 := time.Since(start)
    fmt.Printf("åå°„æ–¹å¼è€—æ—¶: %v\n", duration3)
    fmt.Printf("ç»Ÿè®¡: string=%d, int=%d, float=%d, bool=%d\n",
        stringCount, intCount, floatCount, boolCount)

    // æ€§èƒ½å¯¹æ¯”
    fmt.Printf("\næ€§èƒ½å¯¹æ¯”:\n")
    fmt.Printf("ç±»å‹æ–­è¨€: %v (åŸºå‡†)\n", duration1)
    fmt.Printf("ç±»å‹å¼€å…³: %v (%.2fx)\n", duration2, float64(duration2)/float64(duration1))
    fmt.Printf("åå°„æ–¹å¼: %v (%.2fx)\n", duration3, float64(duration3)/float64(duration1))
}

// æœ€ä½³å®è·µç¤ºä¾‹
func TypeAssertionBestPractices() {
    fmt.Println("\n=== ç±»å‹æ–­è¨€æœ€ä½³å®è·µ ===")

    // 1. å®‰å…¨çš„ç±»å‹æ–­è¨€
    fmt.Println("1. å®‰å…¨çš„ç±»å‹æ–­è¨€:")

    var value interface{} = "hello world"

    // âŒ ä¸å®‰å…¨çš„æ–­è¨€ï¼ˆå¯èƒ½panicï¼‰
    // str := value.(string)

    // âœ… å®‰å…¨çš„æ–­è¨€
    if str, ok := value.(string); ok {
        fmt.Printf("å®‰å…¨æ–­è¨€æˆåŠŸ: %s\n", str)
    } else {
        fmt.Printf("æ–­è¨€å¤±è´¥ï¼Œä¸æ˜¯stringç±»å‹\n")
    }

    // 2. ç±»å‹å¼€å…³çš„ä¼˜é›…ä½¿ç”¨
    fmt.Println("\n2. ç±»å‹å¼€å…³çš„ä¼˜é›…ä½¿ç”¨:")

    func processValue(v interface{}) string {
        switch val := v.(type) {
        case string:
            return fmt.Sprintf("å­—ç¬¦ä¸²: %s (é•¿åº¦: %d)", val, len(val))
        case int:
            return fmt.Sprintf("æ•´æ•°: %d (äºŒè¿›åˆ¶: %b)", val, val)
        case float64:
            return fmt.Sprintf("æµ®ç‚¹æ•°: %.2f", val)
        case bool:
            return fmt.Sprintf("å¸ƒå°”å€¼: %t", val)
        case nil:
            return "ç©ºå€¼"
        default:
            return fmt.Sprintf("æœªçŸ¥ç±»å‹: %T", val)
        }
    }

    testValues := []interface{}{
        "Goè¯­è¨€",
        42,
        3.14159,
        true,
        nil,
        []int{1, 2, 3},
    }

    for _, v := range testValues {
        fmt.Printf("å¤„ç†ç»“æœ: %s\n", processValue(v))
    }

    // 3. æ³›å‹æ—¶ä»£çš„ç±»å‹æ–­è¨€
    fmt.Println("\n3. æ³›å‹æ—¶ä»£çš„ç±»å‹æ–­è¨€:")

    // Go 1.18+ æ³›å‹ç‰ˆæœ¬
    func SafeCast[T any](value interface{}) (T, bool) {
        if v, ok := value.(T); ok {
            return v, true
        }
        var zero T
        return zero, false
    }

    // ä½¿ç”¨æ³›å‹ç‰ˆæœ¬
    if str, ok := SafeCast[string](value); ok {
        fmt.Printf("æ³›å‹æ–­è¨€æˆåŠŸ: %s\n", str)
    }

    if num, ok := SafeCast[int](42); ok {
        fmt.Printf("æ³›å‹æ–­è¨€æˆåŠŸ: %d\n", num)
    }
}

// æ ‡å‡†ç­”æ¡ˆ
func TypeAssertionPerformanceAnswer() {
    fmt.Println(`
ç±»å‹æ–­è¨€æ€§èƒ½æ ‡å‡†ç­”æ¡ˆï¼š

1. æ€§èƒ½æ’åºï¼ˆä»å¿«åˆ°æ…¢ï¼‰ï¼š
   - ç±»å‹å¼€å…³ (type switch) - æœ€å¿«
   - ç±»å‹æ–­è¨€ (type assertion) - ä¸­ç­‰
   - åå°„ (reflection) - æœ€æ…¢

2. é€‰æ‹©åŸåˆ™ï¼š
   - å¤šä¸ªç±»å‹åˆ¤æ–­ï¼šä½¿ç”¨ç±»å‹å¼€å…³
   - å•ä¸ªç±»å‹åˆ¤æ–­ï¼šä½¿ç”¨ç±»å‹æ–­è¨€
   - å¤æ‚ç±»å‹æ“ä½œï¼šè€ƒè™‘åå°„
   - æ€§èƒ½æ•æ„Ÿåœºæ™¯ï¼šé¿å…åå°„

3. æœ€ä½³å®è·µï¼š
   - æ€»æ˜¯ä½¿ç”¨å®‰å…¨çš„ç±»å‹æ–­è¨€ (value, ok := v.(Type))
   - ç±»å‹å¼€å…³ä¸­ä½¿ç”¨å˜é‡æ¥æ”¶å€¼
   - é¿å…åœ¨çƒ­ç‚¹ä»£ç ä¸­ä½¿ç”¨åå°„
   - è€ƒè™‘ä½¿ç”¨æ³›å‹å‡å°‘ç±»å‹æ–­è¨€

4. ä¸å…¶ä»–è¯­è¨€å¯¹æ¯”ï¼š
   - Javaï¼šinstanceof + å¼ºåˆ¶è½¬æ¢
   - Pythonï¼šisinstance() + é¸­å­ç±»å‹
   - Goï¼šç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥ + è¿è¡Œæ—¶æ–­è¨€
    `)
}
```

---

## âš ï¸ è¸©å‘æé†’

åœ¨Goæ¥å£ç¼–ç¨‹ä¸­ï¼Œæœ‰ä¸€äº›å¸¸è§çš„é™·é˜±éœ€è¦ç‰¹åˆ«æ³¨æ„ã€‚

### 1. æ¥å£nilåˆ¤æ–­é™·é˜±

```go
// æ¥è‡ª mall-go/docs/pitfalls/interface_pitfalls.go
package pitfalls

import (
    "fmt"
    "reflect"
)

// é™·é˜±1ï¼šæ¥å£nilåˆ¤æ–­
func PitfallInterfaceNil() {
    fmt.Println("=== é™·é˜±1ï¼šæ¥å£nilåˆ¤æ–­ ===")

    // âŒ é”™è¯¯ç¤ºä¾‹
    type MyError struct {
        Code    int
        Message string
    }

    func (e *MyError) Error() string {
        return fmt.Sprintf("é”™è¯¯%d: %s", e.Code, e.Message)
    }

    // è¿™ä¸ªå‡½æ•°æœ‰é—®é¢˜ï¼
    func badFunction() error {
        var err *MyError // nilæŒ‡é’ˆ
        // ä¸€äº›é€»è¾‘...
        if someCondition := false; someCondition {
            err = &MyError{Code: 500, Message: "æœåŠ¡å™¨é”™è¯¯"}
        }
        return err // è¿”å›nilæŒ‡é’ˆï¼Œä½†æ¥å£ä¸ä¸ºnilï¼
    }

    err := badFunction()
    fmt.Printf("err == nil? %t\n", err == nil) // falseï¼
    fmt.Printf("errçš„ç±»å‹: %T\n", err)
    fmt.Printf("errçš„å€¼: %v\n", err)

    // è¿™ä¼šå¯¼è‡´é—®é¢˜
    if err != nil {
        fmt.Printf("å‘ç”Ÿé”™è¯¯: %v\n", err) // ä¼šæ‰§è¡Œï¼Œä½†å®é™…æ²¡æœ‰é”™è¯¯
    }

    // âœ… æ­£ç¡®ç¤ºä¾‹
    func goodFunction() error {
        var err *MyError
        // ä¸€äº›é€»è¾‘...
        if someCondition := false; someCondition {
            err = &MyError{Code: 500, Message: "æœåŠ¡å™¨é”™è¯¯"}
        }

        if err != nil {
            return err
        }
        return nil // è¿”å›çœŸæ­£çš„nilæ¥å£
    }

    err2 := goodFunction()
    fmt.Printf("err2 == nil? %t\n", err2 == nil) // true

    // è§£å†³æ–¹æ¡ˆï¼šå®‰å…¨çš„nilæ£€æŸ¥
    func isReallyNil(i interface{}) bool {
        if i == nil {
            return true
        }

        v := reflect.ValueOf(i)
        switch v.Kind() {
        case reflect.Ptr, reflect.Interface, reflect.Slice, reflect.Map, reflect.Chan, reflect.Func:
            return v.IsNil()
        default:
            return false
        }
    }

    fmt.Printf("isReallyNil(err): %t\n", isReallyNil(err))
    fmt.Printf("isReallyNil(err2): %t\n", isReallyNil(err2))
}

// é™·é˜±2ï¼šç©ºæ¥å£æ»¥ç”¨
func PitfallEmptyInterfaceAbuse() {
    fmt.Println("\n=== é™·é˜±2ï¼šç©ºæ¥å£æ»¥ç”¨ ===")

    // âŒ é”™è¯¯ç¤ºä¾‹ï¼šè¿‡åº¦ä½¿ç”¨ç©ºæ¥å£
    type BadConfig struct {
        Settings map[string]interface{} // ç±»å‹ä¸æ˜ç¡®
    }

    func (c *BadConfig) Get(key string) interface{} {
        return c.Settings[key] // è¿”å›ç±»å‹ä¸æ˜ç¡®
    }

    func (c *BadConfig) Set(key string, value interface{}) {
        c.Settings[key] = value // å¯ä»¥è®¾ç½®ä»»ä½•ç±»å‹
    }

    badConfig := &BadConfig{
        Settings: make(map[string]interface{}),
    }

    badConfig.Set("port", 8080)
    badConfig.Set("host", "localhost")
    badConfig.Set("debug", true)
    badConfig.Set("timeout", "30s") // åº”è¯¥æ˜¯time.Durationï¼Œä½†è®¾ç½®æˆäº†å­—ç¬¦ä¸²

    // ä½¿ç”¨æ—¶éœ€è¦å¤§é‡ç±»å‹æ–­è¨€ï¼Œå®¹æ˜“å‡ºé”™
    if port, ok := badConfig.Get("port").(int); ok {
        fmt.Printf("ç«¯å£: %d\n", port)
    }

    // è¿™é‡Œä¼šå‡ºé”™ï¼Œå› ä¸ºtimeoutæ˜¯å­—ç¬¦ä¸²è€Œä¸æ˜¯int
    if timeout, ok := badConfig.Get("timeout").(int); ok {
        fmt.Printf("è¶…æ—¶: %d\n", timeout)
    } else {
        fmt.Printf("è¶…æ—¶ç±»å‹é”™è¯¯: %T\n", badConfig.Get("timeout"))
    }

    // âœ… æ­£ç¡®ç¤ºä¾‹ï¼šä½¿ç”¨å…·ä½“ç±»å‹
    type GoodConfig struct {
        Port    int           `json:"port"`
        Host    string        `json:"host"`
        Debug   bool          `json:"debug"`
        Timeout time.Duration `json:"timeout"`
    }

    func (c *GoodConfig) GetPort() int {
        return c.Port
    }

    func (c *GoodConfig) SetPort(port int) {
        c.Port = port
    }

    goodConfig := &GoodConfig{
        Port:    8080,
        Host:    "localhost",
        Debug:   true,
        Timeout: 30 * time.Second,
    }

    fmt.Printf("å¥½çš„é…ç½® - ç«¯å£: %d, ä¸»æœº: %s\n", goodConfig.Port, goodConfig.Host)

    // æ›´å¥½çš„æ–¹æ¡ˆï¼šä½¿ç”¨æ³›å‹ï¼ˆGo 1.18+ï¼‰
    type TypedConfig[T any] struct {
        value T
    }

    func NewTypedConfig[T any](value T) *TypedConfig[T] {
        return &TypedConfig[T]{value: value}
    }

    func (c *TypedConfig[T]) Get() T {
        return c.value
    }

    func (c *TypedConfig[T]) Set(value T) {
        c.value = value
    }

    portConfig := NewTypedConfig(8080)
    fmt.Printf("ç±»å‹å®‰å…¨é…ç½® - ç«¯å£: %d\n", portConfig.Get())
}

// é™·é˜±3ï¼šæ¥å£è®¾è®¡è¿‡åº¦æŠ½è±¡
func PitfallOverAbstraction() {
    fmt.Println("\n=== é™·é˜±3ï¼šæ¥å£è®¾è®¡è¿‡åº¦æŠ½è±¡ ===")

    // âŒ é”™è¯¯ç¤ºä¾‹ï¼šè¿‡åº¦æŠ½è±¡çš„æ¥å£
    type BadDataProcessor interface {
        Process(data interface{}) interface{}
        Transform(data interface{}, rules interface{}) interface{}
        Validate(data interface{}, schema interface{}) (bool, error)
        Serialize(data interface{}, format string) ([]byte, error)
        Deserialize(data []byte, format string) (interface{}, error)
        Cache(key string, data interface{}, ttl time.Duration) error
        GetFromCache(key string) (interface{}, error)
        Log(level string, message string, data interface{})
        Metrics(name string, value interface{})
        Notify(event string, data interface{}) error
    }

    // è¿™ä¸ªæ¥å£è¿åäº†å•ä¸€èŒè´£åŸåˆ™ï¼Œå¤ªè¿‡åºå¤§

    // âœ… æ­£ç¡®ç¤ºä¾‹ï¼šèŒè´£åˆ†ç¦»çš„æ¥å£è®¾è®¡
    type DataProcessor interface {
        Process(data []byte) ([]byte, error)
    }

    type DataValidator interface {
        Validate(data []byte) error
    }

    type DataSerializer interface {
        Serialize(data interface{}) ([]byte, error)
        Deserialize(data []byte, target interface{}) error
    }

    type CacheManager interface {
        Set(key string, value []byte, ttl time.Duration) error
        Get(key string) ([]byte, error)
        Delete(key string) error
    }

    // ç»„åˆä½¿ç”¨å¤šä¸ªå°æ¥å£
    type DataService struct {
        processor  DataProcessor
        validator  DataValidator
        serializer DataSerializer
        cache      CacheManager
    }

    func NewDataService(
        processor DataProcessor,
        validator DataValidator,
        serializer DataSerializer,
        cache CacheManager,
    ) *DataService {
        return &DataService{
            processor:  processor,
            validator:  validator,
            serializer: serializer,
            cache:      cache,
        }
    }

    func (s *DataService) ProcessData(data []byte) ([]byte, error) {
        // éªŒè¯æ•°æ®
        if err := s.validator.Validate(data); err != nil {
            return nil, fmt.Errorf("æ•°æ®éªŒè¯å¤±è´¥: %w", err)
        }

        // å¤„ç†æ•°æ®
        result, err := s.processor.Process(data)
        if err != nil {
            return nil, fmt.Errorf("æ•°æ®å¤„ç†å¤±è´¥: %w", err)
        }

        return result, nil
    }

    fmt.Println("æ¥å£èŒè´£åˆ†ç¦»è®¾è®¡å®Œæˆ")
}

// é™·é˜±4ï¼šç±»å‹æ–­è¨€æ€§èƒ½é—®é¢˜
func PitfallTypeAssertionPerformance() {
    fmt.Println("\n=== é™·é˜±4ï¼šç±»å‹æ–­è¨€æ€§èƒ½é—®é¢˜ ===")

    // âŒ é”™è¯¯ç¤ºä¾‹ï¼šé¢‘ç¹çš„ç±»å‹æ–­è¨€
    func badProcessValues(values []interface{}) {
        for _, v := range values {
            // æ¯æ¬¡éƒ½è¿›è¡Œå¤šæ¬¡ç±»å‹æ–­è¨€
            if str, ok := v.(string); ok {
                fmt.Printf("å­—ç¬¦ä¸²: %s\n", str)
            } else if num, ok := v.(int); ok {
                fmt.Printf("æ•´æ•°: %d\n", num)
            } else if f, ok := v.(float64); ok {
                fmt.Printf("æµ®ç‚¹æ•°: %.2f\n", f)
            } else if b, ok := v.(bool); ok {
                fmt.Printf("å¸ƒå°”å€¼: %t\n", b)
            }
        }
    }

    // âœ… æ­£ç¡®ç¤ºä¾‹ï¼šä½¿ç”¨ç±»å‹å¼€å…³
    func goodProcessValues(values []interface{}) {
        for _, v := range values {
            switch val := v.(type) {
            case string:
                fmt.Printf("å­—ç¬¦ä¸²: %s\n", val)
            case int:
                fmt.Printf("æ•´æ•°: %d\n", val)
            case float64:
                fmt.Printf("æµ®ç‚¹æ•°: %.2f\n", val)
            case bool:
                fmt.Printf("å¸ƒå°”å€¼: %t\n", val)
            default:
                fmt.Printf("æœªçŸ¥ç±»å‹: %T\n", val)
            }
        }
    }

    // æ›´å¥½çš„æ–¹æ¡ˆï¼šé¿å…ä½¿ç”¨interface{}
    type Value struct {
        Type  string
        Data  interface{}
    }

    func (v Value) String() string {
        switch v.Type {
        case "string":
            return v.Data.(string)
        case "int":
            return fmt.Sprintf("%d", v.Data.(int))
        case "float":
            return fmt.Sprintf("%.2f", v.Data.(float64))
        case "bool":
            return fmt.Sprintf("%t", v.Data.(bool))
        default:
            return fmt.Sprintf("%v", v.Data)
        }
    }

    // æˆ–è€…ä½¿ç”¨æ³›å‹ï¼ˆGo 1.18+ï¼‰
    type TypedValue[T any] struct {
        Value T
    }

    func (tv TypedValue[T]) String() string {
        return fmt.Sprintf("%v", tv.Value)
    }

    // æµ‹è¯•æ•°æ®
    testValues := []interface{}{"hello", 42, 3.14, true}

    fmt.Println("ä½¿ç”¨ç±»å‹å¼€å…³å¤„ç†:")
    goodProcessValues(testValues)
}

// é™·é˜±5ï¼šæ¥å£æ–¹æ³•ç­¾åè®¾è®¡é—®é¢˜
func PitfallInterfaceMethodSignature() {
    fmt.Println("\n=== é™·é˜±5ï¼šæ¥å£æ–¹æ³•ç­¾åè®¾è®¡é—®é¢˜ ===")

    // âŒ é”™è¯¯ç¤ºä¾‹ï¼šæ–¹æ³•ç­¾åä¸ä¸€è‡´
    type BadReader interface {
        Read() ([]byte, error)        // æ²¡æœ‰å‚æ•°
        ReadN(n int) ([]byte, error)  // æœ‰å‚æ•°
        ReadAll() []byte              // æ²¡æœ‰é”™è¯¯è¿”å›
    }

    type BadWriter interface {
        Write(data []byte) error      // æ²¡æœ‰è¿”å›å†™å…¥å­—èŠ‚æ•°
        WriteString(s string) (int, error) // è¿”å›å­—èŠ‚æ•°
    }

    // âœ… æ­£ç¡®ç¤ºä¾‹ï¼šä¸€è‡´çš„æ–¹æ³•ç­¾å
    type GoodReader interface {
        Read(p []byte) (n int, err error) // æ ‡å‡†io.Readerç­¾å
    }

    type GoodWriter interface {
        Write(p []byte) (n int, err error) // æ ‡å‡†io.Writerç­¾å
    }

    // ç»„åˆæ¥å£
    type ReadWriter interface {
        GoodReader
        GoodWriter
    }

    // å®ç°ç¤ºä¾‹
    type Buffer struct {
        data []byte
        pos  int
    }

    func (b *Buffer) Read(p []byte) (n int, err error) {
        if b.pos >= len(b.data) {
            return 0, fmt.Errorf("EOF")
        }

        n = copy(p, b.data[b.pos:])
        b.pos += n
        return n, nil
    }

    func (b *Buffer) Write(p []byte) (n int, err error) {
        b.data = append(b.data, p...)
        return len(p), nil
    }

    // ä½¿ç”¨æ ‡å‡†æ¥å£çš„å¥½å¤„
    func processData(rw ReadWriter) error {
        // å¯ä»¥ä¸ä»»ä½•å®ç°äº†ReadWriterçš„ç±»å‹ä¸€èµ·å·¥ä½œ
        buffer := make([]byte, 1024)
        n, err := rw.Read(buffer)
        if err != nil {
            return err
        }

        _, err = rw.Write(buffer[:n])
        return err
    }

    buf := &Buffer{data: []byte("hello world")}
    if err := processData(buf); err != nil {
        fmt.Printf("å¤„ç†æ•°æ®å¤±è´¥: %v\n", err)
    } else {
        fmt.Println("æ•°æ®å¤„ç†æˆåŠŸ")
    }
}

// è¸©å‘æ€»ç»“
func InterfacePitfallsSummary() {
    fmt.Println(`
=== Goæ¥å£ç¼–ç¨‹è¸©å‘æ€»ç»“ ===

1. æ¥å£nilåˆ¤æ–­é™·é˜±ï¼š
   âŒ è¿”å›nilæŒ‡é’ˆç»™æ¥å£ç±»å‹
   âœ… è¿”å›æ˜ç¡®çš„nilæˆ–ä½¿ç”¨åå°„æ£€æŸ¥

2. ç©ºæ¥å£æ»¥ç”¨ï¼š
   âŒ è¿‡åº¦ä½¿ç”¨interface{}å¯¼è‡´ç±»å‹ä¸å®‰å…¨
   âœ… ä½¿ç”¨å…·ä½“ç±»å‹æˆ–æ³›å‹

3. æ¥å£è®¾è®¡è¿‡åº¦æŠ½è±¡ï¼š
   âŒ å•ä¸ªæ¥å£åŒ…å«å¤ªå¤šæ–¹æ³•
   âœ… éµå¾ªå•ä¸€èŒè´£åŸåˆ™ï¼Œè®¾è®¡å°æ¥å£

4. ç±»å‹æ–­è¨€æ€§èƒ½é—®é¢˜ï¼š
   âŒ é¢‘ç¹çš„ç±»å‹æ–­è¨€
   âœ… ä½¿ç”¨ç±»å‹å¼€å…³æˆ–é¿å…interface{}

5. æ–¹æ³•ç­¾åä¸ä¸€è‡´ï¼š
   âŒ æ¥å£æ–¹æ³•ç­¾åä¸ç»Ÿä¸€
   âœ… éµå¾ªGoæ ‡å‡†åº“çš„è®¾è®¡æ¨¡å¼

æœ€ä½³å®è·µï¼š
- æ¥å—æ¥å£ï¼Œè¿”å›ç»“æ„ä½“
- æ¥å£åº”è¯¥å°è€Œä¸“ä¸€
- ä¼˜å…ˆä½¿ç”¨æ ‡å‡†åº“æ¥å£
- é¿å…è¿‡åº¦æŠ½è±¡
- æ³¨æ„æ¥å£çš„nilè¯­ä¹‰
    `)
}
```

---

## ğŸ“ ç»ƒä¹ é¢˜

é€šè¿‡5é“ä»åŸºç¡€åˆ°é«˜çº§çš„ç»ƒä¹ é¢˜ï¼Œå·©å›ºGoæ¥å£è®¾è®¡æ¨¡å¼çš„çŸ¥è¯†ã€‚

### ç»ƒä¹ é¢˜1ï¼šåŸºç¡€æ¥å£è®¾è®¡ï¼ˆâ­ï¼‰

**é¢˜ç›®æè¿°ï¼š**
è®¾è®¡ä¸€ä¸ªå›¾å½¢è®¡ç®—ç³»ç»Ÿï¼ŒåŒ…å«ä¸åŒçš„å‡ ä½•å›¾å½¢ï¼ˆåœ†å½¢ã€çŸ©å½¢ã€ä¸‰è§’å½¢ï¼‰ï¼Œæ¯ä¸ªå›¾å½¢éƒ½èƒ½è®¡ç®—é¢ç§¯å’Œå‘¨é•¿ã€‚è¦æ±‚ä½¿ç”¨æ¥å£è®¾è®¡ï¼Œå¹¶å®ç°ä¸€ä¸ªå›¾å½¢ç®¡ç†å™¨æ¥ç»Ÿä¸€å¤„ç†æ‰€æœ‰å›¾å½¢ã€‚

```go
// ç»ƒä¹ é¢˜1ï¼šåŸºç¡€æ¥å£è®¾è®¡
package exercises

import (
    "fmt"
    "math"
)

// è§£ç­”ï¼š
// 1. å®šä¹‰å›¾å½¢æ¥å£
type Shape interface {
    Area() float64
    Perimeter() float64
    Name() string
}

// 2. å®ç°å…·ä½“å›¾å½¢
type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
    return 2 * math.Pi * c.Radius
}

func (c Circle) Name() string {
    return "åœ†å½¢"
}

type Rectangle struct {
    Width  float64
    Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

func (r Rectangle) Name() string {
    return "çŸ©å½¢"
}

type Triangle struct {
    A, B, C float64 // ä¸‰è¾¹é•¿
}

func (t Triangle) Area() float64 {
    // ä½¿ç”¨æµ·ä¼¦å…¬å¼
    s := (t.A + t.B + t.C) / 2
    return math.Sqrt(s * (s - t.A) * (s - t.B) * (s - t.C))
}

func (t Triangle) Perimeter() float64 {
    return t.A + t.B + t.C
}

func (t Triangle) Name() string {
    return "ä¸‰è§’å½¢"
}

// 3. å›¾å½¢ç®¡ç†å™¨
type ShapeManager struct {
    shapes []Shape
}

func NewShapeManager() *ShapeManager {
    return &ShapeManager{
        shapes: make([]Shape, 0),
    }
}

func (sm *ShapeManager) AddShape(shape Shape) {
    sm.shapes = append(sm.shapes, shape)
    fmt.Printf("æ·»åŠ å›¾å½¢: %s\n", shape.Name())
}

func (sm *ShapeManager) CalculateTotalArea() float64 {
    var total float64
    for _, shape := range sm.shapes {
        total += shape.Area()
    }
    return total
}

func (sm *ShapeManager) CalculateTotalPerimeter() float64 {
    var total float64
    for _, shape := range sm.shapes {
        total += shape.Perimeter()
    }
    return total
}

func (sm *ShapeManager) PrintShapeInfo() {
    fmt.Println("=== å›¾å½¢ä¿¡æ¯ ===")
    for i, shape := range sm.shapes {
        fmt.Printf("%d. %s - é¢ç§¯: %.2f, å‘¨é•¿: %.2f\n",
            i+1, shape.Name(), shape.Area(), shape.Perimeter())
    }
    fmt.Printf("æ€»é¢ç§¯: %.2f\n", sm.CalculateTotalArea())
    fmt.Printf("æ€»å‘¨é•¿: %.2f\n", sm.CalculateTotalPerimeter())
}

// æµ‹è¯•å‡½æ•°
func TestExercise1() {
    fmt.Println("=== ç»ƒä¹ é¢˜1ï¼šåŸºç¡€æ¥å£è®¾è®¡ ===")

    manager := NewShapeManager()

    // æ·»åŠ ä¸åŒå›¾å½¢
    manager.AddShape(Circle{Radius: 5})
    manager.AddShape(Rectangle{Width: 4, Height: 6})
    manager.AddShape(Triangle{A: 3, B: 4, C: 5})

    // æ‰“å°ä¿¡æ¯
    manager.PrintShapeInfo()
}

/*
è§£æè¯´æ˜ï¼š
1. æ¥å£è®¾è®¡ï¼šå®šä¹‰äº†Shapeæ¥å£ï¼ŒåŒ…å«é¢ç§¯ã€å‘¨é•¿å’Œåç§°æ–¹æ³•
2. å¤šæ€å®ç°ï¼šä¸åŒå›¾å½¢å®ç°ç›¸åŒæ¥å£ï¼Œä½†å…·ä½“è®¡ç®—æ–¹å¼ä¸åŒ
3. ç»Ÿä¸€ç®¡ç†ï¼šShapeManageré€šè¿‡æ¥å£ç»Ÿä¸€å¤„ç†æ‰€æœ‰å›¾å½¢
4. æ‰©å±•æ€§ï¼šæ–°å¢å›¾å½¢ç±»å‹åªéœ€å®ç°Shapeæ¥å£å³å¯

æ‰©å±•æ€è€ƒï¼š
- å¦‚ä½•æ·»åŠ 3Då›¾å½¢ï¼ˆä½“ç§¯è®¡ç®—ï¼‰ï¼Ÿ
- å¦‚ä½•å®ç°å›¾å½¢çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–ï¼Ÿ
- å¦‚ä½•æ·»åŠ å›¾å½¢çš„ç»˜åˆ¶åŠŸèƒ½ï¼Ÿ
*/
```

### ç»ƒä¹ é¢˜2ï¼šæ¥å£ç»„åˆè®¾è®¡ï¼ˆâ­â­ï¼‰

**é¢˜ç›®æè¿°ï¼š**
è®¾è®¡ä¸€ä¸ªæ–‡ä»¶å¤„ç†ç³»ç»Ÿï¼Œæ”¯æŒä¸åŒçš„æ–‡ä»¶æ“ä½œï¼ˆè¯»å–ã€å†™å…¥ã€å‹ç¼©ã€åŠ å¯†ï¼‰ã€‚ä½¿ç”¨æ¥å£ç»„åˆçš„æ–¹å¼ï¼Œè®©ä¸åŒçš„æ–‡ä»¶å¤„ç†å™¨å¯ä»¥çµæ´»ç»„åˆè¿™äº›åŠŸèƒ½ã€‚

```go
// ç»ƒä¹ é¢˜2ï¼šæ¥å£ç»„åˆè®¾è®¡
package exercises

import (
    "fmt"
    "strings"
    "time"
)

// è§£ç­”ï¼š
// 1. å®šä¹‰åŸºç¡€æ¥å£
type Reader interface {
    Read() ([]byte, error)
}

type Writer interface {
    Write(data []byte) error
}

type Compressor interface {
    Compress(data []byte) ([]byte, error)
    Decompress(data []byte) ([]byte, error)
}

type Encryptor interface {
    Encrypt(data []byte) ([]byte, error)
    Decrypt(data []byte) ([]byte, error)
}

// 2. ç»„åˆæ¥å£
type ReadWriter interface {
    Reader
    Writer
}

type CompressedReader interface {
    Reader
    Compressor
}

type EncryptedWriter interface {
    Writer
    Encryptor
}

type SecureFileProcessor interface {
    Reader
    Writer
    Compressor
    Encryptor
}

// 3. å…·ä½“å®ç°
type TextFile struct {
    content string
    path    string
}

func NewTextFile(path string, content string) *TextFile {
    return &TextFile{
        content: content,
        path:    path,
    }
}

func (tf *TextFile) Read() ([]byte, error) {
    fmt.Printf("è¯»å–æ–‡ä»¶: %s\n", tf.path)
    return []byte(tf.content), nil
}

func (tf *TextFile) Write(data []byte) error {
    fmt.Printf("å†™å…¥æ–‡ä»¶: %s\n", tf.path)
    tf.content = string(data)
    return nil
}

// å‹ç¼©å™¨å®ç°
type GzipCompressor struct{}

func (gc *GzipCompressor) Compress(data []byte) ([]byte, error) {
    fmt.Printf("GZIPå‹ç¼©æ•°æ®ï¼ŒåŸå§‹å¤§å°: %d å­—èŠ‚\n", len(data))
    // æ¨¡æ‹Ÿå‹ç¼©ï¼ˆå®é™…åº”è¯¥ä½¿ç”¨gzipåº“ï¼‰
    compressed := fmt.Sprintf("GZIP[%s]", string(data))
    return []byte(compressed), nil
}

func (gc *GzipCompressor) Decompress(data []byte) ([]byte, error) {
    fmt.Printf("GZIPè§£å‹æ•°æ®\n")
    // æ¨¡æ‹Ÿè§£å‹
    content := string(data)
    if strings.HasPrefix(content, "GZIP[") && strings.HasSuffix(content, "]") {
        original := content[5 : len(content)-1]
        return []byte(original), nil
    }
    return data, nil
}

// åŠ å¯†å™¨å®ç°
type AESEncryptor struct {
    key string
}

func NewAESEncryptor(key string) *AESEncryptor {
    return &AESEncryptor{key: key}
}

func (ae *AESEncryptor) Encrypt(data []byte) ([]byte, error) {
    fmt.Printf("AESåŠ å¯†æ•°æ®ï¼Œå¯†é’¥: %s\n", ae.key)
    // æ¨¡æ‹ŸåŠ å¯†ï¼ˆå®é™…åº”è¯¥ä½¿ç”¨crypto/aesï¼‰
    encrypted := fmt.Sprintf("AES[%s]", string(data))
    return []byte(encrypted), nil
}

func (ae *AESEncryptor) Decrypt(data []byte) ([]byte, error) {
    fmt.Printf("AESè§£å¯†æ•°æ®\n")
    // æ¨¡æ‹Ÿè§£å¯†
    content := string(data)
    if strings.HasPrefix(content, "AES[") && strings.HasSuffix(content, "]") {
        original := content[4 : len(content)-1]
        return []byte(original), nil
    }
    return data, nil
}

// 4. ç»„åˆæ–‡ä»¶å¤„ç†å™¨
type CompositeFileProcessor struct {
    file       ReadWriter
    compressor Compressor
    encryptor  Encryptor
}

func NewCompositeFileProcessor(file ReadWriter, compressor Compressor, encryptor Encryptor) *CompositeFileProcessor {
    return &CompositeFileProcessor{
        file:       file,
        compressor: compressor,
        encryptor:  encryptor,
    }
}

func (cfp *CompositeFileProcessor) Read() ([]byte, error) {
    // è¯»å– -> è§£å¯† -> è§£å‹
    data, err := cfp.file.Read()
    if err != nil {
        return nil, err
    }

    if cfp.encryptor != nil {
        data, err = cfp.encryptor.Decrypt(data)
        if err != nil {
            return nil, err
        }
    }

    if cfp.compressor != nil {
        data, err = cfp.compressor.Decompress(data)
        if err != nil {
            return nil, err
        }
    }

    return data, nil
}

func (cfp *CompositeFileProcessor) Write(data []byte) error {
    // å‹ç¼© -> åŠ å¯† -> å†™å…¥
    processedData := data
    var err error

    if cfp.compressor != nil {
        processedData, err = cfp.compressor.Compress(processedData)
        if err != nil {
            return err
        }
    }

    if cfp.encryptor != nil {
        processedData, err = cfp.encryptor.Encrypt(processedData)
        if err != nil {
            return err
        }
    }

    return cfp.file.Write(processedData)
}

func (cfp *CompositeFileProcessor) Compress(data []byte) ([]byte, error) {
    if cfp.compressor != nil {
        return cfp.compressor.Compress(data)
    }
    return data, nil
}

func (cfp *CompositeFileProcessor) Decompress(data []byte) ([]byte, error) {
    if cfp.compressor != nil {
        return cfp.compressor.Decompress(data)
    }
    return data, nil
}

func (cfp *CompositeFileProcessor) Encrypt(data []byte) ([]byte, error) {
    if cfp.encryptor != nil {
        return cfp.encryptor.Encrypt(data)
    }
    return data, nil
}

func (cfp *CompositeFileProcessor) Decrypt(data []byte) ([]byte, error) {
    if cfp.encryptor != nil {
        return cfp.encryptor.Decrypt(data)
    }
    return data, nil
}

// 5. æ–‡ä»¶å¤„ç†å·¥å‚
type FileProcessorFactory struct{}

func (fpf *FileProcessorFactory) CreateSimpleProcessor(path string) ReadWriter {
    return NewTextFile(path, "")
}

func (fpf *FileProcessorFactory) CreateCompressedProcessor(path string) *CompositeFileProcessor {
    file := NewTextFile(path, "")
    compressor := &GzipCompressor{}
    return NewCompositeFileProcessor(file, compressor, nil)
}

func (fpf *FileProcessorFactory) CreateEncryptedProcessor(path string, key string) *CompositeFileProcessor {
    file := NewTextFile(path, "")
    encryptor := NewAESEncryptor(key)
    return NewCompositeFileProcessor(file, nil, encryptor)
}

func (fpf *FileProcessorFactory) CreateSecureProcessor(path string, key string) *CompositeFileProcessor {
    file := NewTextFile(path, "")
    compressor := &GzipCompressor{}
    encryptor := NewAESEncryptor(key)
    return NewCompositeFileProcessor(file, compressor, encryptor)
}

// æµ‹è¯•å‡½æ•°
func TestExercise2() {
    fmt.Println("=== ç»ƒä¹ é¢˜2ï¼šæ¥å£ç»„åˆè®¾è®¡ ===")

    factory := &FileProcessorFactory{}

    // æµ‹è¯•ä¸åŒç±»å‹çš„å¤„ç†å™¨
    testData := []byte("è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æ–‡ä»¶çš„å†…å®¹ï¼ŒåŒ…å«ä¸€äº›é‡è¦çš„æ•°æ®ã€‚")

    fmt.Println("1. ç®€å•æ–‡ä»¶å¤„ç†å™¨:")
    simple := factory.CreateSimpleProcessor("simple.txt")
    simple.Write(testData)
    data, _ := simple.Read()
    fmt.Printf("è¯»å–ç»“æœ: %s\n", string(data))

    fmt.Println("\n2. å‹ç¼©æ–‡ä»¶å¤„ç†å™¨:")
    compressed := factory.CreateCompressedProcessor("compressed.txt.gz")
    compressed.Write(testData)
    data, _ = compressed.Read()
    fmt.Printf("è¯»å–ç»“æœ: %s\n", string(data))

    fmt.Println("\n3. åŠ å¯†æ–‡ä»¶å¤„ç†å™¨:")
    encrypted := factory.CreateEncryptedProcessor("encrypted.txt", "mykey123")
    encrypted.Write(testData)
    data, _ = encrypted.Read()
    fmt.Printf("è¯»å–ç»“æœ: %s\n", string(data))

    fmt.Println("\n4. å®‰å…¨æ–‡ä»¶å¤„ç†å™¨ï¼ˆå‹ç¼©+åŠ å¯†ï¼‰:")
    secure := factory.CreateSecureProcessor("secure.txt", "secretkey")
    secure.Write(testData)
    data, _ = secure.Read()
    fmt.Printf("è¯»å–ç»“æœ: %s\n", string(data))
}

/*
è§£æè¯´æ˜ï¼š
1. æ¥å£åˆ†ç¦»ï¼šå°†æ–‡ä»¶æ“ä½œåˆ†è§£ä¸ºç‹¬ç«‹çš„å°æ¥å£
2. æ¥å£ç»„åˆï¼šé€šè¿‡åµŒå…¥åˆ›å»ºå¤åˆæ¥å£
3. è£…é¥°å™¨æ¨¡å¼ï¼šCompositeFileProcessorè£…é¥°åŸºç¡€æ–‡ä»¶æ“ä½œ
4. å·¥å‚æ¨¡å¼ï¼šFileProcessorFactoryåˆ›å»ºä¸åŒé…ç½®çš„å¤„ç†å™¨

æ‰©å±•æ€è€ƒï¼š
- å¦‚ä½•æ·»åŠ æ›´å¤šå‹ç¼©ç®—æ³•ï¼ˆZIPã€LZ4ç­‰ï¼‰ï¼Ÿ
- å¦‚ä½•å®ç°æµå¼å¤„ç†å¤§æ–‡ä»¶ï¼Ÿ
- å¦‚ä½•æ·»åŠ æ–‡ä»¶å®Œæ•´æ€§æ ¡éªŒï¼Ÿ
- å¦‚ä½•æ”¯æŒå¼‚æ­¥æ–‡ä»¶æ“ä½œï¼Ÿ
*/
```

### ç»ƒä¹ é¢˜3ï¼šè§‚å¯Ÿè€…æ¨¡å¼å®ç°ï¼ˆâ­â­â­ï¼‰

**é¢˜ç›®æè¿°ï¼š**
å®ç°ä¸€ä¸ªäº‹ä»¶ç³»ç»Ÿï¼Œæ”¯æŒè®¢é˜…å’Œå‘å¸ƒæœºåˆ¶ã€‚è¦æ±‚æ”¯æŒä¸åŒç±»å‹çš„äº‹ä»¶ï¼Œå¤šä¸ªè§‚å¯Ÿè€…å¯ä»¥è®¢é˜…åŒä¸€äº‹ä»¶ï¼Œå¹¶ä¸”æ”¯æŒå¼‚æ­¥é€šçŸ¥ã€‚

```go
// ç»ƒä¹ é¢˜3ï¼šè§‚å¯Ÿè€…æ¨¡å¼å®ç°
package exercises

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// è§£ç­”ï¼š
// 1. å®šä¹‰äº‹ä»¶æ¥å£
type Event interface {
    GetType() string
    GetData() interface{}
    GetTimestamp() time.Time
}

// 2. è§‚å¯Ÿè€…æ¥å£
type Observer interface {
    OnEvent(ctx context.Context, event Event) error
    GetID() string
}

// 3. äº‹ä»¶å‘å¸ƒè€…æ¥å£
type EventPublisher interface {
    Subscribe(eventType string, observer Observer) error
    Unsubscribe(eventType string, observerID string) error
    Publish(ctx context.Context, event Event) error
    PublishAsync(ctx context.Context, event Event) error
}

// 4. å…·ä½“äº‹ä»¶å®ç°
type BaseEvent struct {
    Type      string      `json:"type"`
    Data      interface{} `json:"data"`
    Timestamp time.Time   `json:"timestamp"`
}

func NewBaseEvent(eventType string, data interface{}) *BaseEvent {
    return &BaseEvent{
        Type:      eventType,
        Data:      data,
        Timestamp: time.Now(),
    }
}

func (e *BaseEvent) GetType() string {
    return e.Type
}

func (e *BaseEvent) GetData() interface{} {
    return e.Data
}

func (e *BaseEvent) GetTimestamp() time.Time {
    return e.Timestamp
}

// ç”¨æˆ·äº‹ä»¶
type UserEvent struct {
    *BaseEvent
    UserID int64  `json:"user_id"`
    Action string `json:"action"`
}

func NewUserEvent(userID int64, action string, data interface{}) *UserEvent {
    return &UserEvent{
        BaseEvent: NewBaseEvent("user", data),
        UserID:    userID,
        Action:    action,
    }
}

// è®¢å•äº‹ä»¶
type OrderEvent struct {
    *BaseEvent
    OrderID string  `json:"order_id"`
    Status  string  `json:"status"`
    Amount  float64 `json:"amount"`
}

func NewOrderEvent(orderID, status string, amount float64, data interface{}) *OrderEvent {
    return &OrderEvent{
        BaseEvent: NewBaseEvent("order", data),
        OrderID:   orderID,
        Status:    status,
        Amount:    amount,
    }
}

// 5. å…·ä½“è§‚å¯Ÿè€…å®ç°
type EmailNotifier struct {
    ID       string
    Email    string
    Template string
}

func NewEmailNotifier(id, email, template string) *EmailNotifier {
    return &EmailNotifier{
        ID:       id,
        Email:    email,
        Template: template,
    }
}

func (en *EmailNotifier) OnEvent(ctx context.Context, event Event) error {
    fmt.Printf("[é‚®ä»¶é€šçŸ¥] å‘é€åˆ° %s: äº‹ä»¶ç±»å‹=%s, æ—¶é—´=%s\n",
        en.Email, event.GetType(), event.GetTimestamp().Format("15:04:05"))

    // æ¨¡æ‹Ÿé‚®ä»¶å‘é€å»¶è¿Ÿ
    time.Sleep(100 * time.Millisecond)

    switch e := event.(type) {
    case *UserEvent:
        fmt.Printf("  ç”¨æˆ·äº‹ä»¶: ç”¨æˆ·ID=%d, åŠ¨ä½œ=%s\n", e.UserID, e.Action)
    case *OrderEvent:
        fmt.Printf("  è®¢å•äº‹ä»¶: è®¢å•ID=%s, çŠ¶æ€=%s, é‡‘é¢=%.2f\n", e.OrderID, e.Status, e.Amount)
    default:
        fmt.Printf("  é€šç”¨äº‹ä»¶: æ•°æ®=%v\n", e.GetData())
    }

    return nil
}

func (en *EmailNotifier) GetID() string {
    return en.ID
}

type SMSNotifier struct {
    ID    string
    Phone string
}

func NewSMSNotifier(id, phone string) *SMSNotifier {
    return &SMSNotifier{
        ID:    id,
        Phone: phone,
    }
}

func (sn *SMSNotifier) OnEvent(ctx context.Context, event Event) error {
    fmt.Printf("[çŸ­ä¿¡é€šçŸ¥] å‘é€åˆ° %s: äº‹ä»¶ç±»å‹=%s\n", sn.Phone, event.GetType())

    // æ¨¡æ‹ŸçŸ­ä¿¡å‘é€å»¶è¿Ÿ
    time.Sleep(50 * time.Millisecond)

    return nil
}

func (sn *SMSNotifier) GetID() string {
    return sn.ID
}

type LogObserver struct {
    ID     string
    Logger string
}

func NewLogObserver(id, logger string) *LogObserver {
    return &LogObserver{
        ID:     id,
        Logger: logger,
    }
}

func (lo *LogObserver) OnEvent(ctx context.Context, event Event) error {
    fmt.Printf("[æ—¥å¿—è®°å½•] %s: [%s] äº‹ä»¶=%s, æ•°æ®=%v\n",
        lo.Logger, event.GetTimestamp().Format("2006-01-02 15:04:05"),
        event.GetType(), event.GetData())
    return nil
}

func (lo *LogObserver) GetID() string {
    return lo.ID
}

// 6. äº‹ä»¶æ€»çº¿å®ç°
type EventBus struct {
    subscribers map[string][]Observer
    mutex       sync.RWMutex
    workerPool  chan struct{} // é™åˆ¶å¹¶å‘æ•°
}

func NewEventBus(maxWorkers int) *EventBus {
    return &EventBus{
        subscribers: make(map[string][]Observer),
        workerPool:  make(chan struct{}, maxWorkers),
    }
}

func (eb *EventBus) Subscribe(eventType string, observer Observer) error {
    eb.mutex.Lock()
    defer eb.mutex.Unlock()

    // æ£€æŸ¥æ˜¯å¦å·²ç»è®¢é˜…
    for _, obs := range eb.subscribers[eventType] {
        if obs.GetID() == observer.GetID() {
            return fmt.Errorf("è§‚å¯Ÿè€… %s å·²ç»è®¢é˜…äº†äº‹ä»¶ %s", observer.GetID(), eventType)
        }
    }

    eb.subscribers[eventType] = append(eb.subscribers[eventType], observer)
    fmt.Printf("è§‚å¯Ÿè€… %s è®¢é˜…äº†äº‹ä»¶ %s\n", observer.GetID(), eventType)
    return nil
}

func (eb *EventBus) Unsubscribe(eventType string, observerID string) error {
    eb.mutex.Lock()
    defer eb.mutex.Unlock()

    observers := eb.subscribers[eventType]
    for i, obs := range observers {
        if obs.GetID() == observerID {
            // åˆ é™¤è§‚å¯Ÿè€…
            eb.subscribers[eventType] = append(observers[:i], observers[i+1:]...)
            fmt.Printf("è§‚å¯Ÿè€… %s å–æ¶ˆè®¢é˜…äº‹ä»¶ %s\n", observerID, eventType)
            return nil
        }
    }

    return fmt.Errorf("è§‚å¯Ÿè€… %s æ²¡æœ‰è®¢é˜…äº‹ä»¶ %s", observerID, eventType)
}

func (eb *EventBus) Publish(ctx context.Context, event Event) error {
    eb.mutex.RLock()
    observers := make([]Observer, len(eb.subscribers[event.GetType()]))
    copy(observers, eb.subscribers[event.GetType()])
    eb.mutex.RUnlock()

    fmt.Printf("å‘å¸ƒäº‹ä»¶: %s, è§‚å¯Ÿè€…æ•°é‡: %d\n", event.GetType(), len(observers))

    // åŒæ­¥é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…
    for _, observer := range observers {
        if err := observer.OnEvent(ctx, event); err != nil {
            fmt.Printf("è§‚å¯Ÿè€… %s å¤„ç†äº‹ä»¶å¤±è´¥: %v\n", observer.GetID(), err)
        }
    }

    return nil
}

func (eb *EventBus) PublishAsync(ctx context.Context, event Event) error {
    eb.mutex.RLock()
    observers := make([]Observer, len(eb.subscribers[event.GetType()]))
    copy(observers, eb.subscribers[event.GetType()])
    eb.mutex.RUnlock()

    fmt.Printf("å¼‚æ­¥å‘å¸ƒäº‹ä»¶: %s, è§‚å¯Ÿè€…æ•°é‡: %d\n", event.GetType(), len(observers))

    // å¼‚æ­¥é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…
    var wg sync.WaitGroup
    for _, observer := range observers {
        wg.Add(1)
        go func(obs Observer) {
            defer wg.Done()

            // è·å–å·¥ä½œæ± ä»¤ç‰Œ
            eb.workerPool <- struct{}{}
            defer func() { <-eb.workerPool }()

            if err := obs.OnEvent(ctx, event); err != nil {
                fmt.Printf("è§‚å¯Ÿè€… %s å¼‚æ­¥å¤„ç†äº‹ä»¶å¤±è´¥: %v\n", obs.GetID(), err)
            }
        }(observer)
    }

    // å¯ä»¥é€‰æ‹©ç­‰å¾…æ‰€æœ‰è§‚å¯Ÿè€…å®Œæˆï¼Œæˆ–è€…ç«‹å³è¿”å›
    go func() {
        wg.Wait()
        fmt.Printf("äº‹ä»¶ %s çš„æ‰€æœ‰å¼‚æ­¥å¤„ç†å®Œæˆ\n", event.GetType())
    }()

    return nil
}

func (eb *EventBus) GetSubscriberCount(eventType string) int {
    eb.mutex.RLock()
    defer eb.mutex.RUnlock()
    return len(eb.subscribers[eventType])
}

// 7. äº‹ä»¶ç®¡ç†å™¨
type EventManager struct {
    eventBus EventPublisher
    stats    map[string]int
    mutex    sync.Mutex
}

func NewEventManager(eventBus EventPublisher) *EventManager {
    return &EventManager{
        eventBus: eventBus,
        stats:    make(map[string]int),
    }
}

func (em *EventManager) RegisterObserver(eventType string, observer Observer) error {
    return em.eventBus.Subscribe(eventType, observer)
}

func (em *EventManager) UnregisterObserver(eventType string, observerID string) error {
    return em.eventBus.Unsubscribe(eventType, observerID)
}

func (em *EventManager) EmitEvent(ctx context.Context, event Event, async bool) error {
    em.mutex.Lock()
    em.stats[event.GetType()]++
    em.mutex.Unlock()

    if async {
        return em.eventBus.PublishAsync(ctx, event)
    }
    return em.eventBus.Publish(ctx, event)
}

func (em *EventManager) GetStats() map[string]int {
    em.mutex.Lock()
    defer em.mutex.Unlock()

    stats := make(map[string]int)
    for k, v := range em.stats {
        stats[k] = v
    }
    return stats
}

// æµ‹è¯•å‡½æ•°
func TestExercise3() {
    fmt.Println("=== ç»ƒä¹ é¢˜3ï¼šè§‚å¯Ÿè€…æ¨¡å¼å®ç° ===")

    // åˆ›å»ºäº‹ä»¶æ€»çº¿
    eventBus := NewEventBus(5) // æœ€å¤š5ä¸ªå¹¶å‘å·¥ä½œè€…
    manager := NewEventManager(eventBus)

    // åˆ›å»ºè§‚å¯Ÿè€…
    emailNotifier := NewEmailNotifier("email1", "user@example.com", "default")
    smsNotifier := NewSMSNotifier("sms1", "13800138000")
    logObserver := NewLogObserver("log1", "SystemLogger")

    // è®¢é˜…äº‹ä»¶
    manager.RegisterObserver("user", emailNotifier)
    manager.RegisterObserver("user", logObserver)
    manager.RegisterObserver("order", emailNotifier)
    manager.RegisterObserver("order", smsNotifier)
    manager.RegisterObserver("order", logObserver)

    ctx := context.Background()

    // å‘å¸ƒç”¨æˆ·äº‹ä»¶
    fmt.Println("\n1. å‘å¸ƒç”¨æˆ·äº‹ä»¶ï¼ˆåŒæ­¥ï¼‰:")
    userEvent := NewUserEvent(12345, "login", map[string]string{"ip": "192.168.1.100"})
    manager.EmitEvent(ctx, userEvent, false)

    // å‘å¸ƒè®¢å•äº‹ä»¶
    fmt.Println("\n2. å‘å¸ƒè®¢å•äº‹ä»¶ï¼ˆå¼‚æ­¥ï¼‰:")
    orderEvent := NewOrderEvent("ORDER_001", "created", 299.99, map[string]string{"payment": "pending"})
    manager.EmitEvent(ctx, orderEvent, true)

    // ç­‰å¾…å¼‚æ­¥å¤„ç†å®Œæˆ
    time.Sleep(200 * time.Millisecond)

    // å–æ¶ˆè®¢é˜…
    fmt.Println("\n3. å–æ¶ˆè®¢é˜…:")
    manager.UnregisterObserver("user", "email1")

    // å†æ¬¡å‘å¸ƒç”¨æˆ·äº‹ä»¶
    fmt.Println("\n4. å†æ¬¡å‘å¸ƒç”¨æˆ·äº‹ä»¶:")
    userEvent2 := NewUserEvent(12346, "logout", map[string]string{"session": "expired"})
    manager.EmitEvent(ctx, userEvent2, false)

    // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
    fmt.Println("\n5. äº‹ä»¶ç»Ÿè®¡:")
    stats := manager.GetStats()
    for eventType, count := range stats {
        fmt.Printf("äº‹ä»¶ç±»å‹ %s: å‘å¸ƒæ¬¡æ•° %d\n", eventType, count)
    }
}

/*
è§£æè¯´æ˜ï¼š
1. æ¥å£è®¾è®¡ï¼šå®šä¹‰äº†Eventã€Observerã€EventPublisheræ¥å£
2. äº‹ä»¶ç±»å‹ï¼šæ”¯æŒä¸åŒç±»å‹çš„äº‹ä»¶ï¼Œå¯æ‰©å±•
3. å¼‚æ­¥å¤„ç†ï¼šæ”¯æŒåŒæ­¥å’Œå¼‚æ­¥äº‹ä»¶é€šçŸ¥
4. å¹¶å‘æ§åˆ¶ï¼šä½¿ç”¨å·¥ä½œæ± é™åˆ¶å¹¶å‘æ•°é‡
5. ç»Ÿè®¡åŠŸèƒ½ï¼šè®°å½•äº‹ä»¶å‘å¸ƒç»Ÿè®¡ä¿¡æ¯

æ‰©å±•æ€è€ƒï¼š
- å¦‚ä½•å®ç°äº‹ä»¶æŒä¹…åŒ–ï¼Ÿ
- å¦‚ä½•æ·»åŠ äº‹ä»¶è¿‡æ»¤åŠŸèƒ½ï¼Ÿ
- å¦‚ä½•å®ç°äº‹ä»¶é‡è¯•æœºåˆ¶ï¼Ÿ
- å¦‚ä½•æ”¯æŒåˆ†å¸ƒå¼äº‹ä»¶ç³»ç»Ÿï¼Ÿ
*/
```

### ç»ƒä¹ é¢˜4ï¼šä¾èµ–æ³¨å…¥å®¹å™¨ï¼ˆâ­â­â­â­ï¼‰

**é¢˜ç›®æè¿°ï¼š**
å®ç°ä¸€ä¸ªå®Œæ•´çš„ä¾èµ–æ³¨å…¥å®¹å™¨ï¼Œæ”¯æŒæ„é€ å‡½æ•°æ³¨å…¥ã€æ¥å£æ³¨å…¥ã€å•ä¾‹æ¨¡å¼ã€ç”Ÿå‘½å‘¨æœŸç®¡ç†ç­‰åŠŸèƒ½ã€‚è¦æ±‚æ”¯æŒå¾ªç¯ä¾èµ–æ£€æµ‹å’Œè‡ªåŠ¨è£…é…ã€‚

```go
// ç»ƒä¹ é¢˜4ï¼šä¾èµ–æ³¨å…¥å®¹å™¨
package exercises

import (
    "fmt"
    "reflect"
    "sync"
)

// è§£ç­”ï¼š
// 1. å®šä¹‰ä¾èµ–æ³¨å…¥ç›¸å…³æ¥å£
type ServiceContainer interface {
    Register(name string, factory ServiceFactory, options ...ServiceOption) error
    RegisterSingleton(name string, factory ServiceFactory) error
    RegisterTransient(name string, factory ServiceFactory) error
    Resolve(name string) (interface{}, error)
    ResolveByType(serviceType reflect.Type) (interface{}, error)
    Build() error
}

type ServiceFactory func(container ServiceContainer) (interface{}, error)

type ServiceLifetime int

const (
    Transient ServiceLifetime = iota // æ¯æ¬¡åˆ›å»ºæ–°å®ä¾‹
    Singleton                        // å•ä¾‹æ¨¡å¼
    Scoped                          // ä½œç”¨åŸŸå†…å•ä¾‹
)

type ServiceDescriptor struct {
    Name        string
    ServiceType reflect.Type
    Factory     ServiceFactory
    Lifetime    ServiceLifetime
    Instance    interface{}
    Dependencies []string
}

type ServiceOption func(*ServiceDescriptor)

// 2. æœåŠ¡é€‰é¡¹
func WithLifetime(lifetime ServiceLifetime) ServiceOption {
    return func(sd *ServiceDescriptor) {
        sd.Lifetime = lifetime
    }
}

func WithDependencies(deps ...string) ServiceOption {
    return func(sd *ServiceDescriptor) {
        sd.Dependencies = deps
    }
}

func WithServiceType(serviceType reflect.Type) ServiceOption {
    return func(sd *ServiceDescriptor) {
        sd.ServiceType = serviceType
    }
}

// 3. ä¾èµ–æ³¨å…¥å®¹å™¨å®ç°
type DIContainer struct {
    services    map[string]*ServiceDescriptor
    instances   map[string]interface{}
    building    map[string]bool // å¾ªç¯ä¾èµ–æ£€æµ‹
    mutex       sync.RWMutex
    built       bool
}

func NewDIContainer() *DIContainer {
    return &DIContainer{
        services:  make(map[string]*ServiceDescriptor),
        instances: make(map[string]interface{}),
        building:  make(map[string]bool),
    }
}

func (c *DIContainer) Register(name string, factory ServiceFactory, options ...ServiceOption) error {
    c.mutex.Lock()
    defer c.mutex.Unlock()

    if c.built {
        return fmt.Errorf("å®¹å™¨å·²æ„å»ºï¼Œæ— æ³•æ³¨å†Œæ–°æœåŠ¡")
    }

    descriptor := &ServiceDescriptor{
        Name:     name,
        Factory:  factory,
        Lifetime: Transient, // é»˜è®¤ä¸ºç¬æ€
    }

    // åº”ç”¨é€‰é¡¹
    for _, option := range options {
        option(descriptor)
    }

    c.services[name] = descriptor
    fmt.Printf("æ³¨å†ŒæœåŠ¡: %s (ç”Ÿå‘½å‘¨æœŸ: %v)\n", name, descriptor.Lifetime)
    return nil
}

func (c *DIContainer) RegisterSingleton(name string, factory ServiceFactory) error {
    return c.Register(name, factory, WithLifetime(Singleton))
}

func (c *DIContainer) RegisterTransient(name string, factory ServiceFactory) error {
    return c.Register(name, factory, WithLifetime(Transient))
}

func (c *DIContainer) Resolve(name string) (interface{}, error) {
    c.mutex.RLock()
    descriptor, exists := c.services[name]
    c.mutex.RUnlock()

    if !exists {
        return nil, fmt.Errorf("æœåŠ¡ '%s' æœªæ³¨å†Œ", name)
    }

    return c.createInstance(descriptor)
}

func (c *DIContainer) ResolveByType(serviceType reflect.Type) (interface{}, error) {
    c.mutex.RLock()
    defer c.mutex.RUnlock()

    for _, descriptor := range c.services {
        if descriptor.ServiceType == serviceType {
            return c.createInstance(descriptor)
        }
    }

    return nil, fmt.Errorf("æœªæ‰¾åˆ°ç±»å‹ %s çš„æœåŠ¡", serviceType.String())
}

func (c *DIContainer) createInstance(descriptor *ServiceDescriptor) (interface{}, error) {
    // æ£€æŸ¥å¾ªç¯ä¾èµ–
    if c.building[descriptor.Name] {
        return nil, fmt.Errorf("æ£€æµ‹åˆ°å¾ªç¯ä¾èµ–: %s", descriptor.Name)
    }

    // å•ä¾‹æ¨¡å¼æ£€æŸ¥
    if descriptor.Lifetime == Singleton {
        c.mutex.RLock()
        if instance, exists := c.instances[descriptor.Name]; exists {
            c.mutex.RUnlock()
            return instance, nil
        }
        c.mutex.RUnlock()
    }

    // æ ‡è®°æ­£åœ¨æ„å»º
    c.building[descriptor.Name] = true
    defer delete(c.building, descriptor.Name)

    // åˆ›å»ºå®ä¾‹
    instance, err := descriptor.Factory(c)
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºæœåŠ¡ '%s' å¤±è´¥: %w", descriptor.Name, err)
    }

    // å•ä¾‹æ¨¡å¼ç¼“å­˜
    if descriptor.Lifetime == Singleton {
        c.mutex.Lock()
        c.instances[descriptor.Name] = instance
        c.mutex.Unlock()
    }

    return instance, nil
}

func (c *DIContainer) Build() error {
    c.mutex.Lock()
    defer c.mutex.Unlock()

    // éªŒè¯æ‰€æœ‰ä¾èµ–
    for name, descriptor := range c.services {
        for _, dep := range descriptor.Dependencies {
            if _, exists := c.services[dep]; !exists {
                return fmt.Errorf("æœåŠ¡ '%s' çš„ä¾èµ– '%s' æœªæ³¨å†Œ", name, dep)
            }
        }
    }

    c.built = true
    fmt.Println("ä¾èµ–æ³¨å…¥å®¹å™¨æ„å»ºå®Œæˆ")
    return nil
}

// 4. ç¤ºä¾‹æœåŠ¡æ¥å£å’Œå®ç°
type Logger interface {
    Log(message string)
    Error(message string)
}

type Database interface {
    Connect() error
    Query(sql string) ([]map[string]interface{}, error)
    Close() error
}

type UserRepository interface {
    GetUser(id int64) (*User, error)
    SaveUser(user *User) error
}

type UserService interface {
    CreateUser(name, email string) (*User, error)
    GetUser(id int64) (*User, error)
}

// å…·ä½“å®ç°
type ConsoleLogger struct {
    prefix string
}

func (cl *ConsoleLogger) Log(message string) {
    fmt.Printf("[%s] INFO: %s\n", cl.prefix, message)
}

func (cl *ConsoleLogger) Error(message string) {
    fmt.Printf("[%s] ERROR: %s\n", cl.prefix, message)
}

type MySQLDatabase struct {
    connectionString string
    logger          Logger
}

func (db *MySQLDatabase) Connect() error {
    db.logger.Log("è¿æ¥åˆ°MySQLæ•°æ®åº“: " + db.connectionString)
    return nil
}

func (db *MySQLDatabase) Query(sql string) ([]map[string]interface{}, error) {
    db.logger.Log("æ‰§è¡ŒSQLæŸ¥è¯¢: " + sql)
    return []map[string]interface{}{
        {"id": 1, "name": "å¼ ä¸‰", "email": "zhangsan@example.com"},
    }, nil
}

func (db *MySQLDatabase) Close() error {
    db.logger.Log("å…³é—­æ•°æ®åº“è¿æ¥")
    return nil
}

type DatabaseUserRepository struct {
    db     Database
    logger Logger
}

func (repo *DatabaseUserRepository) GetUser(id int64) (*User, error) {
    repo.logger.Log(fmt.Sprintf("è·å–ç”¨æˆ·: %d", id))

    results, err := repo.db.Query(fmt.Sprintf("SELECT * FROM users WHERE id = %d", id))
    if err != nil {
        return nil, err
    }

    if len(results) == 0 {
        return nil, fmt.Errorf("ç”¨æˆ·ä¸å­˜åœ¨")
    }

    result := results[0]
    return &User{
        ID:    int64(result["id"].(int)),
        Name:  result["name"].(string),
        Email: result["email"].(string),
    }, nil
}

func (repo *DatabaseUserRepository) SaveUser(user *User) error {
    repo.logger.Log(fmt.Sprintf("ä¿å­˜ç”¨æˆ·: %s", user.Name))

    sql := fmt.Sprintf("INSERT INTO users (name, email) VALUES ('%s', '%s')", user.Name, user.Email)
    _, err := repo.db.Query(sql)
    return err
}

type DefaultUserService struct {
    repo   UserRepository
    logger Logger
}

func (svc *DefaultUserService) CreateUser(name, email string) (*User, error) {
    svc.logger.Log(fmt.Sprintf("åˆ›å»ºç”¨æˆ·: %s", name))

    user := &User{
        ID:    time.Now().Unix(),
        Name:  name,
        Email: email,
    }

    if err := svc.repo.SaveUser(user); err != nil {
        svc.logger.Error(fmt.Sprintf("ä¿å­˜ç”¨æˆ·å¤±è´¥: %v", err))
        return nil, err
    }

    return user, nil
}

func (svc *DefaultUserService) GetUser(id int64) (*User, error) {
    svc.logger.Log(fmt.Sprintf("è·å–ç”¨æˆ·æœåŠ¡: %d", id))
    return svc.repo.GetUser(id)
}

type User struct {
    ID    int64  `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

// 5. æœåŠ¡é…ç½®
func ConfigureServices(container ServiceContainer) error {
    // æ³¨å†ŒLoggerï¼ˆå•ä¾‹ï¼‰
    err := container.RegisterSingleton("logger", func(c ServiceContainer) (interface{}, error) {
        return &ConsoleLogger{prefix: "APP"}, nil
    })
    if err != nil {
        return err
    }

    // æ³¨å†ŒDatabaseï¼ˆå•ä¾‹ï¼‰
    err = container.RegisterSingleton("database", func(c ServiceContainer) (interface{}, error) {
        logger, err := c.Resolve("logger")
        if err != nil {
            return nil, err
        }

        db := &MySQLDatabase{
            connectionString: "mysql://localhost:3306/mall",
            logger:          logger.(Logger),
        }

        if err := db.Connect(); err != nil {
            return nil, err
        }

        return db, nil
    })
    if err != nil {
        return err
    }

    // æ³¨å†ŒUserRepositoryï¼ˆå•ä¾‹ï¼‰
    err = container.RegisterSingleton("userRepository", func(c ServiceContainer) (interface{}, error) {
        db, err := c.Resolve("database")
        if err != nil {
            return nil, err
        }

        logger, err := c.Resolve("logger")
        if err != nil {
            return nil, err
        }

        return &DatabaseUserRepository{
            db:     db.(Database),
            logger: logger.(Logger),
        }, nil
    })
    if err != nil {
        return err
    }

    // æ³¨å†ŒUserServiceï¼ˆç¬æ€ï¼‰
    err = container.RegisterTransient("userService", func(c ServiceContainer) (interface{}, error) {
        repo, err := c.Resolve("userRepository")
        if err != nil {
            return nil, err
        }

        logger, err := c.Resolve("logger")
        if err != nil {
            return nil, err
        }

        return &DefaultUserService{
            repo:   repo.(UserRepository),
            logger: logger.(Logger),
        }, nil
    })
    if err != nil {
        return err
    }

    return container.Build()
}

// æµ‹è¯•å‡½æ•°
func TestExercise4() {
    fmt.Println("=== ç»ƒä¹ é¢˜4ï¼šä¾èµ–æ³¨å…¥å®¹å™¨ ===")

    container := NewDIContainer()

    // é…ç½®æœåŠ¡
    if err := ConfigureServices(container); err != nil {
        fmt.Printf("é…ç½®æœåŠ¡å¤±è´¥: %v\n", err)
        return
    }

    fmt.Println("\n1. è§£æç”¨æˆ·æœåŠ¡:")
    userService, err := container.Resolve("userService")
    if err != nil {
        fmt.Printf("è§£æç”¨æˆ·æœåŠ¡å¤±è´¥: %v\n", err)
        return
    }

    svc := userService.(UserService)

    // åˆ›å»ºç”¨æˆ·
    fmt.Println("\n2. åˆ›å»ºç”¨æˆ·:")
    user, err := svc.CreateUser("æå››", "lisi@example.com")
    if err != nil {
        fmt.Printf("åˆ›å»ºç”¨æˆ·å¤±è´¥: %v\n", err)
        return
    }

    fmt.Printf("ç”¨æˆ·åˆ›å»ºæˆåŠŸ: %+v\n", user)

    // è·å–ç”¨æˆ·
    fmt.Println("\n3. è·å–ç”¨æˆ·:")
    retrievedUser, err := svc.GetUser(1)
    if err != nil {
        fmt.Printf("è·å–ç”¨æˆ·å¤±è´¥: %v\n", err)
        return
    }

    fmt.Printf("è·å–ç”¨æˆ·æˆåŠŸ: %+v\n", retrievedUser)

    // æµ‹è¯•å•ä¾‹æ¨¡å¼
    fmt.Println("\n4. æµ‹è¯•å•ä¾‹æ¨¡å¼:")
    logger1, _ := container.Resolve("logger")
    logger2, _ := container.Resolve("logger")

    fmt.Printf("Loggerå®ä¾‹ç›¸åŒ: %t\n", logger1 == logger2)

    // æµ‹è¯•ç¬æ€æ¨¡å¼
    fmt.Println("\n5. æµ‹è¯•ç¬æ€æ¨¡å¼:")
    userService1, _ := container.Resolve("userService")
    userService2, _ := container.Resolve("userService")

    fmt.Printf("UserServiceå®ä¾‹ç›¸åŒ: %t\n", userService1 == userService2)
}

/*
è§£æè¯´æ˜ï¼š
1. å®¹å™¨è®¾è®¡ï¼šå®ç°äº†å®Œæ•´çš„ä¾èµ–æ³¨å…¥å®¹å™¨
2. ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼šæ”¯æŒå•ä¾‹ã€ç¬æ€ç­‰ç”Ÿå‘½å‘¨æœŸ
3. å¾ªç¯ä¾èµ–æ£€æµ‹ï¼šé˜²æ­¢æ— é™é€’å½’åˆ›å»º
4. è‡ªåŠ¨è£…é…ï¼šé€šè¿‡å·¥å‚å‡½æ•°è‡ªåŠ¨è§£æä¾èµ–
5. ç±»å‹å®‰å…¨ï¼šä½¿ç”¨æ¥å£ç¡®ä¿ç±»å‹å®‰å…¨

æ‰©å±•æ€è€ƒï¼š
- å¦‚ä½•å®ç°ä½œç”¨åŸŸç”Ÿå‘½å‘¨æœŸï¼Ÿ
- å¦‚ä½•æ”¯æŒæ³›å‹ä¾èµ–æ³¨å…¥ï¼Ÿ
- å¦‚ä½•å®ç°é…ç½®æ–‡ä»¶é©±åŠ¨çš„æœåŠ¡æ³¨å†Œï¼Ÿ
- å¦‚ä½•æ·»åŠ æœåŠ¡å¥åº·æ£€æŸ¥ï¼Ÿ
*/
```

### ç»ƒä¹ é¢˜5ï¼šæ’ä»¶ç³»ç»Ÿæ¶æ„ï¼ˆâ­â­â­â­â­ï¼‰

**é¢˜ç›®æè¿°ï¼š**
è®¾è®¡ä¸€ä¸ªå®Œæ•´çš„æ’ä»¶ç³»ç»Ÿï¼Œæ”¯æŒåŠ¨æ€åŠ è½½æ’ä»¶ã€æ’ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€æ’ä»¶é—´é€šä¿¡ã€é…ç½®ç®¡ç†ç­‰åŠŸèƒ½ã€‚è¦æ±‚æ”¯æŒçƒ­æ’æ‹”å’Œç‰ˆæœ¬ç®¡ç†ã€‚

```go
// ç»ƒä¹ é¢˜5ï¼šæ’ä»¶ç³»ç»Ÿæ¶æ„
package exercises

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// è§£ç­”ï¼š
// 1. æ’ä»¶æ ¸å¿ƒæ¥å£
type Plugin interface {
    GetInfo() *PluginInfo
    Initialize(ctx context.Context, config map[string]interface{}) error
    Start(ctx context.Context) error
    Stop(ctx context.Context) error
    Destroy(ctx context.Context) error
    GetStatus() PluginStatus
}

type PluginInfo struct {
    Name        string            `json:"name"`
    Version     string            `json:"version"`
    Description string            `json:"description"`
    Author      string            `json:"author"`
    Dependencies []string         `json:"dependencies"`
    Capabilities []string         `json:"capabilities"`
    Config      map[string]interface{} `json:"config"`
}

type PluginStatus int

const (
    StatusUnknown PluginStatus = iota
    StatusInitialized
    StatusStarted
    StatusStopped
    StatusError
)

func (s PluginStatus) String() string {
    switch s {
    case StatusInitialized:
        return "Initialized"
    case StatusStarted:
        return "Started"
    case StatusStopped:
        return "Stopped"
    case StatusError:
        return "Error"
    default:
        return "Unknown"
    }
}

// 2. æ’ä»¶ç®¡ç†å™¨æ¥å£
type PluginManager interface {
    RegisterPlugin(plugin Plugin) error
    UnregisterPlugin(name string) error
    StartPlugin(name string) error
    StopPlugin(name string) error
    GetPlugin(name string) (Plugin, error)
    ListPlugins() []*PluginInfo
    GetPluginStatus(name string) (PluginStatus, error)
}

// 3. æ’ä»¶é€šä¿¡æ¥å£
type MessageBus interface {
    Subscribe(topic string, handler MessageHandler) error
    Unsubscribe(topic string, handlerID string) error
    Publish(topic string, message *Message) error
    PublishAsync(topic string, message *Message) error
}

type MessageHandler interface {
    GetID() string
    Handle(ctx context.Context, message *Message) error
}

type Message struct {
    ID        string                 `json:"id"`
    Topic     string                 `json:"topic"`
    Source    string                 `json:"source"`
    Target    string                 `json:"target"`
    Type      string                 `json:"type"`
    Data      map[string]interface{} `json:"data"`
    Timestamp time.Time              `json:"timestamp"`
}

// 4. æ’ä»¶æ³¨å†Œè¡¨
type PluginRegistry struct {
    plugins map[string]Plugin
    status  map[string]PluginStatus
    configs map[string]map[string]interface{}
    mutex   sync.RWMutex
}

func NewPluginRegistry() *PluginRegistry {
    return &PluginRegistry{
        plugins: make(map[string]Plugin),
        status:  make(map[string]PluginStatus),
        configs: make(map[string]map[string]interface{}),
    }
}

func (pr *PluginRegistry) RegisterPlugin(plugin Plugin) error {
    pr.mutex.Lock()
    defer pr.mutex.Unlock()

    info := plugin.GetInfo()

    // æ£€æŸ¥æ’ä»¶æ˜¯å¦å·²å­˜åœ¨
    if _, exists := pr.plugins[info.Name]; exists {
        return fmt.Errorf("æ’ä»¶ %s å·²ç»æ³¨å†Œ", info.Name)
    }

    // æ£€æŸ¥ä¾èµ–
    for _, dep := range info.Dependencies {
        if _, exists := pr.plugins[dep]; !exists {
            return fmt.Errorf("æ’ä»¶ %s çš„ä¾èµ– %s æœªæ‰¾åˆ°", info.Name, dep)
        }
    }

    pr.plugins[info.Name] = plugin
    pr.status[info.Name] = StatusUnknown
    pr.configs[info.Name] = info.Config

    fmt.Printf("æ³¨å†Œæ’ä»¶: %s v%s\n", info.Name, info.Version)
    return nil
}

func (pr *PluginRegistry) UnregisterPlugin(name string) error {
    pr.mutex.Lock()
    defer pr.mutex.Unlock()

    plugin, exists := pr.plugins[name]
    if !exists {
        return fmt.Errorf("æ’ä»¶ %s æœªæ‰¾åˆ°", name)
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–æ’ä»¶ä¾èµ–æ­¤æ’ä»¶
    for pluginName, p := range pr.plugins {
        if pluginName == name {
            continue
        }

        info := p.GetInfo()
        for _, dep := range info.Dependencies {
            if dep == name {
                return fmt.Errorf("æ’ä»¶ %s è¢« %s ä¾èµ–ï¼Œæ— æ³•å¸è½½", name, pluginName)
            }
        }
    }

    // åœæ­¢æ’ä»¶
    if pr.status[name] == StatusStarted {
        plugin.Stop(context.Background())
    }

    // é”€æ¯æ’ä»¶
    plugin.Destroy(context.Background())

    delete(pr.plugins, name)
    delete(pr.status, name)
    delete(pr.configs, name)

    fmt.Printf("å¸è½½æ’ä»¶: %s\n", name)
    return nil
}

func (pr *PluginRegistry) StartPlugin(name string) error {
    pr.mutex.Lock()
    defer pr.mutex.Unlock()

    plugin, exists := pr.plugins[name]
    if !exists {
        return fmt.Errorf("æ’ä»¶ %s æœªæ‰¾åˆ°", name)
    }

    if pr.status[name] == StatusStarted {
        return fmt.Errorf("æ’ä»¶ %s å·²ç»å¯åŠ¨", name)
    }

    ctx := context.Background()

    // åˆå§‹åŒ–æ’ä»¶
    if pr.status[name] == StatusUnknown {
        if err := plugin.Initialize(ctx, pr.configs[name]); err != nil {
            pr.status[name] = StatusError
            return fmt.Errorf("åˆå§‹åŒ–æ’ä»¶ %s å¤±è´¥: %w", name, err)
        }
        pr.status[name] = StatusInitialized
    }

    // å¯åŠ¨æ’ä»¶
    if err := plugin.Start(ctx); err != nil {
        pr.status[name] = StatusError
        return fmt.Errorf("å¯åŠ¨æ’ä»¶ %s å¤±è´¥: %w", name, err)
    }

    pr.status[name] = StatusStarted
    fmt.Printf("å¯åŠ¨æ’ä»¶: %s\n", name)
    return nil
}

func (pr *PluginRegistry) StopPlugin(name string) error {
    pr.mutex.Lock()
    defer pr.mutex.Unlock()

    plugin, exists := pr.plugins[name]
    if !exists {
        return fmt.Errorf("æ’ä»¶ %s æœªæ‰¾åˆ°", name)
    }

    if pr.status[name] != StatusStarted {
        return fmt.Errorf("æ’ä»¶ %s æœªå¯åŠ¨", name)
    }

    if err := plugin.Stop(context.Background()); err != nil {
        pr.status[name] = StatusError
        return fmt.Errorf("åœæ­¢æ’ä»¶ %s å¤±è´¥: %w", name, err)
    }

    pr.status[name] = StatusStopped
    fmt.Printf("åœæ­¢æ’ä»¶: %s\n", name)
    return nil
}

func (pr *PluginRegistry) GetPlugin(name string) (Plugin, error) {
    pr.mutex.RLock()
    defer pr.mutex.RUnlock()

    plugin, exists := pr.plugins[name]
    if !exists {
        return nil, fmt.Errorf("æ’ä»¶ %s æœªæ‰¾åˆ°", name)
    }

    return plugin, nil
}

func (pr *PluginRegistry) ListPlugins() []*PluginInfo {
    pr.mutex.RLock()
    defer pr.mutex.RUnlock()

    var infos []*PluginInfo
    for _, plugin := range pr.plugins {
        infos = append(infos, plugin.GetInfo())
    }

    return infos
}

func (pr *PluginRegistry) GetPluginStatus(name string) (PluginStatus, error) {
    pr.mutex.RLock()
    defer pr.mutex.RUnlock()

    status, exists := pr.status[name]
    if !exists {
        return StatusUnknown, fmt.Errorf("æ’ä»¶ %s æœªæ‰¾åˆ°", name)
    }

    return status, nil
}

// 5. æ¶ˆæ¯æ€»çº¿å®ç°
type SimpleMsgBus struct {
    handlers map[string][]MessageHandler
    mutex    sync.RWMutex
}

func NewSimpleMsgBus() *SimpleMsgBus {
    return &SimpleMsgBus{
        handlers: make(map[string][]MessageHandler),
    }
}

func (mb *SimpleMsgBus) Subscribe(topic string, handler MessageHandler) error {
    mb.mutex.Lock()
    defer mb.mutex.Unlock()

    mb.handlers[topic] = append(mb.handlers[topic], handler)
    fmt.Printf("è®¢é˜…ä¸»é¢˜: %s, å¤„ç†å™¨: %s\n", topic, handler.GetID())
    return nil
}

func (mb *SimpleMsgBus) Unsubscribe(topic string, handlerID string) error {
    mb.mutex.Lock()
    defer mb.mutex.Unlock()

    handlers := mb.handlers[topic]
    for i, handler := range handlers {
        if handler.GetID() == handlerID {
            mb.handlers[topic] = append(handlers[:i], handlers[i+1:]...)
            fmt.Printf("å–æ¶ˆè®¢é˜…ä¸»é¢˜: %s, å¤„ç†å™¨: %s\n", topic, handlerID)
            return nil
        }
    }

    return fmt.Errorf("å¤„ç†å™¨ %s æœªè®¢é˜…ä¸»é¢˜ %s", handlerID, topic)
}

func (mb *SimpleMsgBus) Publish(topic string, message *Message) error {
    mb.mutex.RLock()
    handlers := make([]MessageHandler, len(mb.handlers[topic]))
    copy(handlers, mb.handlers[topic])
    mb.mutex.RUnlock()

    fmt.Printf("å‘å¸ƒæ¶ˆæ¯åˆ°ä¸»é¢˜: %s, å¤„ç†å™¨æ•°é‡: %d\n", topic, len(handlers))

    for _, handler := range handlers {
        if err := handler.Handle(context.Background(), message); err != nil {
            fmt.Printf("å¤„ç†å™¨ %s å¤„ç†æ¶ˆæ¯å¤±è´¥: %v\n", handler.GetID(), err)
        }
    }

    return nil
}

func (mb *SimpleMsgBus) PublishAsync(topic string, message *Message) error {
    mb.mutex.RLock()
    handlers := make([]MessageHandler, len(mb.handlers[topic]))
    copy(handlers, mb.handlers[topic])
    mb.mutex.RUnlock()

    fmt.Printf("å¼‚æ­¥å‘å¸ƒæ¶ˆæ¯åˆ°ä¸»é¢˜: %s, å¤„ç†å™¨æ•°é‡: %d\n", topic, len(handlers))

    for _, handler := range handlers {
        go func(h MessageHandler) {
            if err := h.Handle(context.Background(), message); err != nil {
                fmt.Printf("å¤„ç†å™¨ %s å¼‚æ­¥å¤„ç†æ¶ˆæ¯å¤±è´¥: %v\n", h.GetID(), err)
            }
        }(handler)
    }

    return nil
}

// 6. ç¤ºä¾‹æ’ä»¶å®ç°
type LoggerPlugin struct {
    info   *PluginInfo
    status PluginStatus
    config map[string]interface{}
    msgBus MessageBus
}

func NewLoggerPlugin(msgBus MessageBus) *LoggerPlugin {
    return &LoggerPlugin{
        info: &PluginInfo{
            Name:        "logger",
            Version:     "1.0.0",
            Description: "æ—¥å¿—è®°å½•æ’ä»¶",
            Author:      "System",
            Capabilities: []string{"logging", "file-output"},
            Config: map[string]interface{}{
                "level":  "info",
                "output": "console",
            },
        },
        status: StatusUnknown,
        msgBus: msgBus,
    }
}

func (lp *LoggerPlugin) GetInfo() *PluginInfo {
    return lp.info
}

func (lp *LoggerPlugin) Initialize(ctx context.Context, config map[string]interface{}) error {
    lp.config = config
    fmt.Printf("åˆå§‹åŒ–æ—¥å¿—æ’ä»¶ï¼Œé…ç½®: %v\n", config)

    // è®¢é˜…æ—¥å¿—æ¶ˆæ¯
    handler := &LogMessageHandler{id: "logger-handler"}
    lp.msgBus.Subscribe("log", handler)

    lp.status = StatusInitialized
    return nil
}

func (lp *LoggerPlugin) Start(ctx context.Context) error {
    fmt.Println("å¯åŠ¨æ—¥å¿—æ’ä»¶")
    lp.status = StatusStarted
    return nil
}

func (lp *LoggerPlugin) Stop(ctx context.Context) error {
    fmt.Println("åœæ­¢æ—¥å¿—æ’ä»¶")
    lp.status = StatusStopped
    return nil
}

func (lp *LoggerPlugin) Destroy(ctx context.Context) error {
    fmt.Println("é”€æ¯æ—¥å¿—æ’ä»¶")
    lp.msgBus.Unsubscribe("log", "logger-handler")
    return nil
}

func (lp *LoggerPlugin) GetStatus() PluginStatus {
    return lp.status
}

type LogMessageHandler struct {
    id string
}

func (lmh *LogMessageHandler) GetID() string {
    return lmh.id
}

func (lmh *LogMessageHandler) Handle(ctx context.Context, message *Message) error {
    level := message.Data["level"].(string)
    msg := message.Data["message"].(string)
    fmt.Printf("[%s] %s: %s\n", message.Timestamp.Format("15:04:05"), level, msg)
    return nil
}

// æ•°æ®åº“æ’ä»¶
type DatabasePlugin struct {
    info   *PluginInfo
    status PluginStatus
    config map[string]interface{}
    msgBus MessageBus
}

func NewDatabasePlugin(msgBus MessageBus) *DatabasePlugin {
    return &DatabasePlugin{
        info: &PluginInfo{
            Name:        "database",
            Version:     "1.0.0",
            Description: "æ•°æ®åº“è¿æ¥æ’ä»¶",
            Author:      "System",
            Dependencies: []string{"logger"},
            Capabilities: []string{"mysql", "postgresql"},
            Config: map[string]interface{}{
                "driver": "mysql",
                "host":   "localhost",
                "port":   3306,
            },
        },
        status: StatusUnknown,
        msgBus: msgBus,
    }
}

func (dp *DatabasePlugin) GetInfo() *PluginInfo {
    return dp.info
}

func (dp *DatabasePlugin) Initialize(ctx context.Context, config map[string]interface{}) error {
    dp.config = config

    // å‘é€æ—¥å¿—æ¶ˆæ¯
    logMsg := &Message{
        ID:     "db-init",
        Topic:  "log",
        Source: "database",
        Type:   "info",
        Data: map[string]interface{}{
            "level":   "INFO",
            "message": "åˆå§‹åŒ–æ•°æ®åº“æ’ä»¶",
        },
        Timestamp: time.Now(),
    }
    dp.msgBus.Publish("log", logMsg)

    dp.status = StatusInitialized
    return nil
}

func (dp *DatabasePlugin) Start(ctx context.Context) error {
    logMsg := &Message{
        ID:     "db-start",
        Topic:  "log",
        Source: "database",
        Type:   "info",
        Data: map[string]interface{}{
            "level":   "INFO",
            "message": "å¯åŠ¨æ•°æ®åº“æ’ä»¶",
        },
        Timestamp: time.Now(),
    }
    dp.msgBus.Publish("log", logMsg)

    dp.status = StatusStarted
    return nil
}

func (dp *DatabasePlugin) Stop(ctx context.Context) error {
    logMsg := &Message{
        ID:     "db-stop",
        Topic:  "log",
        Source: "database",
        Type:   "info",
        Data: map[string]interface{}{
            "level":   "INFO",
            "message": "åœæ­¢æ•°æ®åº“æ’ä»¶",
        },
        Timestamp: time.Now(),
    }
    dp.msgBus.Publish("log", logMsg)

    dp.status = StatusStopped
    return nil
}

func (dp *DatabasePlugin) Destroy(ctx context.Context) error {
    fmt.Println("é”€æ¯æ•°æ®åº“æ’ä»¶")
    return nil
}

func (dp *DatabasePlugin) GetStatus() PluginStatus {
    return dp.status
}

// æµ‹è¯•å‡½æ•°
func TestExercise5() {
    fmt.Println("=== ç»ƒä¹ é¢˜5ï¼šæ’ä»¶ç³»ç»Ÿæ¶æ„ ===")

    // åˆ›å»ºæ’ä»¶ç³»ç»Ÿç»„ä»¶
    registry := NewPluginRegistry()
    msgBus := NewSimpleMsgBus()

    // åˆ›å»ºæ’ä»¶
    loggerPlugin := NewLoggerPlugin(msgBus)
    dbPlugin := NewDatabasePlugin(msgBus)

    // æ³¨å†Œæ’ä»¶
    fmt.Println("1. æ³¨å†Œæ’ä»¶:")
    registry.RegisterPlugin(loggerPlugin)
    registry.RegisterPlugin(dbPlugin)

    // åˆ—å‡ºæ’ä»¶
    fmt.Println("\n2. æ’ä»¶åˆ—è¡¨:")
    plugins := registry.ListPlugins()
    for _, info := range plugins {
        fmt.Printf("- %s v%s: %s\n", info.Name, info.Version, info.Description)
        if len(info.Dependencies) > 0 {
            fmt.Printf("  ä¾èµ–: %v\n", info.Dependencies)
        }
        if len(info.Capabilities) > 0 {
            fmt.Printf("  èƒ½åŠ›: %v\n", info.Capabilities)
        }
    }

    // å¯åŠ¨æ’ä»¶
    fmt.Println("\n3. å¯åŠ¨æ’ä»¶:")
    registry.StartPlugin("logger")
    registry.StartPlugin("database")

    // æ£€æŸ¥çŠ¶æ€
    fmt.Println("\n4. æ’ä»¶çŠ¶æ€:")
    for _, info := range plugins {
        status, _ := registry.GetPluginStatus(info.Name)
        fmt.Printf("- %s: %s\n", info.Name, status)
    }

    // æµ‹è¯•æ’ä»¶é€šä¿¡
    fmt.Println("\n5. æµ‹è¯•æ’ä»¶é€šä¿¡:")
    testMsg := &Message{
        ID:     "test-msg",
        Topic:  "log",
        Source: "system",
        Type:   "info",
        Data: map[string]interface{}{
            "level":   "INFO",
            "message": "è¿™æ˜¯ä¸€æ¡æµ‹è¯•æ¶ˆæ¯",
        },
        Timestamp: time.Now(),
    }
    msgBus.Publish("log", testMsg)

    // åœæ­¢æ’ä»¶
    fmt.Println("\n6. åœæ­¢æ’ä»¶:")
    registry.StopPlugin("database")
    registry.StopPlugin("logger")

    // å¸è½½æ’ä»¶
    fmt.Println("\n7. å¸è½½æ’ä»¶:")
    registry.UnregisterPlugin("database")
    registry.UnregisterPlugin("logger")
}

/*
è§£æè¯´æ˜ï¼š
1. æ’ä»¶æ¶æ„ï¼šå®šä¹‰äº†å®Œæ•´çš„æ’ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†
2. ä¾èµ–ç®¡ç†ï¼šæ”¯æŒæ’ä»¶é—´ä¾èµ–å…³ç³»æ£€æŸ¥
3. æ¶ˆæ¯é€šä¿¡ï¼šå®ç°äº†æ’ä»¶é—´çš„æ¶ˆæ¯æ€»çº¿é€šä¿¡
4. çŠ¶æ€ç®¡ç†ï¼šè·Ÿè¸ªæ’ä»¶çš„è¿è¡ŒçŠ¶æ€
5. çƒ­æ’æ‹”ï¼šæ”¯æŒåŠ¨æ€åŠ è½½å’Œå¸è½½æ’ä»¶

æ‰©å±•æ€è€ƒï¼š
- å¦‚ä½•å®ç°æ’ä»¶çš„ç‰ˆæœ¬å…¼å®¹æ€§æ£€æŸ¥ï¼Ÿ
- å¦‚ä½•æ”¯æŒæ’ä»¶çš„é…ç½®çƒ­æ›´æ–°ï¼Ÿ
- å¦‚ä½•å®ç°æ’ä»¶çš„èµ„æºéš”ç¦»ï¼Ÿ
- å¦‚ä½•æ·»åŠ æ’ä»¶çš„æ€§èƒ½ç›‘æ§ï¼Ÿ
- å¦‚ä½•æ”¯æŒåˆ†å¸ƒå¼æ’ä»¶ç³»ç»Ÿï¼Ÿ
*/
```

---

## ğŸ“š ç« èŠ‚æ€»ç»“

æ­å–œä½ å®Œæˆäº†Goè¯­è¨€æ¥å£è®¾è®¡æ¨¡å¼çš„å­¦ä¹ ï¼ğŸ‰ è®©æˆ‘ä»¬æ¥æ€»ç»“ä¸€ä¸‹è¿™ä¸€ç« çš„æ ¸å¿ƒå†…å®¹ã€‚

### ğŸ¯ æ ¸å¿ƒçŸ¥è¯†ç‚¹å›é¡¾

#### 1. Goæ¥å£è®¾è®¡å“²å­¦ ğŸ›ï¸

```go
// Goæ¥å£è®¾è®¡çš„æ ¸å¿ƒåŸåˆ™
/*
1. "æ¥å—æ¥å£ï¼Œè¿”å›ç»“æ„ä½“" (Accept interfaces, return structs)
   - å‡½æ•°å‚æ•°ä½¿ç”¨æ¥å£ç±»å‹ï¼Œå¢åŠ çµæ´»æ€§
   - å‡½æ•°è¿”å›å€¼ä½¿ç”¨å…·ä½“ç±»å‹ï¼Œæä¾›æ˜ç¡®çš„API

2. æ¥å£éš”ç¦»åŸåˆ™ (Interface Segregation Principle)
   - æ¥å£åº”è¯¥å°è€Œä¸“ä¸€
   - å®¢æˆ·ç«¯ä¸åº”è¯¥ä¾èµ–å®ƒä¸éœ€è¦çš„æ¥å£

3. éšå¼å®ç° (Implicit Implementation)
   - æ— éœ€æ˜¾å¼å£°æ˜å®ç°æ¥å£
   - åªè¦å®ç°äº†æ¥å£çš„æ‰€æœ‰æ–¹æ³•å°±è‡ªåŠ¨æ»¡è¶³æ¥å£

4. ç»„åˆä¼˜äºç»§æ‰¿ (Composition over Inheritance)
   - é€šè¿‡æ¥å£ç»„åˆå®ç°å¤æ‚åŠŸèƒ½
   - é¿å…æ·±å±‚æ¬¡çš„ç»§æ‰¿å…³ç³»
*/

// ç¤ºä¾‹ï¼šä¼˜ç§€çš„æ¥å£è®¾è®¡
type Reader interface {
    Read([]byte) (int, error)
}

type Writer interface {
    Write([]byte) (int, error)
}

type ReadWriter interface {
    Reader
    Writer
}
```

#### 2. ç»å…¸è®¾è®¡æ¨¡å¼åœ¨Goä¸­çš„å®ç° ğŸ¨

| è®¾è®¡æ¨¡å¼ | Goå®ç°ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
|---------|-----------|---------|
| **å·¥å‚æ¨¡å¼** | ä½¿ç”¨å‡½æ•°è¿”å›æ¥å£ç±»å‹ | å¯¹è±¡åˆ›å»ºå¤æ‚æ—¶ |
| **ç­–ç•¥æ¨¡å¼** | æ¥å£+ç»“æ„ä½“å®ç° | ç®—æ³•å¯æ›¿æ¢æ—¶ |
| **è£…é¥°å™¨æ¨¡å¼** | æ¥å£åµŒå…¥+ç»„åˆ | åŠŸèƒ½åŠ¨æ€æ‰©å±• |
| **é€‚é…å™¨æ¨¡å¼** | æ¥å£è½¬æ¢ | ç³»ç»Ÿé›†æˆæ—¶ |
| **è§‚å¯Ÿè€…æ¨¡å¼** | æ¥å£+é€šé“ | äº‹ä»¶é©±åŠ¨ç³»ç»Ÿ |

#### 3. ä¾èµ–æ³¨å…¥å’Œæ§åˆ¶åè½¬ ğŸ’‰

```go
// ä¾èµ–æ³¨å…¥çš„ä¸‰ç§æ–¹å¼
type UserService struct {
    // 1. æ„é€ å‡½æ•°æ³¨å…¥ï¼ˆæ¨èï¼‰
    repo   UserRepository
    logger Logger
}

func NewUserService(repo UserRepository, logger Logger) *UserService {
    return &UserService{repo: repo, logger: logger}
}

// 2. æ¥å£æ³¨å…¥
type ServiceInjector interface {
    InjectUserRepository(repo UserRepository)
    InjectLogger(logger Logger)
}

// 3. å±æ€§æ³¨å…¥ï¼ˆä½¿ç”¨æ ‡ç­¾ï¼‰
type AutowiredService struct {
    Repo   UserRepository `inject:"true"`
    Logger Logger         `inject:"true"`
}
```

#### 4. æ¥å£ç»„åˆå’ŒåµŒå…¥ ğŸ”—

```go
// æ¥å£ç»„åˆçš„å¼ºå¤§ä¹‹å¤„
type ReadWriteCloser interface {
    io.Reader    // åµŒå…¥æ ‡å‡†æ¥å£
    io.Writer    // åµŒå…¥æ ‡å‡†æ¥å£
    io.Closer    // åµŒå…¥æ ‡å‡†æ¥å£
}

// å®ç°æ—¶åªéœ€å®ç°å„ä¸ªå°æ¥å£
type File struct {
    // ...
}

func (f *File) Read(p []byte) (n int, err error) { /* ... */ }
func (f *File) Write(p []byte) (n int, err error) { /* ... */ }
func (f *File) Close() error { /* ... */ }
// File è‡ªåŠ¨å®ç°äº† ReadWriteCloser æ¥å£
```

### ğŸš€ Goæ¥å£è®¾è®¡æœ€ä½³å®è·µæ¸…å•

#### âœ… åº”è¯¥åšçš„äº‹æƒ…

1. **è®¾è®¡å°æ¥å£**
   ```go
   // âœ… å¥½çš„è®¾è®¡
   type Reader interface {
       Read([]byte) (int, error)
   }

   type Writer interface {
       Write([]byte) (int, error)
   }
   ```

2. **ä½¿ç”¨æ ‡å‡†åº“æ¥å£**
   ```go
   // âœ… ä¼˜å…ˆä½¿ç”¨æ ‡å‡†æ¥å£
   func ProcessData(r io.Reader, w io.Writer) error {
       // ä¸æ ‡å‡†åº“å…¼å®¹
   }
   ```

3. **æ¥å—æ¥å£ï¼Œè¿”å›ç»“æ„ä½“**
   ```go
   // âœ… å‚æ•°ä½¿ç”¨æ¥å£
   func NewService(repo Repository) *Service {
       return &Service{repo: repo}  // è¿”å›å…·ä½“ç±»å‹
   }
   ```

4. **ä½¿ç”¨æ¥å£ç»„åˆ**
   ```go
   // âœ… é€šè¿‡ç»„åˆåˆ›å»ºå¤æ‚æ¥å£
   type ReadWriteSeeker interface {
       io.Reader
       io.Writer
       io.Seeker
   }
   ```

#### âŒ ä¸åº”è¯¥åšçš„äº‹æƒ…

1. **é¿å…å¤§æ¥å£**
   ```go
   // âŒ è¿åæ¥å£éš”ç¦»åŸåˆ™
   type BadService interface {
       CreateUser(user User) error
       UpdateUser(user User) error
       DeleteUser(id int) error
       SendEmail(to, subject, body string) error
       ProcessPayment(amount float64) error
       GenerateReport() ([]byte, error)
   }
   ```

2. **é¿å…æ»¥ç”¨ç©ºæ¥å£**
   ```go
   // âŒ ç±»å‹ä¸å®‰å…¨
   func BadFunction(data interface{}) interface{} {
       // éœ€è¦å¤§é‡ç±»å‹æ–­è¨€
   }

   // âœ… ä½¿ç”¨å…·ä½“ç±»å‹æˆ–æ³›å‹
   func GoodFunction[T any](data T) T {
       return data
   }
   ```

3. **é¿å…æ¥å£nilé™·é˜±**
   ```go
   // âŒ è¿”å›nilæŒ‡é’ˆç»™æ¥å£
   func BadGetError() error {
       var err *MyError = nil
       return err  // æ¥å£ä¸ä¸ºnilï¼
   }

   // âœ… è¿”å›æ˜ç¡®çš„nil
   func GoodGetError() error {
       var err *MyError = nil
       if err != nil {
           return err
       }
       return nil  // çœŸæ­£çš„nilæ¥å£
   }
   ```

### ğŸ”— ä¸å‰é¢ç« èŠ‚çš„çŸ¥è¯†è¿æ¥

#### ä¸ç»“æ„ä½“å’Œæ¥å£ç« èŠ‚çš„è”ç³»
- **ç»“æ„ä½“å®ç°æ¥å£**ï¼šé€šè¿‡æ–¹æ³•é›†å®ç°æ¥å£å¥‘çº¦
- **æ¥å£åµŒå…¥**ï¼šæ‰©å±•äº†ç»“æ„ä½“åµŒå…¥çš„æ¦‚å¿µåˆ°æ¥å£å±‚é¢
- **å¤šæ€å®ç°**ï¼šåŒä¸€æ¥å£çš„ä¸åŒå®ç°æä¾›ä¸åŒè¡Œä¸º

#### ä¸é”™è¯¯å¤„ç†ç« èŠ‚çš„è”ç³»
- **é”™è¯¯æ¥å£**ï¼š`error` æ˜¯Goä¸­æœ€é‡è¦çš„æ¥å£
- **è‡ªå®šä¹‰é”™è¯¯ç±»å‹**ï¼šå®ç°erroræ¥å£åˆ›å»ºä¸°å¯Œçš„é”™è¯¯ä¿¡æ¯
- **é”™è¯¯åŒ…è£…**ï¼šé€šè¿‡æ¥å£å®ç°é”™è¯¯é“¾

#### ä¸å¹¶å‘ç¼–ç¨‹ç« èŠ‚çš„è”ç³»
- **å¹¶å‘å®‰å…¨æ¥å£**ï¼šæ¥å£æ–¹æ³•çš„å¹¶å‘å®‰å…¨æ€§è®¾è®¡
- **é€šé“ä¸æ¥å£**ï¼šç»“åˆä½¿ç”¨å®ç°å¼‚æ­¥é€šä¿¡
- **Contextæ¥å£**ï¼šè´¯ç©¿æ•´ä¸ªè¯·æ±‚ç”Ÿå‘½å‘¨æœŸçš„ä¸Šä¸‹æ–‡ç®¡ç†

### ğŸ“ ä¸‹ä¸€æ­¥å­¦ä¹ å»ºè®®

#### ç«‹å³å®è·µ (æœ¬å‘¨å†…)
1. **é‡æ„ç°æœ‰ä»£ç **ï¼šå°†å¤§æ¥å£æ‹†åˆ†ä¸ºå°æ¥å£
2. **å®ç°è®¾è®¡æ¨¡å¼**ï¼šé€‰æ‹©1-2ä¸ªè®¾è®¡æ¨¡å¼åœ¨é¡¹ç›®ä¸­åº”ç”¨
3. **ç¼–å†™æ¥å£æµ‹è¯•**ï¼šä¸ºå…³é”®æ¥å£ç¼–å†™Mockæµ‹è¯•

#### æ·±å…¥å­¦ä¹  (æœ¬æœˆå†…)
1. **ç ”ç©¶æ ‡å‡†åº“**ï¼šæ·±å…¥å­¦ä¹ Goæ ‡å‡†åº“çš„æ¥å£è®¾è®¡
2. **æ€§èƒ½ä¼˜åŒ–**ï¼šåˆ†ææ¥å£è°ƒç”¨çš„æ€§èƒ½å½±å“
3. **æ¶æ„è®¾è®¡**ï¼šåœ¨ç³»ç»Ÿæ¶æ„ä¸­åˆç†ä½¿ç”¨æ¥å£

#### é«˜çº§è¿›é˜¶ (é•¿æœŸç›®æ ‡)
1. **æ’ä»¶ç³»ç»Ÿ**ï¼šè®¾è®¡å¯æ‰©å±•çš„æ’ä»¶æ¶æ„
2. **å¾®æœåŠ¡æ¥å£**ï¼šè®¾è®¡æœåŠ¡é—´çš„æ¥å£å¥‘çº¦
3. **å¼€æºè´¡çŒ®**ï¼šå‚ä¸Goå¼€æºé¡¹ç›®ï¼Œå­¦ä¹ æœ€ä½³å®è·µ

### ğŸŒŸ Goæ¥å£è®¾è®¡çš„ç‹¬ç‰¹ä¼˜åŠ¿

#### ç›¸æ¯”Javaçš„ä¼˜åŠ¿
```java
// Javaéœ€è¦æ˜¾å¼å®ç°
public class MyWriter implements Writer {
    @Override
    public void write(String data) { /* ... */ }
}
```

```go
// Goéšå¼å®ç°ï¼Œæ›´çµæ´»
type MyWriter struct{}

func (w MyWriter) Write(p []byte) (int, error) {
    // è‡ªåŠ¨å®ç°äº†io.Writeræ¥å£
}
```

#### ç›¸æ¯”Pythonçš„ä¼˜åŠ¿
```python
# Pythonè¿è¡Œæ—¶æ£€æŸ¥
def process_data(writer):
    if hasattr(writer, 'write'):
        writer.write(data)  # è¿è¡Œæ—¶å¯èƒ½å‡ºé”™
```

```go
// Goç¼–è¯‘æ—¶æ£€æŸ¥
func ProcessData(w io.Writer) error {
    _, err := w.Write(data)  // ç¼–è¯‘æ—¶ä¿è¯ç±»å‹å®‰å…¨
    return err
}
```

### ğŸ¯ æ€»ç»“æ„Ÿè¨€

Goè¯­è¨€çš„æ¥å£è®¾è®¡ä½“ç°äº†"ç®€å•è€Œå¼ºå¤§"çš„å“²å­¦ã€‚é€šè¿‡å°æ¥å£ã€éšå¼å®ç°å’Œç»„åˆè®¾è®¡ï¼ŒGoæä¾›äº†ä¸€ç§æ—¢çµæ´»åˆç±»å‹å®‰å…¨çš„æŠ½è±¡æœºåˆ¶ã€‚æŒæ¡æ¥å£è®¾è®¡æ¨¡å¼ï¼Œä¸ä»…èƒ½å†™å‡ºæ›´ä¼˜é›…çš„ä»£ç ï¼Œæ›´èƒ½è®¾è®¡å‡ºå¯æ‰©å±•ã€å¯ç»´æŠ¤çš„ç³»ç»Ÿæ¶æ„ã€‚

è®°ä½Goæ¥å£è®¾è®¡çš„é»„é‡‘æ³•åˆ™ï¼š
- **Keep interfaces small** - ä¿æŒæ¥å£å°å·§
- **Accept interfaces, return structs** - æ¥å—æ¥å£ï¼Œè¿”å›ç»“æ„ä½“
- **Composition over inheritance** - ç»„åˆä¼˜äºç»§æ‰¿
- **Design for testability** - ä¸ºå¯æµ‹è¯•æ€§è€Œè®¾è®¡

ç»§ç»­ä½ çš„Goè¯­è¨€å­¦ä¹ ä¹‹æ—…ï¼Œä¸‹ä¸€ç« æˆ‘ä»¬å°†æ¢ç´¢æ›´é«˜çº§çš„ä¸»é¢˜ã€‚åŠ æ²¹ï¼ğŸš€

---

**æœ¬ç« å®Œæˆæ ‡å¿—ï¼š**
- âœ… æŒæ¡Goæ¥å£è®¾è®¡å“²å­¦
- âœ… å®ç°ç»å…¸è®¾è®¡æ¨¡å¼
- âœ… ç†è§£ä¾èµ–æ³¨å…¥åŸç†
- âœ… ç†Ÿç»ƒä½¿ç”¨æ¥å£ç»„åˆ
- âœ… é¿å…å¸¸è§æ¥å£é™·é˜±
- âœ… å®Œæˆ5é“ç»¼åˆç»ƒä¹ 

**å­¦ä¹ æˆæœï¼š**
- ğŸ“– **ç†è®ºçŸ¥è¯†**ï¼šæ¥å£è®¾è®¡åŸç†å’Œæœ€ä½³å®è·µ
- ğŸ› ï¸ **å®è·µæŠ€èƒ½**ï¼šè®¾è®¡æ¨¡å¼å®ç°å’Œæ¥å£æµ‹è¯•
- ğŸ—ï¸ **æ¶æ„èƒ½åŠ›**ï¼šç³»ç»Ÿæ¥å£è®¾è®¡å’Œæ’ä»¶æ¶æ„
- ğŸ¯ **é¢è¯•å‡†å¤‡**ï¼šæ¥å£ç›¸å…³é¢è¯•é¢˜å’Œæ ‡å‡†ç­”æ¡ˆ

æ­å–œä½ å·²ç»æˆä¸ºGoæ¥å£è®¾è®¡çš„ä¸“å®¶ï¼ğŸ‰
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
