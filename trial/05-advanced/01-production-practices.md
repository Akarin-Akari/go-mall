# È´òÁ∫ßÁØáÁ¨¨‰∏ÄÁ´†ÔºöÁîü‰∫ßÂÆûË∑µ‰∏éËøêÁª¥ üöÄ

> *"‰ª£Á†ÅÂÜôÂæóÂ•Ω‰∏çÂ•ΩÔºåÁîü‰∫ßÁéØÂ¢ÉËØ¥‰∫ÜÁÆó„ÄÇÊéåÊè°Áîü‰∫ßÂÆûË∑µÔºåÂ∞±ÊéåÊè°‰∫Ü‰ªéÂºÄÂèëÂà∞ËøêÁª¥ÁöÑÂÆåÊï¥ÊäÄËÉΩÈìæÔºÅ"* üí™

## üìö Êú¨Á´†Â≠¶‰π†ÁõÆÊ†á

ÈÄöËøáÊú¨Á´†Â≠¶‰π†Ôºå‰Ω†Â∞ÜÊéåÊè°Ôºö

- üê≥ **ÂÆπÂô®ÂåñÈÉ®ÁΩ≤**ÔºöDockerÂÆπÂô®Âåñ„ÄÅKubernetesÁºñÊéí„ÄÅ‰∫ëÂéüÁîüÈÉ®ÁΩ≤
- üìä **ÁõëÊéß‰∏éÂèØËßÇÊµãÊÄß**ÔºöÊåáÊ†áÁõëÊéß„ÄÅÈìæË∑ØËøΩË∏™„ÄÅÊó•ÂøóËÅöÂêà„ÄÅÂëäË≠¶Á≥ªÁªü
- üîß **ÊÄßËÉΩ‰ºòÂåñ**ÔºöGoÁ®ãÂ∫èÊÄßËÉΩÂàÜÊûê„ÄÅÂÜÖÂ≠ò‰ºòÂåñ„ÄÅÂπ∂Âèë‰ºòÂåñ
- üõ°Ô∏è **ÂÆâÂÖ®ÂÆûË∑µ**ÔºöËÆ§ËØÅÊéàÊùÉ„ÄÅÊï∞ÊçÆÂä†ÂØÜ„ÄÅÂÆâÂÖ®Êâ´Êèè„ÄÅÊºèÊ¥ûÈò≤Êä§
- üìà **Êâ©Â±ïÊÄßËÆæËÆ°**ÔºöÊ∞¥Âπ≥Êâ©Â±ï„ÄÅË¥üËΩΩÂùáË°°„ÄÅÁºìÂ≠òÁ≠ñÁï•„ÄÅÊï∞ÊçÆÂ∫ì‰ºòÂåñ
- üîÑ **CI/CDÊµÅÊ∞¥Á∫ø**ÔºöËá™Âä®ÂåñÊûÑÂª∫„ÄÅÊµãËØï„ÄÅÈÉ®ÁΩ≤„ÄÅÂõûÊªö
- üö® **ÊïÖÈöúÂ§ÑÁêÜ**ÔºöÊïÖÈöúËØäÊñ≠„ÄÅÂ∫îÊÄ•ÂìçÂ∫î„ÄÅÁÅæÈöæÊÅ¢Â§ç
- üè¢ **‰ºÅ‰∏öÁ∫ßÂÆûË∑µ**ÔºöÁªìÂêàmall-goÈ°πÁõÆÁöÑÁîü‰∫ßÁéØÂ¢ÉÊúÄ‰Ω≥ÂÆûË∑µ

---

## üê≥ ÂÆπÂô®ÂåñÈÉ®ÁΩ≤

### DockerÂÆπÂô®ÂåñÂÆûË∑µ

```go
// DockerÂÆπÂô®ÂåñÈÖçÁΩÆ
package deployment

import (
    "context"
    "fmt"
    "os"
    "path/filepath"
)

// DockerÈÖçÁΩÆ
type DockerConfig struct {
    BaseImage    string            `json:"base_image"`
    WorkDir      string            `json:"work_dir"`
    ExposedPorts []int             `json:"exposed_ports"`
    Environment  map[string]string `json:"environment"`
    Volumes      []VolumeMount     `json:"volumes"`
    HealthCheck  HealthCheckConfig `json:"health_check"`
}

type VolumeMount struct {
    HostPath      string `json:"host_path"`
    ContainerPath string `json:"container_path"`
    ReadOnly      bool   `json:"read_only"`
}

type HealthCheckConfig struct {
    Command     []string `json:"command"`
    Interval    string   `json:"interval"`
    Timeout     string   `json:"timeout"`
    Retries     int      `json:"retries"`
    StartPeriod string   `json:"start_period"`
}

// ÁîüÊàêDockerfile
func GenerateDockerfile(config DockerConfig, appName string) string {
    dockerfile := fmt.Sprintf(`# Â§öÈò∂ÊÆµÊûÑÂª∫ - ÊûÑÂª∫Èò∂ÊÆµ
FROM golang:1.21-alpine AS builder

# ËÆæÁΩÆÂ∑•‰ΩúÁõÆÂΩï
WORKDIR /app

# ÂÆâË£ÖÂøÖË¶ÅÁöÑÂåÖ
RUN apk add --no-cache git ca-certificates tzdata

# Â§çÂà∂go modÊñá‰ª∂
COPY go.mod go.sum ./

# ‰∏ãËΩΩ‰æùËµñ
RUN go mod download

# Â§çÂà∂Ê∫ê‰ª£Á†Å
COPY . .

# ÊûÑÂª∫Â∫îÁî®
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o %s .

# ËøêË°åÈò∂ÊÆµ
FROM %s

# ÂÆâË£ÖcaËØÅ‰π¶ÂíåÊó∂Âå∫Êï∞ÊçÆ
RUN apk --no-cache add ca-certificates tzdata

# ËÆæÁΩÆÊó∂Âå∫
ENV TZ=Asia/Shanghai

# ÂàõÂª∫ÈùûrootÁî®Êà∑
RUN addgroup -g 1001 -S appgroup && \
    adduser -u 1001 -S appuser -G appgroup

# ËÆæÁΩÆÂ∑•‰ΩúÁõÆÂΩï
WORKDIR %s

# ‰ªéÊûÑÂª∫Èò∂ÊÆµÂ§çÂà∂‰∫åËøõÂà∂Êñá‰ª∂
COPY --from=builder /app/%s .

# Â§çÂà∂ÈÖçÁΩÆÊñá‰ª∂
COPY --from=builder /app/configs ./configs

# Êõ¥ÊîπÊñá‰ª∂ÊâÄÊúâËÄÖ
RUN chown -R appuser:appgroup .

# ÂàáÊç¢Âà∞ÈùûrootÁî®Êà∑
USER appuser

# Êö¥Èú≤Á´ØÂè£
`, appName, config.BaseImage, config.WorkDir, appName)

    // Ê∑ªÂä†Êö¥Èú≤Á´ØÂè£
    for _, port := range config.ExposedPorts {
        dockerfile += fmt.Sprintf("EXPOSE %d\n", port)
    }

    // Ê∑ªÂä†ÁéØÂ¢ÉÂèòÈáè
    for key, value := range config.Environment {
        dockerfile += fmt.Sprintf("ENV %s=%s\n", key, value)
    }

    // Ê∑ªÂä†ÂÅ•Â∫∑Ê£ÄÊü•
    if len(config.HealthCheck.Command) > 0 {
        dockerfile += fmt.Sprintf(`
# ÂÅ•Â∫∑Ê£ÄÊü•
HEALTHCHECK --interval=%s --timeout=%s --start-period=%s --retries=%d \
    CMD %s
`,
            config.HealthCheck.Interval,
            config.HealthCheck.Timeout,
            config.HealthCheck.StartPeriod,
            config.HealthCheck.Retries,
            config.HealthCheck.Command[0])
    }

    // Ê∑ªÂä†ÂêØÂä®ÂëΩ‰ª§
    dockerfile += fmt.Sprintf("\n# ÂêØÂä®Â∫îÁî®\nCMD [\"./%s\"]\n", appName)

    return dockerfile
}

// ÁîüÊàêdocker-compose.yml
func GenerateDockerCompose(services []ServiceConfig) string {
    compose := `version: '3.8'

services:
`

    for _, service := range services {
        compose += fmt.Sprintf(`  %s:
    build:
      context: .
      dockerfile: Dockerfile
    image: %s:latest
    container_name: %s
    restart: unless-stopped
    ports:
`, service.Name, service.Image, service.ContainerName)

        for _, port := range service.Ports {
            compose += fmt.Sprintf("      - \"%d:%d\"\n", port.Host, port.Container)
        }

        if len(service.Environment) > 0 {
            compose += "    environment:\n"
            for key, value := range service.Environment {
                compose += fmt.Sprintf("      - %s=%s\n", key, value)
            }
        }

        if len(service.Volumes) > 0 {
            compose += "    volumes:\n"
            for _, volume := range service.Volumes {
                compose += fmt.Sprintf("      - %s:%s", volume.HostPath, volume.ContainerPath)
                if volume.ReadOnly {
                    compose += ":ro"
                }
                compose += "\n"
            }
        }

        if len(service.DependsOn) > 0 {
            compose += "    depends_on:\n"
            for _, dep := range service.DependsOn {
                compose += fmt.Sprintf("      - %s\n", dep)
            }
        }

        compose += "\n"
    }

    // Ê∑ªÂä†ÁΩëÁªúÈÖçÁΩÆ
    compose += `networks:
  default:
    driver: bridge

volumes:
  postgres_data:
  redis_data:
`

    return compose
}

type ServiceConfig struct {
    Name          string            `json:"name"`
    Image         string            `json:"image"`
    ContainerName string            `json:"container_name"`
    Ports         []PortMapping     `json:"ports"`
    Environment   map[string]string `json:"environment"`
    Volumes       []VolumeMount     `json:"volumes"`
    DependsOn     []string          `json:"depends_on"`
}

type PortMapping struct {
    Host      int `json:"host"`
    Container int `json:"container"`
}

// Mall-GoÈ°πÁõÆÁöÑDockerÈÖçÁΩÆÁ§∫‰æã
func GetMallGoDockerConfig() []ServiceConfig {
    return []ServiceConfig{
        {
            Name:          "mall-go-api",
            Image:         "mall-go/api",
            ContainerName: "mall-go-api",
            Ports: []PortMapping{
                {Host: 8080, Container: 8080},
            },
            Environment: map[string]string{
                "GIN_MODE":     "release",
                "DB_HOST":      "postgres",
                "DB_PORT":      "5432",
                "REDIS_HOST":   "redis",
                "REDIS_PORT":   "6379",
                "LOG_LEVEL":    "info",
            },
            Volumes: []VolumeMount{
                {
                    HostPath:      "./logs",
                    ContainerPath: "/app/logs",
                    ReadOnly:      false,
                },
                {
                    HostPath:      "./configs",
                    ContainerPath: "/app/configs",
                    ReadOnly:      true,
                },
            },
            DependsOn: []string{"postgres", "redis"},
        },
        {
            Name:          "postgres",
            Image:         "postgres:15-alpine",
            ContainerName: "mall-go-postgres",
            Ports: []PortMapping{
                {Host: 5432, Container: 5432},
            },
            Environment: map[string]string{
                "POSTGRES_DB":       "mall_go",
                "POSTGRES_USER":     "mall_user",
                "POSTGRES_PASSWORD": "mall_password",
                "PGDATA":           "/var/lib/postgresql/data/pgdata",
            },
            Volumes: []VolumeMount{
                {
                    HostPath:      "postgres_data",
                    ContainerPath: "/var/lib/postgresql/data",
                    ReadOnly:      false,
                },
            },
        },
        {
            Name:          "redis",
            Image:         "redis:7-alpine",
            ContainerName: "mall-go-redis",
            Ports: []PortMapping{
                {Host: 6379, Container: 6379},
            },
            Volumes: []VolumeMount{
                {
                    HostPath:      "redis_data",
                    ContainerPath: "/data",
                    ReadOnly:      false,
                },
            },
        },
    }
}
```

### KubernetesÈÉ®ÁΩ≤ÂÆûË∑µ

```go
// KubernetesÈÉ®ÁΩ≤ÈÖçÁΩÆ
package k8s

import (
    "fmt"
    "strings"
)

// KubernetesËµÑÊ∫êÈÖçÁΩÆ
type K8sConfig struct {
    Namespace   string                 `json:"namespace"`
    Deployment  DeploymentConfig       `json:"deployment"`
    Service     ServiceConfig          `json:"service"`
    Ingress     IngressConfig          `json:"ingress"`
    ConfigMap   map[string]string      `json:"config_map"`
    Secret      map[string]string      `json:"secret"`
    HPA         HPAConfig              `json:"hpa"`
}

type DeploymentConfig struct {
    Name         string            `json:"name"`
    Image        string            `json:"image"`
    Replicas     int32             `json:"replicas"`
    Port         int32             `json:"port"`
    Resources    ResourceConfig    `json:"resources"`
    Environment  map[string]string `json:"environment"`
    HealthCheck  K8sHealthCheck    `json:"health_check"`
}

type ResourceConfig struct {
    Requests ResourceRequirements `json:"requests"`
    Limits   ResourceRequirements `json:"limits"`
}

type ResourceRequirements struct {
    CPU    string `json:"cpu"`
    Memory string `json:"memory"`
}

type K8sHealthCheck struct {
    LivenessProbe  ProbeConfig `json:"liveness_probe"`
    ReadinessProbe ProbeConfig `json:"readiness_probe"`
}

type ProbeConfig struct {
    Path                string `json:"path"`
    Port                int32  `json:"port"`
    InitialDelaySeconds int32  `json:"initial_delay_seconds"`
    PeriodSeconds       int32  `json:"period_seconds"`
    TimeoutSeconds      int32  `json:"timeout_seconds"`
    FailureThreshold    int32  `json:"failure_threshold"`
}

type ServiceConfig struct {
    Name     string        `json:"name"`
    Type     string        `json:"type"`
    Ports    []ServicePort `json:"ports"`
    Selector map[string]string `json:"selector"`
}

type ServicePort struct {
    Name       string `json:"name"`
    Port       int32  `json:"port"`
    TargetPort int32  `json:"target_port"`
    Protocol   string `json:"protocol"`
}

type IngressConfig struct {
    Name        string              `json:"name"`
    Host        string              `json:"host"`
    Paths       []IngressPath       `json:"paths"`
    TLS         []IngressTLS        `json:"tls"`
    Annotations map[string]string   `json:"annotations"`
}

type IngressPath struct {
    Path        string `json:"path"`
    PathType    string `json:"path_type"`
    ServiceName string `json:"service_name"`
    ServicePort int32  `json:"service_port"`
}

type IngressTLS struct {
    Hosts      []string `json:"hosts"`
    SecretName string   `json:"secret_name"`
}

type HPAConfig struct {
    Name                     string `json:"name"`
    MinReplicas              int32  `json:"min_replicas"`
    MaxReplicas              int32  `json:"max_replicas"`
    TargetCPUUtilization     int32  `json:"target_cpu_utilization"`
    TargetMemoryUtilization  int32  `json:"target_memory_utilization"`
}

// ÁîüÊàêKubernetes YAML
func GenerateK8sYAML(config K8sConfig) string {
    var yaml strings.Builder

    // Namespace
    yaml.WriteString(generateNamespace(config.Namespace))
    yaml.WriteString("---\n")

    // ConfigMap
    if len(config.ConfigMap) > 0 {
        yaml.WriteString(generateConfigMap(config.Namespace, config.Deployment.Name, config.ConfigMap))
        yaml.WriteString("---\n")
    }

    // Secret
    if len(config.Secret) > 0 {
        yaml.WriteString(generateSecret(config.Namespace, config.Deployment.Name, config.Secret))
        yaml.WriteString("---\n")
    }

    // Deployment
    yaml.WriteString(generateDeployment(config.Namespace, config.Deployment))
    yaml.WriteString("---\n")

    // Service
    yaml.WriteString(generateService(config.Namespace, config.Service))
    yaml.WriteString("---\n")

    // Ingress
    if config.Ingress.Name != "" {
        yaml.WriteString(generateIngress(config.Namespace, config.Ingress))
        yaml.WriteString("---\n")
    }

    // HPA
    if config.HPA.Name != "" {
        yaml.WriteString(generateHPA(config.Namespace, config.HPA))
    }

    return yaml.String()
}

func generateNamespace(name string) string {
    return fmt.Sprintf(`apiVersion: v1
kind: Namespace
metadata:
  name: %s
`, name)
}

func generateDeployment(namespace string, config DeploymentConfig) string {
    deployment := fmt.Sprintf(`apiVersion: apps/v1
kind: Deployment
metadata:
  name: %s
  namespace: %s
  labels:
    app: %s
spec:
  replicas: %d
  selector:
    matchLabels:
      app: %s
  template:
    metadata:
      labels:
        app: %s
    spec:
      containers:
      - name: %s
        image: %s
        ports:
        - containerPort: %d
        resources:
          requests:
            cpu: %s
            memory: %s
          limits:
            cpu: %s
            memory: %s
`, config.Name, namespace, config.Name, config.Replicas, config.Name, config.Name,
        config.Name, config.Image, config.Port,
        config.Resources.Requests.CPU, config.Resources.Requests.Memory,
        config.Resources.Limits.CPU, config.Resources.Limits.Memory)

    // Ê∑ªÂä†ÁéØÂ¢ÉÂèòÈáè
    if len(config.Environment) > 0 {
        deployment += "        env:\n"
        for key, value := range config.Environment {
            deployment += fmt.Sprintf("        - name: %s\n          value: \"%s\"\n", key, value)
        }
    }

    // Ê∑ªÂä†ÂÅ•Â∫∑Ê£ÄÊü•
    if config.HealthCheck.LivenessProbe.Path != "" {
        deployment += fmt.Sprintf(`        livenessProbe:
          httpGet:
            path: %s
            port: %d
          initialDelaySeconds: %d
          periodSeconds: %d
          timeoutSeconds: %d
          failureThreshold: %d
`, config.HealthCheck.LivenessProbe.Path, config.HealthCheck.LivenessProbe.Port,
            config.HealthCheck.LivenessProbe.InitialDelaySeconds,
            config.HealthCheck.LivenessProbe.PeriodSeconds,
            config.HealthCheck.LivenessProbe.TimeoutSeconds,
            config.HealthCheck.LivenessProbe.FailureThreshold)
    }

    if config.HealthCheck.ReadinessProbe.Path != "" {
        deployment += fmt.Sprintf(`        readinessProbe:
          httpGet:
            path: %s
            port: %d
          initialDelaySeconds: %d
          periodSeconds: %d
          timeoutSeconds: %d
          failureThreshold: %d
`, config.HealthCheck.ReadinessProbe.Path, config.HealthCheck.ReadinessProbe.Port,
            config.HealthCheck.ReadinessProbe.InitialDelaySeconds,
            config.HealthCheck.ReadinessProbe.PeriodSeconds,
            config.HealthCheck.ReadinessProbe.TimeoutSeconds,
            config.HealthCheck.ReadinessProbe.FailureThreshold)
    }

    return deployment
}

func generateService(namespace string, config ServiceConfig) string {
    service := fmt.Sprintf(`apiVersion: v1
kind: Service
metadata:
  name: %s
  namespace: %s
  labels:
    app: %s
spec:
  type: %s
  ports:
`, config.Name, namespace, config.Name, config.Type)

    for _, port := range config.Ports {
        service += fmt.Sprintf(`  - name: %s
    port: %d
    targetPort: %d
    protocol: %s
`, port.Name, port.Port, port.TargetPort, port.Protocol)
    }

    service += "  selector:\n"
    for key, value := range config.Selector {
        service += fmt.Sprintf("    %s: %s\n", key, value)
    }

    return service
}

func generateConfigMap(namespace, name string, data map[string]string) string {
    configMap := fmt.Sprintf(`apiVersion: v1
kind: ConfigMap
metadata:
  name: %s-config
  namespace: %s
data:
`, name, namespace)

    for key, value := range data {
        configMap += fmt.Sprintf("  %s: \"%s\"\n", key, value)
    }

    return configMap
}

func generateSecret(namespace, name string, data map[string]string) string {
    secret := fmt.Sprintf(`apiVersion: v1
kind: Secret
metadata:
  name: %s-secret
  namespace: %s
type: Opaque
data:
`, name, namespace)

    for key, value := range data {
        // Ê≥®ÊÑèÔºöÂÆûÈôÖ‰ΩøÁî®Êó∂ÈúÄË¶Åbase64ÁºñÁ†Å
        secret += fmt.Sprintf("  %s: %s\n", key, value)
    }

    return secret
}

func generateHPA(namespace string, config HPAConfig) string {
    return fmt.Sprintf(`apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: %s
  namespace: %s
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: %s
  minReplicas: %d
  maxReplicas: %d
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: %d
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: %d
`, config.Name, namespace, config.Name, config.MinReplicas, config.MaxReplicas,
        config.TargetCPUUtilization, config.TargetMemoryUtilization)
}
```

---

## üìä ÁõëÊéß‰∏éÂèØËßÇÊµãÊÄß

### PrometheusÁõëÊéßÈõÜÊàê

```go
// PrometheusÁõëÊéßÈõÜÊàê
package monitoring

import (
    "net/http"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

// ÁõëÊéßÊåáÊ†áÂÆö‰πâ
var (
    // HTTPËØ∑Ê±ÇËÆ°Êï∞Âô®
    httpRequestsTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "endpoint", "status_code"},
    )

    // HTTPËØ∑Ê±ÇÂª∂ËøüÁõ¥ÊñπÂõæ
    httpRequestDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "HTTP request duration in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "endpoint"},
    )

    // Êï∞ÊçÆÂ∫ìËøûÊé•Ê±†ÊåáÊ†á
    dbConnectionsInUse = promauto.NewGauge(
        prometheus.GaugeOpts{
            Name: "db_connections_in_use",
            Help: "Number of database connections currently in use",
        },
    )

    dbConnectionsIdle = promauto.NewGauge(
        prometheus.GaugeOpts{
            Name: "db_connections_idle",
            Help: "Number of idle database connections",
        },
    )

    // ‰∏öÂä°ÊåáÊ†á
    ordersTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "orders_total",
            Help: "Total number of orders",
        },
        []string{"status"},
    )

    orderAmount = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "order_amount",
            Help:    "Order amount distribution",
            Buckets: []float64{10, 50, 100, 500, 1000, 5000, 10000},
        },
        []string{"currency"},
    )

    // Á≥ªÁªüÊåáÊ†á
    goroutinesCount = promauto.NewGauge(
        prometheus.GaugeOpts{
            Name: "goroutines_count",
            Help: "Number of goroutines",
        },
    )

    memoryUsage = promauto.NewGauge(
        prometheus.GaugeOpts{
            Name: "memory_usage_bytes",
            Help: "Memory usage in bytes",
        },
    )
)

// Prometheus‰∏≠Èó¥‰ª∂
func PrometheusMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()

        // Â§ÑÁêÜËØ∑Ê±Ç
        c.Next()

        // ËÆ∞ÂΩïÊåáÊ†á
        duration := time.Since(start).Seconds()
        statusCode := c.Writer.Status()

        httpRequestsTotal.WithLabelValues(
            c.Request.Method,
            c.FullPath(),
            http.StatusText(statusCode),
        ).Inc()

        httpRequestDuration.WithLabelValues(
            c.Request.Method,
            c.FullPath(),
        ).Observe(duration)
    }
}

// ÁõëÊéßÊúçÂä°
type MonitoringService struct {
    registry *prometheus.Registry
}

func NewMonitoringService() *MonitoringService {
    return &MonitoringService{
        registry: prometheus.NewRegistry(),
    }
}

// ÂêØÂä®ÁõëÊéßÊúçÂä°
func (ms *MonitoringService) StartMetricsServer(port string) {
    http.Handle("/metrics", promhttp.Handler())
    go http.ListenAndServe(":"+port, nil)
}

// Êõ¥Êñ∞Á≥ªÁªüÊåáÊ†á
func (ms *MonitoringService) UpdateSystemMetrics() {
    go func() {
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for range ticker.C {
            // Êõ¥Êñ∞goroutineÊï∞Èáè
            goroutinesCount.Set(float64(runtime.NumGoroutine()))

            // Êõ¥Êñ∞ÂÜÖÂ≠ò‰ΩøÁî®
            var m runtime.MemStats
            runtime.ReadMemStats(&m)
            memoryUsage.Set(float64(m.Alloc))
        }
    }()
}

// ‰∏öÂä°ÊåáÊ†áËÆ∞ÂΩï
func RecordOrderCreated(status string, amount float64, currency string) {
    ordersTotal.WithLabelValues(status).Inc()
    orderAmount.WithLabelValues(currency).Observe(amount)
}

func UpdateDBConnectionMetrics(inUse, idle int) {
    dbConnectionsInUse.Set(float64(inUse))
    dbConnectionsIdle.Set(float64(idle))
}
```

### ÂàÜÂ∏ÉÂºèÈìæË∑ØËøΩË∏™

```go
// ÂàÜÂ∏ÉÂºèÈìæË∑ØËøΩË∏™
package tracing

import (
    "context"
    "fmt"
    "net/http"
    "time"

    "github.com/gin-gonic/gin"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/exporters/jaeger"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/resource"
    "go.opentelemetry.io/otel/sdk/trace"
    "go.opentelemetry.io/otel/semconv/v1.4.0"
    oteltrace "go.opentelemetry.io/otel/trace"
)

// ÈìæË∑ØËøΩË∏™ÈÖçÁΩÆ
type TracingConfig struct {
    ServiceName     string `json:"service_name"`
    ServiceVersion  string `json:"service_version"`
    JaegerEndpoint  string `json:"jaeger_endpoint"`
    SamplingRate    float64 `json:"sampling_rate"`
    Environment     string `json:"environment"`
}

// ÂàùÂßãÂåñÈìæË∑ØËøΩË∏™
func InitTracing(config TracingConfig) (func(), error) {
    // ÂàõÂª∫JaegerÂØºÂá∫Âô®
    exp, err := jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(config.JaegerEndpoint)))
    if err != nil {
        return nil, fmt.Errorf("failed to create jaeger exporter: %w", err)
    }

    // ÂàõÂª∫ËµÑÊ∫ê
    res, err := resource.New(context.Background(),
        resource.WithAttributes(
            semconv.ServiceNameKey.String(config.ServiceName),
            semconv.ServiceVersionKey.String(config.ServiceVersion),
            attribute.String("environment", config.Environment),
        ),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create resource: %w", err)
    }

    // ÂàõÂª∫ËøΩË∏™Êèê‰æõËÄÖ
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exp),
        trace.WithResource(res),
        trace.WithSampler(trace.TraceIDRatioBased(config.SamplingRate)),
    )

    // ËÆæÁΩÆÂÖ®Â±ÄËøΩË∏™Êèê‰æõËÄÖ
    otel.SetTracerProvider(tp)
    otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{},
        propagation.Baggage{},
    ))

    // ËøîÂõûÊ∏ÖÁêÜÂáΩÊï∞
    return func() {
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        tp.Shutdown(ctx)
    }, nil
}

// GinÈìæË∑ØËøΩË∏™‰∏≠Èó¥‰ª∂
func TracingMiddleware(serviceName string) gin.HandlerFunc {
    tracer := otel.Tracer(serviceName)

    return func(c *gin.Context) {
        // ‰ªéËØ∑Ê±ÇÂ§¥‰∏≠ÊèêÂèñËøΩË∏™‰∏ä‰∏ãÊñá
        ctx := otel.GetTextMapPropagator().Extract(c.Request.Context(), propagation.HeaderCarrier(c.Request.Header))

        // ÂàõÂª∫span
        ctx, span := tracer.Start(ctx, fmt.Sprintf("%s %s", c.Request.Method, c.FullPath()),
            oteltrace.WithAttributes(
                attribute.String("http.method", c.Request.Method),
                attribute.String("http.url", c.Request.URL.String()),
                attribute.String("http.scheme", c.Request.URL.Scheme),
                attribute.String("http.host", c.Request.Host),
                attribute.String("http.user_agent", c.Request.UserAgent()),
            ),
        )
        defer span.End()

        // Â∞Ü‰∏ä‰∏ãÊñá‰º†ÈÄíÁªôËØ∑Ê±Ç
        c.Request = c.Request.WithContext(ctx)

        // Â§ÑÁêÜËØ∑Ê±Ç
        c.Next()

        // ËÆ∞ÂΩïÂìçÂ∫î‰ø°ÊÅØ
        span.SetAttributes(
            attribute.Int("http.status_code", c.Writer.Status()),
            attribute.Int("http.response_size", c.Writer.Size()),
        )

        // Â¶ÇÊûúÊúâÈîôËØØÔºåËÆ∞ÂΩïÈîôËØØ‰ø°ÊÅØ
        if len(c.Errors) > 0 {
            span.SetAttributes(attribute.String("error", c.Errors.String()))
        }
    }
}

// Êï∞ÊçÆÂ∫ìËøΩË∏™Ë£ÖÈ•∞Âô®
type TracedDB struct {
    db     *sql.DB
    tracer oteltrace.Tracer
}

func NewTracedDB(db *sql.DB, serviceName string) *TracedDB {
    return &TracedDB{
        db:     db,
        tracer: otel.Tracer(serviceName + "-db"),
    }
}

func (tdb *TracedDB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    ctx, span := tdb.tracer.Start(ctx, "db.query",
        oteltrace.WithAttributes(
            attribute.String("db.statement", query),
            attribute.String("db.operation", "query"),
        ),
    )
    defer span.End()

    rows, err := tdb.db.QueryContext(ctx, query, args...)
    if err != nil {
        span.SetAttributes(attribute.String("error", err.Error()))
    }

    return rows, err
}

func (tdb *TracedDB) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
    ctx, span := tdb.tracer.Start(ctx, "db.exec",
        oteltrace.WithAttributes(
            attribute.String("db.statement", query),
            attribute.String("db.operation", "exec"),
        ),
    )
    defer span.End()

    result, err := tdb.db.ExecContext(ctx, query, args...)
    if err != nil {
        span.SetAttributes(attribute.String("error", err.Error()))
    }

    return result, err
}

// HTTPÂÆ¢Êà∑Á´ØËøΩË∏™
type TracedHTTPClient struct {
    client *http.Client
    tracer oteltrace.Tracer
}

func NewTracedHTTPClient(client *http.Client, serviceName string) *TracedHTTPClient {
    return &TracedHTTPClient{
        client: client,
        tracer: otel.Tracer(serviceName + "-http"),
    }
}

func (thc *TracedHTTPClient) Do(req *http.Request) (*http.Response, error) {
    ctx, span := thc.tracer.Start(req.Context(), fmt.Sprintf("HTTP %s", req.Method),
        oteltrace.WithAttributes(
            attribute.String("http.method", req.Method),
            attribute.String("http.url", req.URL.String()),
            attribute.String("http.scheme", req.URL.Scheme),
            attribute.String("http.host", req.URL.Host),
        ),
    )
    defer span.End()

    // Ê≥®ÂÖ•ËøΩË∏™‰∏ä‰∏ãÊñáÂà∞ËØ∑Ê±ÇÂ§¥
    otel.GetTextMapPropagator().Inject(ctx, propagation.HeaderCarrier(req.Header))

    // ÊâßË°åËØ∑Ê±Ç
    resp, err := thc.client.Do(req.WithContext(ctx))
    if err != nil {
        span.SetAttributes(attribute.String("error", err.Error()))
        return nil, err
    }

    // ËÆ∞ÂΩïÂìçÂ∫î‰ø°ÊÅØ
    span.SetAttributes(
        attribute.Int("http.status_code", resp.StatusCode),
        attribute.Int64("http.response_content_length", resp.ContentLength),
    )

    return resp, nil
}
```

---

## üîß ÊÄßËÉΩ‰ºòÂåñ

### GoÁ®ãÂ∫èÊÄßËÉΩÂàÜÊûê

```go
// GoÁ®ãÂ∫èÊÄßËÉΩÂàÜÊûê
package profiling

import (
    "context"
    "fmt"
    "net/http"
    _ "net/http/pprof"
    "runtime"
    "runtime/pprof"
    "time"
)

// ÊÄßËÉΩÂàÜÊûêÈÖçÁΩÆ
type ProfilingConfig struct {
    EnablePprof     bool   `json:"enable_pprof"`
    PprofPort       string `json:"pprof_port"`
    CPUProfilePath  string `json:"cpu_profile_path"`
    MemProfilePath  string `json:"mem_profile_path"`
    ProfileDuration time.Duration `json:"profile_duration"`
}

// ÊÄßËÉΩÂàÜÊûêÊúçÂä°
type ProfilingService struct {
    config ProfilingConfig
}

func NewProfilingService(config ProfilingConfig) *ProfilingService {
    return &ProfilingService{config: config}
}

// ÂêØÂä®pprofÊúçÂä°
func (ps *ProfilingService) StartPprofServer() {
    if !ps.config.EnablePprof {
        return
    }

    go func() {
        fmt.Printf("Starting pprof server on port %s\n", ps.config.PprofPort)
        if err := http.ListenAndServe(":"+ps.config.PprofPort, nil); err != nil {
            fmt.Printf("pprof server error: %v\n", err)
        }
    }()
}

// CPUÊÄßËÉΩÂàÜÊûê
func (ps *ProfilingService) StartCPUProfile() error {
    if ps.config.CPUProfilePath == "" {
        return fmt.Errorf("CPU profile path not configured")
    }

    f, err := os.Create(ps.config.CPUProfilePath)
    if err != nil {
        return fmt.Errorf("create CPU profile file: %w", err)
    }

    if err := pprof.StartCPUProfile(f); err != nil {
        f.Close()
        return fmt.Errorf("start CPU profile: %w", err)
    }

    // ÂÆöÊó∂ÂÅúÊ≠¢
    go func() {
        time.Sleep(ps.config.ProfileDuration)
        pprof.StopCPUProfile()
        f.Close()
        fmt.Printf("CPU profile saved to %s\n", ps.config.CPUProfilePath)
    }()

    return nil
}

// ÂÜÖÂ≠òÊÄßËÉΩÂàÜÊûê
func (ps *ProfilingService) WriteMemProfile() error {
    if ps.config.MemProfilePath == "" {
        return fmt.Errorf("memory profile path not configured")
    }

    f, err := os.Create(ps.config.MemProfilePath)
    if err != nil {
        return fmt.Errorf("create memory profile file: %w", err)
    }
    defer f.Close()

    runtime.GC() // Âº∫Âà∂ÂûÉÂúæÂõûÊî∂
    if err := pprof.WriteHeapProfile(f); err != nil {
        return fmt.Errorf("write heap profile: %w", err)
    }

    fmt.Printf("Memory profile saved to %s\n", ps.config.MemProfilePath)
    return nil
}

// ÊÄßËÉΩÁõëÊéßÊåáÊ†á
type PerformanceMetrics struct {
    Goroutines     int           `json:"goroutines"`
    MemoryAlloc    uint64        `json:"memory_alloc"`
    MemoryTotal    uint64        `json:"memory_total"`
    MemorySys      uint64        `json:"memory_sys"`
    GCCount        uint32        `json:"gc_count"`
    GCPauseTotal   time.Duration `json:"gc_pause_total"`
    LastGCTime     time.Time     `json:"last_gc_time"`
}

// Ëé∑ÂèñÊÄßËÉΩÊåáÊ†á
func GetPerformanceMetrics() PerformanceMetrics {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    return PerformanceMetrics{
        Goroutines:     runtime.NumGoroutine(),
        MemoryAlloc:    m.Alloc,
        MemoryTotal:    m.TotalAlloc,
        MemorySys:      m.Sys,
        GCCount:        m.NumGC,
        GCPauseTotal:   time.Duration(m.PauseTotalNs),
        LastGCTime:     time.Unix(0, int64(m.LastGC)),
    }
}

// ÊÄßËÉΩ‰ºòÂåñÂª∫ËÆÆ
type OptimizationSuggestion struct {
    Category    string `json:"category"`
    Issue       string `json:"issue"`
    Suggestion  string `json:"suggestion"`
    Priority    string `json:"priority"`
}

// ÂàÜÊûêÊÄßËÉΩÂπ∂ÁªôÂá∫Âª∫ËÆÆ
func AnalyzePerformance(metrics PerformanceMetrics) []OptimizationSuggestion {
    var suggestions []OptimizationSuggestion

    // Ê£ÄÊü•goroutineÊï∞Èáè
    if metrics.Goroutines > 10000 {
        suggestions = append(suggestions, OptimizationSuggestion{
            Category:   "Concurrency",
            Issue:      fmt.Sprintf("High goroutine count: %d", metrics.Goroutines),
            Suggestion: "Check for goroutine leaks, use worker pools to limit concurrency",
            Priority:   "High",
        })
    }

    // Ê£ÄÊü•ÂÜÖÂ≠ò‰ΩøÁî®
    if metrics.MemoryAlloc > 1024*1024*1024 { // 1GB
        suggestions = append(suggestions, OptimizationSuggestion{
            Category:   "Memory",
            Issue:      fmt.Sprintf("High memory usage: %d MB", metrics.MemoryAlloc/(1024*1024)),
            Suggestion: "Review memory allocations, use object pools, optimize data structures",
            Priority:   "High",
        })
    }

    // Ê£ÄÊü•GCÈ¢ëÁéá
    if metrics.GCCount > 1000 {
        suggestions = append(suggestions, OptimizationSuggestion{
            Category:   "GC",
            Issue:      fmt.Sprintf("Frequent GC: %d collections", metrics.GCCount),
            Suggestion: "Reduce allocations, reuse objects, tune GOGC parameter",
            Priority:   "Medium",
        })
    }

    return suggestions
}
```

### ÂÜÖÂ≠ò‰ºòÂåñÂÆûË∑µ

```go
// ÂÜÖÂ≠ò‰ºòÂåñÂÆûË∑µ
package optimization

import (
    "sync"
    "time"
)

// ÂØπË±°Ê±†‰ºòÂåñ
type ObjectPool struct {
    pool sync.Pool
}

func NewObjectPool(newFunc func() interface{}) *ObjectPool {
    return &ObjectPool{
        pool: sync.Pool{
            New: newFunc,
        },
    }
}

func (op *ObjectPool) Get() interface{} {
    return op.pool.Get()
}

func (op *ObjectPool) Put(obj interface{}) {
    op.pool.Put(obj)
}

// Â≠óÁ¨¶‰∏≤ÊûÑÂª∫Âô®Ê±†
var stringBuilderPool = sync.Pool{
    New: func() interface{} {
        return &strings.Builder{}
    },
}

// ‰ºòÂåñÁöÑÂ≠óÁ¨¶‰∏≤ÊãºÊé•
func OptimizedStringConcat(parts []string) string {
    builder := stringBuilderPool.Get().(*strings.Builder)
    defer func() {
        builder.Reset()
        stringBuilderPool.Put(builder)
    }()

    for _, part := range parts {
        builder.WriteString(part)
    }

    return builder.String()
}

// Â≠óËäÇÁºìÂÜ≤Ê±†
var byteBufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 0, 1024)
    },
}

// ‰ºòÂåñÁöÑÂ≠óËäÇÊìç‰Ωú
func OptimizedByteOperation(data []byte) []byte {
    buffer := byteBufferPool.Get().([]byte)
    defer byteBufferPool.Put(buffer[:0])

    // ÊâßË°åÂ≠óËäÇÊìç‰Ωú
    buffer = append(buffer, data...)
    // Â§ÑÁêÜÈÄªËæë...

    // ËøîÂõûÂâØÊú¨
    result := make([]byte, len(buffer))
    copy(result, buffer)
    return result
}

// ÂÜÖÂ≠òÂèãÂ•ΩÁöÑÂ§ßÊï∞ÊçÆÂ§ÑÁêÜ
type StreamProcessor struct {
    batchSize int
    processor func([]interface{}) error
}

func NewStreamProcessor(batchSize int, processor func([]interface{}) error) *StreamProcessor {
    return &StreamProcessor{
        batchSize: batchSize,
        processor: processor,
    }
}

func (sp *StreamProcessor) Process(data <-chan interface{}) error {
    batch := make([]interface{}, 0, sp.batchSize)

    for item := range data {
        batch = append(batch, item)

        if len(batch) >= sp.batchSize {
            if err := sp.processor(batch); err != nil {
                return err
            }
            batch = batch[:0] // ÈáçÁΩÆÂàáÁâá‰ΩÜ‰øùÁïôÂÆπÈáè
        }
    }

    // Â§ÑÁêÜÂâ©‰ΩôÊï∞ÊçÆ
    if len(batch) > 0 {
        return sp.processor(batch)
    }

    return nil
}

// ÁºìÂ≠ò‰ºòÂåñ
type LRUCache struct {
    capacity int
    cache    map[string]*CacheNode
    head     *CacheNode
    tail     *CacheNode
    mutex    sync.RWMutex
}

type CacheNode struct {
    key   string
    value interface{}
    prev  *CacheNode
    next  *CacheNode
    expiry time.Time
}

func NewLRUCache(capacity int) *LRUCache {
    head := &CacheNode{}
    tail := &CacheNode{}
    head.next = tail
    tail.prev = head

    return &LRUCache{
        capacity: capacity,
        cache:    make(map[string]*CacheNode),
        head:     head,
        tail:     tail,
    }
}

func (lru *LRUCache) Get(key string) (interface{}, bool) {
    lru.mutex.Lock()
    defer lru.mutex.Unlock()

    if node, exists := lru.cache[key]; exists {
        // Ê£ÄÊü•ËøáÊúü
        if time.Now().After(node.expiry) {
            lru.removeNode(node)
            delete(lru.cache, key)
            return nil, false
        }

        // ÁßªÂä®Âà∞Â§¥ÈÉ®
        lru.moveToHead(node)
        return node.value, true
    }

    return nil, false
}

func (lru *LRUCache) Put(key string, value interface{}, ttl time.Duration) {
    lru.mutex.Lock()
    defer lru.mutex.Unlock()

    if node, exists := lru.cache[key]; exists {
        // Êõ¥Êñ∞Áé∞ÊúâËäÇÁÇπ
        node.value = value
        node.expiry = time.Now().Add(ttl)
        lru.moveToHead(node)
    } else {
        // ÂàõÂª∫Êñ∞ËäÇÁÇπ
        newNode := &CacheNode{
            key:    key,
            value:  value,
            expiry: time.Now().Add(ttl),
        }

        lru.cache[key] = newNode
        lru.addToHead(newNode)

        // Ê£ÄÊü•ÂÆπÈáè
        if len(lru.cache) > lru.capacity {
            tail := lru.removeTail()
            delete(lru.cache, tail.key)
        }
    }
}

func (lru *LRUCache) moveToHead(node *CacheNode) {
    lru.removeNode(node)
    lru.addToHead(node)
}

func (lru *LRUCache) removeNode(node *CacheNode) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

func (lru *LRUCache) addToHead(node *CacheNode) {
    node.prev = lru.head
    node.next = lru.head.next
    lru.head.next.prev = node
    lru.head.next = node
}

func (lru *LRUCache) removeTail() *CacheNode {
    lastNode := lru.tail.prev
    lru.removeNode(lastNode)
    return lastNode
}
```

---

## üõ°Ô∏è ÂÆâÂÖ®ÂÆûË∑µ

### ËÆ§ËØÅÊéàÊùÉÁ≥ªÁªü

```go
// ËÆ§ËØÅÊéàÊùÉÁ≥ªÁªü
package security

import (
    "crypto/rand"
    "crypto/sha256"
    "encoding/base64"
    "fmt"
    "time"

    "github.com/golang-jwt/jwt/v5"
    "golang.org/x/crypto/bcrypt"
)

// JWTÈÖçÁΩÆ
type JWTConfig struct {
    SecretKey       string        `json:"secret_key"`
    AccessTokenTTL  time.Duration `json:"access_token_ttl"`
    RefreshTokenTTL time.Duration `json:"refresh_token_ttl"`
    Issuer          string        `json:"issuer"`
    Audience        string        `json:"audience"`
}

// JWTÂ£∞Êòé
type Claims struct {
    UserID   string   `json:"user_id"`
    Username string   `json:"username"`
    Roles    []string `json:"roles"`
    jwt.RegisteredClaims
}

// JWTÊúçÂä°
type JWTService struct {
    config JWTConfig
}

func NewJWTService(config JWTConfig) *JWTService {
    return &JWTService{config: config}
}

// ÁîüÊàêËÆøÈóÆ‰ª§Áâå
func (js *JWTService) GenerateAccessToken(userID, username string, roles []string) (string, error) {
    claims := Claims{
        UserID:   userID,
        Username: username,
        Roles:    roles,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(js.config.AccessTokenTTL)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            NotBefore: jwt.NewNumericDate(time.Now()),
            Issuer:    js.config.Issuer,
            Audience:  []string{js.config.Audience},
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(js.config.SecretKey))
}

// ÁîüÊàêÂà∑Êñ∞‰ª§Áâå
func (js *JWTService) GenerateRefreshToken(userID string) (string, error) {
    claims := jwt.RegisteredClaims{
        Subject:   userID,
        ExpiresAt: jwt.NewNumericDate(time.Now().Add(js.config.RefreshTokenTTL)),
        IssuedAt:  jwt.NewNumericDate(time.Now()),
        NotBefore: jwt.NewNumericDate(time.Now()),
        Issuer:    js.config.Issuer,
        Audience:  []string{js.config.Audience},
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(js.config.SecretKey))
}

// È™åËØÅ‰ª§Áâå
func (js *JWTService) ValidateToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
        }
        return []byte(js.config.SecretKey), nil
    })

    if err != nil {
        return nil, err
    }

    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }

    return nil, fmt.Errorf("invalid token")
}

// ÂØÜÁ†ÅÂä†ÂØÜÊúçÂä°
type PasswordService struct {
    cost int
}

func NewPasswordService(cost int) *PasswordService {
    if cost < bcrypt.MinCost {
        cost = bcrypt.DefaultCost
    }
    return &PasswordService{cost: cost}
}

// Âä†ÂØÜÂØÜÁ†Å
func (ps *PasswordService) HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), ps.cost)
    return string(bytes), err
}

// È™åËØÅÂØÜÁ†Å
func (ps *PasswordService) CheckPassword(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}

// ÁîüÊàêÂÆâÂÖ®ÈöèÊú∫Â≠óÁ¨¶‰∏≤
func GenerateSecureRandomString(length int) (string, error) {
    bytes := make([]byte, length)
    if _, err := rand.Read(bytes); err != nil {
        return "", err
    }
    return base64.URLEncoding.EncodeToString(bytes)[:length], nil
}

// APIÂØÜÈí•ÁÆ°ÁêÜ
type APIKeyService struct {
    keys map[string]APIKeyInfo
    mutex sync.RWMutex
}

type APIKeyInfo struct {
    UserID      string    `json:"user_id"`
    Permissions []string  `json:"permissions"`
    CreatedAt   time.Time `json:"created_at"`
    ExpiresAt   time.Time `json:"expires_at"`
    LastUsed    time.Time `json:"last_used"`
    IsActive    bool      `json:"is_active"`
}

func NewAPIKeyService() *APIKeyService {
    return &APIKeyService{
        keys: make(map[string]APIKeyInfo),
    }
}

// ÁîüÊàêAPIÂØÜÈí•
func (aks *APIKeyService) GenerateAPIKey(userID string, permissions []string, ttl time.Duration) (string, error) {
    // ÁîüÊàêÂØÜÈí•
    keyBytes := make([]byte, 32)
    if _, err := rand.Read(keyBytes); err != nil {
        return "", err
    }

    // ÂàõÂª∫ÂØÜÈí•ÂìàÂ∏å
    hash := sha256.Sum256(keyBytes)
    keyString := base64.URLEncoding.EncodeToString(hash[:])

    // Â≠òÂÇ®ÂØÜÈí•‰ø°ÊÅØ
    aks.mutex.Lock()
    defer aks.mutex.Unlock()

    aks.keys[keyString] = APIKeyInfo{
        UserID:      userID,
        Permissions: permissions,
        CreatedAt:   time.Now(),
        ExpiresAt:   time.Now().Add(ttl),
        IsActive:    true,
    }

    return keyString, nil
}

// È™åËØÅAPIÂØÜÈí•
func (aks *APIKeyService) ValidateAPIKey(key string) (*APIKeyInfo, error) {
    aks.mutex.RLock()
    defer aks.mutex.RUnlock()

    keyInfo, exists := aks.keys[key]
    if !exists {
        return nil, fmt.Errorf("invalid API key")
    }

    if !keyInfo.IsActive {
        return nil, fmt.Errorf("API key is inactive")
    }

    if time.Now().After(keyInfo.ExpiresAt) {
        return nil, fmt.Errorf("API key has expired")
    }

    // Êõ¥Êñ∞ÊúÄÂêé‰ΩøÁî®Êó∂Èó¥
    keyInfo.LastUsed = time.Now()
    aks.keys[key] = keyInfo

    return &keyInfo, nil
}

// ÊùÉÈôêÊ£ÄÊü•
func (aks *APIKeyService) CheckPermission(key, permission string) bool {
    keyInfo, err := aks.ValidateAPIKey(key)
    if err != nil {
        return false
    }

    for _, perm := range keyInfo.Permissions {
        if perm == permission || perm == "*" {
            return true
        }
    }

    return false
}
```

---

## üîÑ CI/CDÊµÅÊ∞¥Á∫ø

### GitHub ActionsÈÖçÁΩÆ

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  GO_VERSION: '1.21'
  DOCKER_REGISTRY: 'your-registry.com'
  IMAGE_NAME: 'mall-go'

jobs:
  # ‰ª£Á†ÅË¥®ÈáèÊ£ÄÊü•
  lint:
    name: Code Linting
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: golangci-lint
      uses: golangci/golangci-lint-action@v3
      with:
        version: latest
        args: --timeout=5m

    - name: Go vet
      run: go vet ./...

    - name: Go fmt
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "Code is not formatted properly"
          gofmt -s -l .
          exit 1
        fi

  # ÂÆâÂÖ®Êâ´Êèè
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Run Gosec Security Scanner
      uses: securecodewarrior/github-action-gosec@master
      with:
        args: '-fmt sarif -out gosec.sarif ./...'

    - name: Upload SARIF file
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: gosec.sarif

  # ÂçïÂÖÉÊµãËØï
  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
    - uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Download dependencies
      run: go mod download

    - name: Run tests
      run: |
        go test -v -race -coverprofile=coverage.out ./...
        go tool cover -html=coverage.out -o coverage.html
      env:
        DB_HOST: localhost
        DB_PORT: 5432
        DB_USER: postgres
        DB_PASSWORD: postgres
        DB_NAME: test_db
        REDIS_HOST: localhost
        REDIS_PORT: 6379

    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out
        flags: unittests
        name: codecov-umbrella

  # ÊûÑÂª∫ÂíåÊé®ÈÄÅDockerÈïúÂÉè
  build:
    name: Build and Push
    runs-on: ubuntu-latest
    needs: [lint, security, test]
    if: github.ref == 'refs/heads/main'

    steps:
    - uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # ÈÉ®ÁΩ≤Âà∞ÊµãËØïÁéØÂ¢É
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
    - uses: actions/checkout@v4

    - name: Deploy to Kubernetes
      uses: azure/k8s-deploy@v1
      with:
        manifests: |
          k8s/staging/deployment.yaml
          k8s/staging/service.yaml
          k8s/staging/ingress.yaml
        images: |
          ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        kubectl-version: 'latest'

  # ÈÉ®ÁΩ≤Âà∞Áîü‰∫ßÁéØÂ¢É
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
    - uses: actions/checkout@v4

    - name: Deploy to Kubernetes
      uses: azure/k8s-deploy@v1
      with:
        manifests: |
          k8s/production/deployment.yaml
          k8s/production/service.yaml
          k8s/production/ingress.yaml
        images: |
          ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        kubectl-version: 'latest'

    - name: Run smoke tests
      run: |
        # Á≠âÂæÖÈÉ®ÁΩ≤ÂÆåÊàê
        sleep 60
        # ÊâßË°åÂÜíÁÉüÊµãËØï
        curl -f https://api.mall-go.com/health || exit 1
        curl -f https://api.mall-go.com/metrics || exit 1
```

### ÈÉ®ÁΩ≤ËÑöÊú¨

```go
// ÈÉ®ÁΩ≤ËÑöÊú¨ÁîüÊàêÂô®
package deployment

import (
    "fmt"
    "os"
    "text/template"
)

// ÈÉ®ÁΩ≤ÈÖçÁΩÆ
type DeploymentScript struct {
    AppName        string `json:"app_name"`
    Environment    string `json:"environment"`
    DockerImage    string `json:"docker_image"`
    Port           int    `json:"port"`
    HealthCheckURL string `json:"health_check_url"`
    BackupCount    int    `json:"backup_count"`
}

// ÁîüÊàêÈÉ®ÁΩ≤ËÑöÊú¨
func GenerateDeployScript(config DeploymentScript) string {
    scriptTemplate := `#!/bin/bash

# ÈÉ®ÁΩ≤ËÑöÊú¨ - {{.AppName}} ({{.Environment}})
set -e

APP_NAME="{{.AppName}}"
ENVIRONMENT="{{.Environment}}"
DOCKER_IMAGE="{{.DockerImage}}"
PORT={{.Port}}
HEALTH_CHECK_URL="{{.HealthCheckURL}}"
BACKUP_COUNT={{.BackupCount}}

echo "ÂºÄÂßãÈÉ®ÁΩ≤ $APP_NAME Âà∞ $ENVIRONMENT ÁéØÂ¢É..."

# 1. ÊãâÂèñÊúÄÊñ∞ÈïúÂÉè
echo "ÊãâÂèñDockerÈïúÂÉè..."
docker pull $DOCKER_IMAGE

# 2. Â§á‰ªΩÂΩìÂâçÁâàÊú¨
echo "Â§á‰ªΩÂΩìÂâçÁâàÊú¨..."
if docker ps -q -f name=$APP_NAME > /dev/null; then
    BACKUP_NAME="${APP_NAME}_backup_$(date +%Y%m%d_%H%M%S)"
    docker commit $APP_NAME $BACKUP_NAME
    echo "Â§á‰ªΩÂÆåÊàê: $BACKUP_NAME"

    # Ê∏ÖÁêÜÊóßÂ§á‰ªΩ
    OLD_BACKUPS=$(docker images --format "table {{.Repository}}" | grep "${APP_NAME}_backup" | tail -n +$((BACKUP_COUNT + 1)))
    if [ ! -z "$OLD_BACKUPS" ]; then
        echo "Ê∏ÖÁêÜÊóßÂ§á‰ªΩ..."
        echo "$OLD_BACKUPS" | xargs -r docker rmi
    fi
fi

# 3. ÂÅúÊ≠¢ÊóßÂÆπÂô®
echo "ÂÅúÊ≠¢ÊóßÂÆπÂô®..."
if docker ps -q -f name=$APP_NAME > /dev/null; then
    docker stop $APP_NAME
    docker rm $APP_NAME
fi

# 4. ÂêØÂä®Êñ∞ÂÆπÂô®
echo "ÂêØÂä®Êñ∞ÂÆπÂô®..."
docker run -d \
    --name $APP_NAME \
    --restart unless-stopped \
    -p $PORT:$PORT \
    -e ENVIRONMENT=$ENVIRONMENT \
    --network mall-go-network \
    $DOCKER_IMAGE

# 5. ÂÅ•Â∫∑Ê£ÄÊü•
echo "ÊâßË°åÂÅ•Â∫∑Ê£ÄÊü•..."
RETRY_COUNT=0
MAX_RETRIES=30

while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
    if curl -f $HEALTH_CHECK_URL > /dev/null 2>&1; then
        echo "ÂÅ•Â∫∑Ê£ÄÊü•ÈÄöËøá!"
        break
    fi

    echo "Á≠âÂæÖÂ∫îÁî®ÂêØÂä®... ($((RETRY_COUNT + 1))/$MAX_RETRIES)"
    sleep 10
    RETRY_COUNT=$((RETRY_COUNT + 1))
done

if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
    echo "ÂÅ•Â∫∑Ê£ÄÊü•Â§±Ë¥•ÔºåÂºÄÂßãÂõûÊªö..."

    # ÂÅúÊ≠¢Â§±Ë¥•ÁöÑÂÆπÂô®
    docker stop $APP_NAME
    docker rm $APP_NAME

    # ÊÅ¢Â§çÂ§á‰ªΩ
    if [ ! -z "$BACKUP_NAME" ]; then
        docker run -d \
            --name $APP_NAME \
            --restart unless-stopped \
            -p $PORT:$PORT \
            -e ENVIRONMENT=$ENVIRONMENT \
            --network mall-go-network \
            $BACKUP_NAME
        echo "ÂõûÊªöÂÆåÊàê"
    fi

    exit 1
fi

# 6. Ê∏ÖÁêÜÊó†Áî®ÈïúÂÉè
echo "Ê∏ÖÁêÜÊó†Áî®ÈïúÂÉè..."
docker image prune -f

echo "ÈÉ®ÁΩ≤ÂÆåÊàê!"
echo "Â∫îÁî®Áä∂ÊÄÅ: $(docker ps --format 'table {{.Names}}\t{{.Status}}' | grep $APP_NAME)"
echo "ËÆøÈóÆÂú∞ÂùÄ: $HEALTH_CHECK_URL"
`

    tmpl, _ := template.New("deploy").Parse(scriptTemplate)
    var result strings.Builder
    tmpl.Execute(&result, config)
    return result.String()
}

// ÁîüÊàêKubernetesÈÉ®ÁΩ≤ËÑöÊú¨
func GenerateK8sDeployScript(namespace, appName, image string) string {
    return fmt.Sprintf(`#!/bin/bash

# KubernetesÈÉ®ÁΩ≤ËÑöÊú¨
set -e

NAMESPACE="%s"
APP_NAME="%s"
IMAGE="%s"

echo "ÂºÄÂßãÈÉ®ÁΩ≤Âà∞Kubernetes..."

# 1. ÂàõÂª∫ÂëΩÂêçÁ©∫Èó¥ÔºàÂ¶ÇÊûú‰∏çÂ≠òÂú®Ôºâ
kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

# 2. Â∫îÁî®ÈÖçÁΩÆ
echo "Â∫îÁî®ConfigMapÂíåSecret..."
kubectl apply -f k8s/configmap.yaml -n $NAMESPACE
kubectl apply -f k8s/secret.yaml -n $NAMESPACE

# 3. Êõ¥Êñ∞ÈÉ®ÁΩ≤
echo "Êõ¥Êñ∞Deployment..."
kubectl set image deployment/$APP_NAME $APP_NAME=$IMAGE -n $NAMESPACE

# 4. Á≠âÂæÖÈÉ®ÁΩ≤ÂÆåÊàê
echo "Á≠âÂæÖÈÉ®ÁΩ≤ÂÆåÊàê..."
kubectl rollout status deployment/$APP_NAME -n $NAMESPACE --timeout=300s

# 5. È™åËØÅÈÉ®ÁΩ≤
echo "È™åËØÅÈÉ®ÁΩ≤..."
kubectl get pods -n $NAMESPACE -l app=$APP_NAME

# 6. Ê£ÄÊü•ÊúçÂä°Áä∂ÊÄÅ
echo "Ê£ÄÊü•ÊúçÂä°Áä∂ÊÄÅ..."
kubectl get svc -n $NAMESPACE -l app=$APP_NAME

echo "ÈÉ®ÁΩ≤ÂÆåÊàê!"
`, namespace, appName, image)
}
```

---

## üéØ Èù¢ËØïÂ∏∏ËÄÉÁÇπ

### 1. Áîü‰∫ßÁéØÂ¢ÉÈÉ®ÁΩ≤ÂíåËøêÁª¥

**ÈóÆÈ¢òÔºö** Â¶Ç‰Ωï‰øùËØÅGoÂ∫îÁî®Âú®Áîü‰∫ßÁéØÂ¢ÉÁöÑÁ®≥ÂÆöÊÄßÂíåÂèØÈù†ÊÄßÔºü

**Á≠îÊ°àÔºö**
```go
/*
Áîü‰∫ßÁéØÂ¢ÉÁ®≥ÂÆöÊÄß‰øùËØÅÊé™ÊñΩÔºö

1. ÂÆπÂô®ÂåñÈÉ®ÁΩ≤
   - ‰ΩøÁî®DockerÂÆπÂô®ÂåñÔºå‰øùËØÅÁéØÂ¢É‰∏ÄËá¥ÊÄß
   - Â§öÈò∂ÊÆµÊûÑÂª∫ÔºåÂáèÂ∞èÈïúÂÉè‰ΩìÁßØ
   - ÂÅ•Â∫∑Ê£ÄÊü•ÂíåËá™Âä®ÈáçÂêØ
   - ËµÑÊ∫êÈôêÂà∂ÂíåÈÖçÈ¢ùÁÆ°ÁêÜ

2. ÁõëÊéßÂíåÂèØËßÇÊµãÊÄß
   - ÊåáÊ†áÁõëÊéßÔºöCPU„ÄÅÂÜÖÂ≠ò„ÄÅÁΩëÁªú„ÄÅ‰∏öÂä°ÊåáÊ†á
   - Êó•ÂøóËÅöÂêàÔºöÁªìÊûÑÂåñÊó•Âøó„ÄÅÈõÜ‰∏≠Êî∂ÈõÜ
   - ÈìæË∑ØËøΩË∏™ÔºöÂàÜÂ∏ÉÂºèËØ∑Ê±ÇËøΩË∏™
   - ÂëäË≠¶Á≥ªÁªüÔºöÂèäÊó∂ÂèëÁé∞ÂíåÂìçÂ∫îÈóÆÈ¢ò

3. È´òÂèØÁî®Êû∂ÊûÑ
   - Ë¥üËΩΩÂùáË°°ÔºöÂ§öÂÆû‰æãÈÉ®ÁΩ≤
   - ÊïÖÈöúËΩ¨ÁßªÔºöËá™Âä®ÂàáÊç¢ÂíåÊÅ¢Â§ç
   - Êï∞ÊçÆÂ§á‰ªΩÔºöÂÆöÊúüÂ§á‰ªΩÂíåÊÅ¢Â§çÊµãËØï
   - ÁÅæÈöæÊÅ¢Â§çÔºöË∑®Âå∫ÂüüÈÉ®ÁΩ≤

4. ÊÄßËÉΩ‰ºòÂåñ
   - ÂÜÖÂ≠òÁÆ°ÁêÜÔºöÂØπË±°Ê±†„ÄÅÂÜÖÂ≠òÂ§çÁî®
   - Âπ∂ÂèëÊéßÂà∂ÔºögoroutineÊ±†„ÄÅÈôêÊµÅ
   - ÁºìÂ≠òÁ≠ñÁï•ÔºöÂ§öÁ∫ßÁºìÂ≠ò„ÄÅÁºìÂ≠òÈ¢ÑÁÉ≠
   - Êï∞ÊçÆÂ∫ì‰ºòÂåñÔºöËøûÊé•Ê±†„ÄÅÊü•ËØ¢‰ºòÂåñ

5. ÂÆâÂÖ®Èò≤Êä§
   - ËÆ§ËØÅÊéàÊùÉÔºöJWT„ÄÅRBAC
   - Êï∞ÊçÆÂä†ÂØÜÔºö‰º†ËæìÂä†ÂØÜ„ÄÅÂ≠òÂÇ®Âä†ÂØÜ
   - ÂÆâÂÖ®Êâ´ÊèèÔºö‰ª£Á†ÅÊâ´Êèè„ÄÅ‰æùËµñÊ£ÄÊü•
   - ËÆøÈóÆÊéßÂà∂ÔºöÁΩëÁªúÈöîÁ¶ª„ÄÅÈò≤ÁÅ´Â¢ô
*/

// Áîü‰∫ßÁéØÂ¢ÉÈÖçÁΩÆÁÆ°ÁêÜ
type ProductionConfig struct {
    // Â∫îÁî®ÈÖçÁΩÆ
    App struct {
        Name        string `json:"name"`
        Version     string `json:"version"`
        Environment string `json:"environment"`
        LogLevel    string `json:"log_level"`
    } `json:"app"`

    // ÊúçÂä°Âô®ÈÖçÁΩÆ
    Server struct {
        Host            string        `json:"host"`
        Port            int           `json:"port"`
        ReadTimeout     time.Duration `json:"read_timeout"`
        WriteTimeout    time.Duration `json:"write_timeout"`
        IdleTimeout     time.Duration `json:"idle_timeout"`
        MaxHeaderBytes  int           `json:"max_header_bytes"`
        GracefulTimeout time.Duration `json:"graceful_timeout"`
    } `json:"server"`

    // Êï∞ÊçÆÂ∫ìÈÖçÁΩÆ
    Database struct {
        Host            string        `json:"host"`
        Port            int           `json:"port"`
        Username        string        `json:"username"`
        Password        string        `json:"password"`
        Database        string        `json:"database"`
        MaxOpenConns    int           `json:"max_open_conns"`
        MaxIdleConns    int           `json:"max_idle_conns"`
        ConnMaxLifetime time.Duration `json:"conn_max_lifetime"`
        SSLMode         string        `json:"ssl_mode"`
    } `json:"database"`

    // RedisÈÖçÁΩÆ
    Redis struct {
        Host         string        `json:"host"`
        Port         int           `json:"port"`
        Password     string        `json:"password"`
        DB           int           `json:"db"`
        PoolSize     int           `json:"pool_size"`
        MinIdleConns int           `json:"min_idle_conns"`
        DialTimeout  time.Duration `json:"dial_timeout"`
        ReadTimeout  time.Duration `json:"read_timeout"`
        WriteTimeout time.Duration `json:"write_timeout"`
    } `json:"redis"`

    // ÁõëÊéßÈÖçÁΩÆ
    Monitoring struct {
        EnableMetrics bool   `json:"enable_metrics"`
        MetricsPort   string `json:"metrics_port"`
        EnableTracing bool   `json:"enable_tracing"`
        JaegerURL     string `json:"jaeger_url"`
        SampleRate    float64 `json:"sample_rate"`
    } `json:"monitoring"`
}

// ‰ºòÈõÖÂÖ≥Èó≠
func GracefulShutdown(server *http.Server, timeout time.Duration) {
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

    <-quit
    log.Println("Shutting down server...")

    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    defer cancel()

    if err := server.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown:", err)
    }

    log.Println("Server exiting")
}
```

### 2. ÊÄßËÉΩ‰ºòÂåñÂíåÊïÖÈöúÊéíÊü•

**ÈóÆÈ¢òÔºö** GoÂ∫îÁî®Âá∫Áé∞ÊÄßËÉΩÈóÆÈ¢òÊó∂ÔºåÂ¶Ç‰ΩïËøõË°åÊéíÊü•Âíå‰ºòÂåñÔºü

**Á≠îÊ°àÔºö**
```go
/*
GoÂ∫îÁî®ÊÄßËÉΩÊéíÊü•Ê≠•È™§Ôºö

1. ÊÄßËÉΩÂàÜÊûêÂ∑•ÂÖ∑
   - pprofÔºöCPU„ÄÅÂÜÖÂ≠ò„ÄÅgoroutineÂàÜÊûê
   - traceÔºöÁ®ãÂ∫èÊâßË°åËΩ®ËøπÂàÜÊûê
   - benchmarkÔºöÂü∫ÂáÜÊµãËØï
   - ÁõëÊéßÊåáÊ†áÔºöPrometheus + Grafana

2. Â∏∏ËßÅÊÄßËÉΩÈóÆÈ¢ò
   - ÂÜÖÂ≠òÊ≥ÑÊºèÔºögoroutineÊ≥ÑÊºè„ÄÅÂÜÖÂ≠òÊú™ÈáäÊîæ
   - CPUÂç†Áî®È´òÔºöÁÆóÊ≥ïÂ§çÊùÇÂ∫¶„ÄÅÊó†ÈôêÂæ™ÁéØ
   - GCÂéãÂäõÂ§ßÔºöÈ¢ëÁπÅÂàÜÈÖç„ÄÅÂ§ßÂØπË±°
   - Âπ∂ÂèëÈóÆÈ¢òÔºöÈîÅÁ´û‰∫â„ÄÅchannelÈòªÂ°û

3. ‰ºòÂåñÁ≠ñÁï•
   - ÂÜÖÂ≠ò‰ºòÂåñÔºöÂØπË±°Ê±†„ÄÅÂÜÖÂ≠òÂ§çÁî®
   - Âπ∂Âèë‰ºòÂåñÔºöworker pool„ÄÅÈôêÊµÅ
   - ÁÆóÊ≥ï‰ºòÂåñÔºöÊï∞ÊçÆÁªìÊûÑ„ÄÅÁºìÂ≠ò
   - I/O‰ºòÂåñÔºöËøûÊé•Ê±†„ÄÅÊâπÂ§ÑÁêÜ
*/

// ÊÄßËÉΩÁõëÊéßÂíåÂàÜÊûê
type PerformanceAnalyzer struct {
    metrics map[string]interface{}
    mutex   sync.RWMutex
}

func NewPerformanceAnalyzer() *PerformanceAnalyzer {
    return &PerformanceAnalyzer{
        metrics: make(map[string]interface{}),
    }
}

// ËÆ∞ÂΩïÊÄßËÉΩÊåáÊ†á
func (pa *PerformanceAnalyzer) RecordMetric(name string, value interface{}) {
    pa.mutex.Lock()
    defer pa.mutex.Unlock()
    pa.metrics[name] = value
}

// Ëé∑ÂèñÊÄßËÉΩÊä•Âëä
func (pa *PerformanceAnalyzer) GetReport() map[string]interface{} {
    pa.mutex.RLock()
    defer pa.mutex.RUnlock()

    report := make(map[string]interface{})
    for k, v := range pa.metrics {
        report[k] = v
    }

    // Ê∑ªÂä†Á≥ªÁªüÊåáÊ†á
    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    report["goroutines"] = runtime.NumGoroutine()
    report["memory_alloc"] = m.Alloc
    report["memory_total"] = m.TotalAlloc
    report["memory_sys"] = m.Sys
    report["gc_count"] = m.NumGC
    report["gc_pause_total"] = time.Duration(m.PauseTotalNs)

    return report
}

// ÊÄßËÉΩÊµãËØïËæÖÂä©ÂáΩÊï∞
func BenchmarkFunction(name string, fn func()) time.Duration {
    start := time.Now()
    fn()
    duration := time.Since(start)

    fmt.Printf("Benchmark %s: %v\n", name, duration)
    return duration
}

// ÂÜÖÂ≠ò‰ΩøÁî®ÂàÜÊûê
func AnalyzeMemoryUsage() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    fmt.Printf("Memory Usage Analysis:\n")
    fmt.Printf("  Alloc: %d KB\n", m.Alloc/1024)
    fmt.Printf("  TotalAlloc: %d KB\n", m.TotalAlloc/1024)
    fmt.Printf("  Sys: %d KB\n", m.Sys/1024)
    fmt.Printf("  NumGC: %d\n", m.NumGC)
    fmt.Printf("  GCCPUFraction: %f\n", m.GCCPUFraction)
    fmt.Printf("  Goroutines: %d\n", runtime.NumGoroutine())
}
```

---

## ‚ö†Ô∏è Ë∏©ÂùëÊèêÈÜí

### 1. ÂÆπÂô®ÂåñÈÉ®ÁΩ≤Èô∑Èò±

```go
// ‚ùå ÈîôËØØÔºö‰∏çÂÆâÂÖ®ÁöÑDockerÈÖçÁΩÆ
/*
Â∏∏ËßÅÈóÆÈ¢òÔºö
1. ‰ΩøÁî®rootÁî®Êà∑ËøêË°åÂ∫îÁî®
2. Êö¥Èú≤‰∏çÂøÖË¶ÅÁöÑÁ´ØÂè£
3. Ê≤°ÊúâËÆæÁΩÆËµÑÊ∫êÈôêÂà∂
4. ÂøΩÁï•ÂÅ•Â∫∑Ê£ÄÊü•
5. Á°¨ÁºñÁ†ÅÈÖçÁΩÆ‰ø°ÊÅØ
*/

// ÈîôËØØÁöÑDockerfileÁ§∫‰æã
dockerfile_bad := `
FROM golang:1.21
WORKDIR /app
COPY . .
RUN go build -o app .
EXPOSE 8080
CMD ["./app"]
`

// ‚úÖ Ê≠£Á°ÆÔºöÂÆâÂÖ®ÁöÑDockerÈÖçÁΩÆ
dockerfile_good := `
# Â§öÈò∂ÊÆµÊûÑÂª∫
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

# ËøêË°åÈò∂ÊÆµ
FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/

# ÂàõÂª∫ÈùûrootÁî®Êà∑
RUN addgroup -g 1001 -S appgroup && \
    adduser -u 1001 -S appuser -G appgroup

# Â§çÂà∂‰∫åËøõÂà∂Êñá‰ª∂
COPY --from=builder /app/app .
RUN chown appuser:appgroup ./app

# ÂàáÊç¢Âà∞ÈùûrootÁî®Êà∑
USER appuser

# ÂÅ•Â∫∑Ê£ÄÊü•
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

EXPOSE 8080
CMD ["./app"]
`

/*
ÊúÄ‰Ω≥ÂÆûË∑µÔºö
1. ‰ΩøÁî®Â§öÈò∂ÊÆµÊûÑÂª∫ÂáèÂ∞èÈïúÂÉè‰ΩìÁßØ
2. ÂàõÂª∫ÈùûrootÁî®Êà∑ËøêË°åÂ∫îÁî®
3. Ê∑ªÂä†ÂÅ•Â∫∑Ê£ÄÊü•
4. ËÆæÁΩÆÂêàÈÄÇÁöÑËµÑÊ∫êÈôêÂà∂
5. ‰ΩøÁî®ÁéØÂ¢ÉÂèòÈáèÈÖçÁΩÆ
*/
```

### 2. ÁõëÊéßÈÖçÁΩÆÈô∑Èò±

```go
// ‚ùå ÈîôËØØÔºöÁõëÊéßÈÖçÁΩÆ‰∏çÂΩì
type BadMonitoringConfig struct {
    // ÁõëÊéßÊâÄÊúâËØ∑Ê±ÇÔºåÂØºËá¥ÊÄßËÉΩÈóÆÈ¢ò
    TraceAllRequests bool

    // ÊåáÊ†áËøáÂ§öÔºåÂ≠òÂÇ®ÂéãÂäõÂ§ß
    DetailedMetrics map[string]interface{}

    // Ê≤°ÊúâÈááÊ†∑ÔºåÈìæË∑ØËøΩË∏™ÂºÄÈîÄÂ§ß
    TracingSampleRate float64 // 1.0 = 100%

    // Êó•ÂøóÁ∫ßÂà´Ëøá‰ΩéÔºåÊó•ÂøóÈáèÂ∑®Â§ß
    LogLevel string // "debug"
}

// ‚úÖ Ê≠£Á°ÆÔºöÂêàÁêÜÁöÑÁõëÊéßÈÖçÁΩÆ
type GoodMonitoringConfig struct {
    // Ê†∏ÂøÉÊåáÊ†áÁõëÊéß
    CoreMetrics struct {
        RequestCount    bool `json:"request_count"`
        ResponseTime    bool `json:"response_time"`
        ErrorRate       bool `json:"error_rate"`
        SystemMetrics   bool `json:"system_metrics"`
    } `json:"core_metrics"`

    // ÂêàÁêÜÁöÑÈááÊ†∑Áéá
    TracingSampleRate float64 `json:"tracing_sample_rate"` // 0.1 = 10%

    // ÂàÜÁ∫ßÊó•Âøó
    LogConfig struct {
        Level      string `json:"level"`      // "info"
        MaxSize    int    `json:"max_size"`   // MB
        MaxBackups int    `json:"max_backups"`
        MaxAge     int    `json:"max_age"`    // days
        Compress   bool   `json:"compress"`
    } `json:"log_config"`

    // ÂëäË≠¶ÈòàÂÄº
    AlertThresholds struct {
        CPUUsage     float64 `json:"cpu_usage"`     // 80%
        MemoryUsage  float64 `json:"memory_usage"`  // 85%
        ErrorRate    float64 `json:"error_rate"`    // 5%
        ResponseTime float64 `json:"response_time"` // 1000ms
    } `json:"alert_thresholds"`
}

/*
ÁõëÊéßÊúÄ‰Ω≥ÂÆûË∑µÔºö
1. ÁõëÊéßÊ†∏ÂøÉÊåáÊ†áÔºåÈÅøÂÖçÊåáÊ†áÁàÜÁÇ∏
2. ÂêàÁêÜËÆæÁΩÆÈááÊ†∑ÁéáÔºåÂπ≥Ë°°ÊÄßËÉΩÂíåÂèØËßÇÊµãÊÄß
3. ÂàÜÁ∫ßÊó•ÂøóÔºåÊéßÂà∂Êó•ÂøóÈáè
4. ËÆæÁΩÆÂêàÁêÜÁöÑÂëäË≠¶ÈòàÂÄº
5. ÂÆöÊúüÊ∏ÖÁêÜÂéÜÂè≤Êï∞ÊçÆ
*/
```

### 3. ÊÄßËÉΩ‰ºòÂåñÈô∑Èò±

```go
// ‚ùå ÈîôËØØÔºöËøáÂ∫¶‰ºòÂåñ
func BadOptimization() {
    // ËøáÊó©‰ºòÂåñÔºå‰ª£Á†ÅÂ§çÊùÇÂ∫¶Â¢ûÂä†
    type ComplexCache struct {
        l1Cache map[string]interface{}
        l2Cache map[string]interface{}
        l3Cache map[string]interface{}
        // ... Â§öÁ∫ßÁºìÂ≠òÔºå‰ΩÜÂÆûÈôÖ‰∏çÈúÄË¶Å
    }

    // ËøáÂ∫¶‰ΩøÁî®goroutine
    for i := 0; i < 1000000; i++ {
        go func(i int) {
            // ÁÆÄÂçïÊìç‰ΩúÔºå‰∏çÈúÄË¶Ågoroutine
            fmt.Println(i)
        }(i)
    }

    // ‰∏çÂøÖË¶ÅÁöÑÂÜÖÂ≠òÊ±†
    var stringPool = sync.Pool{
        New: func() interface{} {
            return make([]string, 0, 10)
        },
    }
    // Áî®‰∫éÁÆÄÂçïÁöÑÂ≠óÁ¨¶‰∏≤Êìç‰ΩúÔºåÂºÄÈîÄÂ§ß‰∫éÊî∂Áõä
}

// ‚úÖ Ê≠£Á°ÆÔºöÂêàÁêÜ‰ºòÂåñ
func GoodOptimization() {
    // 1. ÂÖàÊµãÈáèÔºåÂÜç‰ºòÂåñ
    start := time.Now()
    defer func() {
        fmt.Printf("Operation took: %v\n", time.Since(start))
    }()

    // 2. ‰ΩøÁî®worker poolÊéßÂà∂Âπ∂Âèë
    const workerCount = 10
    jobs := make(chan int, 100)
    results := make(chan int, 100)

    // ÂêØÂä®workers
    for w := 0; w < workerCount; w++ {
        go worker(jobs, results)
    }

    // ÂèëÈÄÅ‰ªªÂä°
    for i := 0; i < 100; i++ {
        jobs <- i
    }
    close(jobs)

    // Êî∂ÈõÜÁªìÊûú
    for i := 0; i < 100; i++ {
        <-results
    }

    // 3. ÂêàÁêÜ‰ΩøÁî®ÁºìÂ≠ò
    cache := NewLRUCache(1000) // ÈÄÇÂΩìÁöÑÁºìÂ≠òÂ§ßÂ∞è

    // 4. ÊâπÈáèÂ§ÑÁêÜ
    batchSize := 100
    batch := make([]Item, 0, batchSize)

    for item := range items {
        batch = append(batch, item)
        if len(batch) >= batchSize {
            processBatch(batch)
            batch = batch[:0] // ÈáçÁΩÆ‰ΩÜ‰øùÁïôÂÆπÈáè
        }
    }

    // Â§ÑÁêÜÂâ©‰ΩôÈ°πÁõÆ
    if len(batch) > 0 {
        processBatch(batch)
    }
}

func worker(jobs <-chan int, results chan<- int) {
    for job := range jobs {
        // Â§ÑÁêÜ‰ªªÂä°
        result := processJob(job)
        results <- result
    }
}

/*
ÊÄßËÉΩ‰ºòÂåñÂéüÂàôÔºö
1. ÂÖàÊµãÈáèÔºåÂêé‰ºòÂåñ
2. ÂÖ≥Ê≥®ÁÉ≠ÁÇπ‰ª£Á†Å
3. ÈÅøÂÖçËøáÊó©‰ºòÂåñ
4. Âπ≥Ë°°Â§çÊùÇÂ∫¶ÂíåÊÄßËÉΩ
5. ÊåÅÁª≠ÁõëÊéßÂíåË∞ÉÊï¥
*/
```

---

## üìù ÁªÉ‰π†È¢ò

### ÁªÉ‰π†È¢ò1ÔºöËÆæËÆ°ÂÆåÊï¥ÁöÑÁõëÊéßÁ≥ªÁªüÔºà‚≠ê‚≠ê‚≠êÔºâ

**È¢òÁõÆÊèèËø∞Ôºö**
‰∏∫mall-goÈ°πÁõÆËÆæËÆ°‰∏Ä‰∏™ÂÆåÊï¥ÁöÑÁõëÊéßÁ≥ªÁªüÔºåÂåÖÊã¨ÊåáÊ†áÊî∂ÈõÜ„ÄÅÈìæË∑ØËøΩË∏™„ÄÅÊó•ÂøóËÅöÂêà„ÄÅÂëäË≠¶Á≥ªÁªüÁ≠â„ÄÇ

```go
// ÁªÉ‰π†È¢ò1ÔºöÂÆåÊï¥ÁõëÊéßÁ≥ªÁªüËÆæËÆ°
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// Ëß£Á≠îÔºö
// 1. ÁõëÊéßÁ≥ªÁªüÊû∂ÊûÑ
type MonitoringSystem struct {
    MetricsCollector  *MetricsCollector  `json:"metrics_collector"`
    TracingSystem     *TracingSystem     `json:"tracing_system"`
    LoggingSystem     *LoggingSystem     `json:"logging_system"`
    AlertManager      *AlertManager      `json:"alert_manager"`
    Dashboard         *Dashboard         `json:"dashboard"`
}

// ÊåáÊ†áÊî∂ÈõÜÂô®
type MetricsCollector struct {
    metrics map[string]Metric
    mutex   sync.RWMutex
}

type Metric struct {
    Name      string                 `json:"name"`
    Type      string                 `json:"type"` // counter, gauge, histogram
    Value     float64                `json:"value"`
    Labels    map[string]string      `json:"labels"`
    Timestamp time.Time              `json:"timestamp"`
}

func NewMetricsCollector() *MetricsCollector {
    return &MetricsCollector{
        metrics: make(map[string]Metric),
    }
}

// ËÆ∞ÂΩïÊåáÊ†á
func (mc *MetricsCollector) RecordCounter(name string, value float64, labels map[string]string) {
    mc.mutex.Lock()
    defer mc.mutex.Unlock()

    key := fmt.Sprintf("%s_%s", name, labelsToString(labels))
    metric := mc.metrics[key]
    metric.Name = name
    metric.Type = "counter"
    metric.Value += value
    metric.Labels = labels
    metric.Timestamp = time.Now()
    mc.metrics[key] = metric
}

func (mc *MetricsCollector) RecordGauge(name string, value float64, labels map[string]string) {
    mc.mutex.Lock()
    defer mc.mutex.Unlock()

    key := fmt.Sprintf("%s_%s", name, labelsToString(labels))
    mc.metrics[key] = Metric{
        Name:      name,
        Type:      "gauge",
        Value:     value,
        Labels:    labels,
        Timestamp: time.Now(),
    }
}

// Ëé∑ÂèñÊâÄÊúâÊåáÊ†á
func (mc *MetricsCollector) GetMetrics() []Metric {
    mc.mutex.RLock()
    defer mc.mutex.RUnlock()

    metrics := make([]Metric, 0, len(mc.metrics))
    for _, metric := range mc.metrics {
        metrics = append(metrics, metric)
    }
    return metrics
}

// 2. ÈìæË∑ØËøΩË∏™Á≥ªÁªü
type TracingSystem struct {
    spans map[string]*Span
    mutex sync.RWMutex
}

type Span struct {
    TraceID    string            `json:"trace_id"`
    SpanID     string            `json:"span_id"`
    ParentID   string            `json:"parent_id"`
    Operation  string            `json:"operation"`
    StartTime  time.Time         `json:"start_time"`
    EndTime    time.Time         `json:"end_time"`
    Duration   time.Duration     `json:"duration"`
    Tags       map[string]string `json:"tags"`
    Logs       []LogEntry        `json:"logs"`
}

type LogEntry struct {
    Timestamp time.Time         `json:"timestamp"`
    Fields    map[string]string `json:"fields"`
}

func NewTracingSystem() *TracingSystem {
    return &TracingSystem{
        spans: make(map[string]*Span),
    }
}

// ÂºÄÂßãspan
func (ts *TracingSystem) StartSpan(traceID, spanID, parentID, operation string) *Span {
    span := &Span{
        TraceID:   traceID,
        SpanID:    spanID,
        ParentID:  parentID,
        Operation: operation,
        StartTime: time.Now(),
        Tags:      make(map[string]string),
        Logs:      make([]LogEntry, 0),
    }

    ts.mutex.Lock()
    ts.spans[spanID] = span
    ts.mutex.Unlock()

    return span
}

// ÁªìÊùüspan
func (ts *TracingSystem) FinishSpan(spanID string) {
    ts.mutex.Lock()
    defer ts.mutex.Unlock()

    if span, exists := ts.spans[spanID]; exists {
        span.EndTime = time.Now()
        span.Duration = span.EndTime.Sub(span.StartTime)
    }
}

// 3. Êó•ÂøóÁ≥ªÁªü
type LoggingSystem struct {
    logs   []LogMessage
    mutex  sync.RWMutex
    config LogConfig
}

type LogMessage struct {
    Level     string                 `json:"level"`
    Message   string                 `json:"message"`
    Timestamp time.Time              `json:"timestamp"`
    Fields    map[string]interface{} `json:"fields"`
    TraceID   string                 `json:"trace_id"`
    SpanID    string                 `json:"span_id"`
}

type LogConfig struct {
    Level      string `json:"level"`
    MaxSize    int    `json:"max_size"`
    MaxBackups int    `json:"max_backups"`
    MaxAge     int    `json:"max_age"`
}

func NewLoggingSystem(config LogConfig) *LoggingSystem {
    return &LoggingSystem{
        logs:   make([]LogMessage, 0),
        config: config,
    }
}

// ËÆ∞ÂΩïÊó•Âøó
func (ls *LoggingSystem) Log(level, message string, fields map[string]interface{}, traceID, spanID string) {
    if !ls.shouldLog(level) {
        return
    }

    logMsg := LogMessage{
        Level:     level,
        Message:   message,
        Timestamp: time.Now(),
        Fields:    fields,
        TraceID:   traceID,
        SpanID:    spanID,
    }

    ls.mutex.Lock()
    ls.logs = append(ls.logs, logMsg)

    // ÈôêÂà∂Êó•ÂøóÊï∞Èáè
    if len(ls.logs) > ls.config.MaxSize {
        ls.logs = ls.logs[len(ls.logs)-ls.config.MaxSize:]
    }
    ls.mutex.Unlock()
}

func (ls *LoggingSystem) shouldLog(level string) bool {
    levels := map[string]int{
        "debug": 0,
        "info":  1,
        "warn":  2,
        "error": 3,
    }

    configLevel := levels[ls.config.Level]
    msgLevel := levels[level]

    return msgLevel >= configLevel
}

// 4. ÂëäË≠¶ÁÆ°ÁêÜÂô®
type AlertManager struct {
    rules   []AlertRule
    alerts  []Alert
    mutex   sync.RWMutex
}

type AlertRule struct {
    Name        string  `json:"name"`
    Metric      string  `json:"metric"`
    Condition   string  `json:"condition"` // >, <, ==
    Threshold   float64 `json:"threshold"`
    Duration    time.Duration `json:"duration"`
    Severity    string  `json:"severity"`
    Actions     []AlertAction `json:"actions"`
}

type Alert struct {
    Rule        AlertRule `json:"rule"`
    Value       float64   `json:"value"`
    Status      string    `json:"status"` // firing, resolved
    StartTime   time.Time `json:"start_time"`
    ResolveTime time.Time `json:"resolve_time"`
}

type AlertAction struct {
    Type   string                 `json:"type"` // email, webhook, slack
    Config map[string]interface{} `json:"config"`
}

func NewAlertManager() *AlertManager {
    return &AlertManager{
        rules:  make([]AlertRule, 0),
        alerts: make([]Alert, 0),
    }
}

// Ê∑ªÂä†ÂëäË≠¶ËßÑÂàô
func (am *AlertManager) AddRule(rule AlertRule) {
    am.mutex.Lock()
    defer am.mutex.Unlock()
    am.rules = append(am.rules, rule)
}

// Ê£ÄÊü•ÂëäË≠¶
func (am *AlertManager) CheckAlerts(metrics []Metric) {
    am.mutex.Lock()
    defer am.mutex.Unlock()

    for _, rule := range am.rules {
        for _, metric := range metrics {
            if metric.Name == rule.Metric {
                if am.evaluateCondition(metric.Value, rule.Condition, rule.Threshold) {
                    am.fireAlert(rule, metric.Value)
                }
            }
        }
    }
}

func (am *AlertManager) evaluateCondition(value float64, condition string, threshold float64) bool {
    switch condition {
    case ">":
        return value > threshold
    case "<":
        return value < threshold
    case "==":
        return value == threshold
    default:
        return false
    }
}

func (am *AlertManager) fireAlert(rule AlertRule, value float64) {
    alert := Alert{
        Rule:      rule,
        Value:     value,
        Status:    "firing",
        StartTime: time.Now(),
    }

    am.alerts = append(am.alerts, alert)

    // ÊâßË°åÂëäË≠¶Âä®‰Ωú
    for _, action := range rule.Actions {
        go am.executeAction(action, alert)
    }
}

func (am *AlertManager) executeAction(action AlertAction, alert Alert) {
    switch action.Type {
    case "email":
        fmt.Printf("Sending email alert: %s\n", alert.Rule.Name)
    case "webhook":
        fmt.Printf("Sending webhook alert: %s\n", alert.Rule.Name)
    case "slack":
        fmt.Printf("Sending slack alert: %s\n", alert.Rule.Name)
    }
}

// 5. ‰ª™Ë°®Êùø
type Dashboard struct {
    widgets []Widget
}

type Widget struct {
    Type   string                 `json:"type"` // chart, table, gauge
    Title  string                 `json:"title"`
    Query  string                 `json:"query"`
    Config map[string]interface{} `json:"config"`
}

// ‰ΩøÁî®Á§∫‰æã
func ExampleMonitoringSystem() {
    // ÂàõÂª∫ÁõëÊéßÁ≥ªÁªü
    monitoring := &MonitoringSystem{
        MetricsCollector: NewMetricsCollector(),
        TracingSystem:    NewTracingSystem(),
        LoggingSystem:    NewLoggingSystem(LogConfig{Level: "info", MaxSize: 10000}),
        AlertManager:     NewAlertManager(),
    }

    // Ê∑ªÂä†ÂëäË≠¶ËßÑÂàô
    monitoring.AlertManager.AddRule(AlertRule{
        Name:      "High CPU Usage",
        Metric:    "cpu_usage",
        Condition: ">",
        Threshold: 80.0,
        Duration:  5 * time.Minute,
        Severity:  "warning",
        Actions: []AlertAction{
            {Type: "email", Config: map[string]interface{}{"to": "admin@example.com"}},
        },
    })

    // Ê®°ÊãüÊåáÊ†áÊî∂ÈõÜ
    monitoring.MetricsCollector.RecordGauge("cpu_usage", 85.0, map[string]string{"host": "server1"})
    monitoring.MetricsCollector.RecordCounter("http_requests_total", 1, map[string]string{"method": "GET", "status": "200"})

    // Ê®°ÊãüÈìæË∑ØËøΩË∏™
    span := monitoring.TracingSystem.StartSpan("trace1", "span1", "", "http_request")
    time.Sleep(100 * time.Millisecond)
    monitoring.TracingSystem.FinishSpan("span1")

    // Ê®°ÊãüÊó•ÂøóËÆ∞ÂΩï
    monitoring.LoggingSystem.Log("info", "Request processed", map[string]interface{}{
        "method": "GET",
        "path":   "/api/users",
        "status": 200,
    }, "trace1", "span1")

    // Ê£ÄÊü•ÂëäË≠¶
    metrics := monitoring.MetricsCollector.GetMetrics()
    monitoring.AlertManager.CheckAlerts(metrics)
}

// ËæÖÂä©ÂáΩÊï∞
func labelsToString(labels map[string]string) string {
    var result string
    for k, v := range labels {
        result += fmt.Sprintf("%s=%s,", k, v)
    }
    return result
}

/*
ÁõëÊéßÁ≥ªÁªüËÆæËÆ°Ë¶ÅÁÇπÔºö
1. Â§öÁª¥Â∫¶ÁõëÊéßÔºöÊåáÊ†á„ÄÅÈìæË∑Ø„ÄÅÊó•Âøó„ÄÅÂëäË≠¶
2. È´òÊÄßËÉΩÔºöÂºÇÊ≠•Â§ÑÁêÜ„ÄÅÊâπÈáèÊìç‰Ωú
3. ÂèØÊâ©Â±ïÔºöÊèí‰ª∂ÂåñÊû∂ÊûÑ„ÄÅÈÖçÁΩÆÈ©±Âä®
4. ÊòìÁî®ÊÄßÔºöÁªü‰∏ÄÊé•Âè£„ÄÅÂèØËßÜÂåñÂ±ïÁ§∫
5. ÂèØÈù†ÊÄßÔºöÂÆπÈîôÂ§ÑÁêÜ„ÄÅÊï∞ÊçÆÊåÅ‰πÖÂåñ

Êâ©Â±ïÊÄùËÄÉÔºö
- Â¶Ç‰ΩïÂÆûÁé∞ÁõëÊéßÊï∞ÊçÆÁöÑÊåÅ‰πÖÂåñÂ≠òÂÇ®Ôºü
- Â¶Ç‰ΩïÂ§ÑÁêÜÂ§ßÈáèÁõëÊéßÊï∞ÊçÆÁöÑÊÄßËÉΩÈóÆÈ¢òÔºü
- Â¶Ç‰ΩïÂÆûÁé∞ÂàÜÂ∏ÉÂºèÁõëÊéßÊï∞ÊçÆÁöÑËÅöÂêàÔºü
- Â¶Ç‰ΩïËÆæËÆ°ÁÅµÊ¥ªÁöÑÂëäË≠¶ËßÑÂàôÂºïÊìéÔºü
*/
```

### ÁªÉ‰π†È¢ò2ÔºöËÆæËÆ°È´òÂèØÁî®ÈÉ®ÁΩ≤Êû∂ÊûÑÔºà‚≠ê‚≠ê‚≠ê‚≠êÔºâ

**È¢òÁõÆÊèèËø∞Ôºö**
‰∏∫mall-goÈ°πÁõÆËÆæËÆ°‰∏Ä‰∏™È´òÂèØÁî®ÁöÑÈÉ®ÁΩ≤Êû∂ÊûÑÔºåÂåÖÊã¨Ë¥üËΩΩÂùáË°°„ÄÅÊïÖÈöúËΩ¨Áßª„ÄÅÊï∞ÊçÆÂ§á‰ªΩ„ÄÅÁÅæÈöæÊÅ¢Â§çÁ≠â„ÄÇ

```go
// ÁªÉ‰π†È¢ò2ÔºöÈ´òÂèØÁî®ÈÉ®ÁΩ≤Êû∂ÊûÑËÆæËÆ°
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// Ëß£Á≠îÔºö
// 1. È´òÂèØÁî®Êû∂ÊûÑÁªÑ‰ª∂
type HighAvailabilityArchitecture struct {
    LoadBalancer    *LoadBalancer    `json:"load_balancer"`
    ServiceRegistry *ServiceRegistry `json:"service_registry"`
    HealthChecker   *HealthChecker   `json:"health_checker"`
    BackupManager   *BackupManager   `json:"backup_manager"`
    FailoverManager *FailoverManager `json:"failover_manager"`
    CircuitBreaker  *CircuitBreaker  `json:"circuit_breaker"`
}

// Ë¥üËΩΩÂùáË°°Âô®
type LoadBalancer struct {
    algorithm string // round_robin, weighted, least_connections
    backends  []Backend
    mutex     sync.RWMutex
}

type Backend struct {
    ID       string    `json:"id"`
    Address  string    `json:"address"`
    Weight   int       `json:"weight"`
    Healthy  bool      `json:"healthy"`
    LastSeen time.Time `json:"last_seen"`
    Metrics  BackendMetrics `json:"metrics"`
}

type BackendMetrics struct {
    ActiveConnections int           `json:"active_connections"`
    ResponseTime      time.Duration `json:"response_time"`
    ErrorRate         float64       `json:"error_rate"`
    RequestCount      int64         `json:"request_count"`
}

func NewLoadBalancer(algorithm string) *LoadBalancer {
    return &LoadBalancer{
        algorithm: algorithm,
        backends:  make([]Backend, 0),
    }
}

// Ê∑ªÂä†ÂêéÁ´ØÊúçÂä°
func (lb *LoadBalancer) AddBackend(backend Backend) {
    lb.mutex.Lock()
    defer lb.mutex.Unlock()
    lb.backends = append(lb.backends, backend)
}

// ÈÄâÊã©ÂêéÁ´ØÊúçÂä°
func (lb *LoadBalancer) SelectBackend() (*Backend, error) {
    lb.mutex.RLock()
    defer lb.mutex.RUnlock()

    healthyBackends := make([]Backend, 0)
    for _, backend := range lb.backends {
        if backend.Healthy {
            healthyBackends = append(healthyBackends, backend)
        }
    }

    if len(healthyBackends) == 0 {
        return nil, fmt.Errorf("no healthy backends available")
    }

    switch lb.algorithm {
    case "round_robin":
        return lb.roundRobin(healthyBackends), nil
    case "weighted":
        return lb.weighted(healthyBackends), nil
    case "least_connections":
        return lb.leastConnections(healthyBackends), nil
    default:
        return &healthyBackends[0], nil
    }
}

func (lb *LoadBalancer) roundRobin(backends []Backend) *Backend {
    // ÁÆÄÂåñÂÆûÁé∞ÔºåÂÆûÈôÖÈúÄË¶ÅÁª¥Êä§ËÆ°Êï∞Âô®
    return &backends[time.Now().Unix()%int64(len(backends))]
}

func (lb *LoadBalancer) weighted(backends []Backend) *Backend {
    totalWeight := 0
    for _, backend := range backends {
        totalWeight += backend.Weight
    }

    if totalWeight == 0 {
        return &backends[0]
    }

    random := int(time.Now().Unix()) % totalWeight
    currentWeight := 0

    for _, backend := range backends {
        currentWeight += backend.Weight
        if random < currentWeight {
            return &backend
        }
    }

    return &backends[0]
}

func (lb *LoadBalancer) leastConnections(backends []Backend) *Backend {
    minConnections := backends[0].Metrics.ActiveConnections
    selectedBackend := &backends[0]

    for _, backend := range backends {
        if backend.Metrics.ActiveConnections < minConnections {
            minConnections = backend.Metrics.ActiveConnections
            selectedBackend = &backend
        }
    }

    return selectedBackend
}

// 2. ÊúçÂä°Ê≥®ÂÜå‰∏éÂèëÁé∞
type ServiceRegistry struct {
    services map[string][]ServiceInstance
    mutex    sync.RWMutex
}

type ServiceInstance struct {
    ID       string            `json:"id"`
    Name     string            `json:"name"`
    Address  string            `json:"address"`
    Port     int               `json:"port"`
    Tags     []string          `json:"tags"`
    Metadata map[string]string `json:"metadata"`
    Health   HealthStatus      `json:"health"`
    TTL      time.Duration     `json:"ttl"`
    LastHeartbeat time.Time    `json:"last_heartbeat"`
}

type HealthStatus struct {
    Status      string    `json:"status"` // healthy, unhealthy, unknown
    LastCheck   time.Time `json:"last_check"`
    CheckCount  int       `json:"check_count"`
    FailureCount int      `json:"failure_count"`
}

func NewServiceRegistry() *ServiceRegistry {
    return &ServiceRegistry{
        services: make(map[string][]ServiceInstance),
    }
}

// Ê≥®ÂÜåÊúçÂä°
func (sr *ServiceRegistry) RegisterService(instance ServiceInstance) error {
    sr.mutex.Lock()
    defer sr.mutex.Unlock()

    instance.LastHeartbeat = time.Now()
    instance.Health.Status = "healthy"
    instance.Health.LastCheck = time.Now()

    if _, exists := sr.services[instance.Name]; !exists {
        sr.services[instance.Name] = make([]ServiceInstance, 0)
    }

    // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®
    for i, existing := range sr.services[instance.Name] {
        if existing.ID == instance.ID {
            sr.services[instance.Name][i] = instance
            return nil
        }
    }

    sr.services[instance.Name] = append(sr.services[instance.Name], instance)
    return nil
}

// ÂèëÁé∞ÊúçÂä°
func (sr *ServiceRegistry) DiscoverService(serviceName string) ([]ServiceInstance, error) {
    sr.mutex.RLock()
    defer sr.mutex.RUnlock()

    instances, exists := sr.services[serviceName]
    if !exists {
        return nil, fmt.Errorf("service %s not found", serviceName)
    }

    // ËøáÊª§ÂÅ•Â∫∑ÁöÑÂÆû‰æã
    healthyInstances := make([]ServiceInstance, 0)
    for _, instance := range instances {
        if instance.Health.Status == "healthy" {
            healthyInstances = append(healthyInstances, instance)
        }
    }

    return healthyInstances, nil
}

// ÂøÉË∑≥Ê£ÄÊü•
func (sr *ServiceRegistry) Heartbeat(serviceID string) error {
    sr.mutex.Lock()
    defer sr.mutex.Unlock()

    for serviceName, instances := range sr.services {
        for i, instance := range instances {
            if instance.ID == serviceID {
                sr.services[serviceName][i].LastHeartbeat = time.Now()
                sr.services[serviceName][i].Health.Status = "healthy"
                return nil
            }
        }
    }

    return fmt.Errorf("service %s not found", serviceID)
}

// 3. ÂÅ•Â∫∑Ê£ÄÊü•Âô®
type HealthChecker struct {
    checks   map[string]HealthCheck
    results  map[string]HealthResult
    mutex    sync.RWMutex
    interval time.Duration
}

type HealthCheck struct {
    ID       string        `json:"id"`
    Type     string        `json:"type"` // http, tcp, script
    Target   string        `json:"target"`
    Interval time.Duration `json:"interval"`
    Timeout  time.Duration `json:"timeout"`
    Config   map[string]interface{} `json:"config"`
}

type HealthResult struct {
    CheckID   string    `json:"check_id"`
    Status    string    `json:"status"` // pass, fail, warn
    Message   string    `json:"message"`
    Timestamp time.Time `json:"timestamp"`
    Duration  time.Duration `json:"duration"`
}

func NewHealthChecker(interval time.Duration) *HealthChecker {
    return &HealthChecker{
        checks:   make(map[string]HealthCheck),
        results:  make(map[string]HealthResult),
        interval: interval,
    }
}

// Ê∑ªÂä†ÂÅ•Â∫∑Ê£ÄÊü•
func (hc *HealthChecker) AddCheck(check HealthCheck) {
    hc.mutex.Lock()
    defer hc.mutex.Unlock()
    hc.checks[check.ID] = check
}

// ÊâßË°åÂÅ•Â∫∑Ê£ÄÊü•
func (hc *HealthChecker) RunChecks(ctx context.Context) {
    ticker := time.NewTicker(hc.interval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            hc.executeChecks()
        }
    }
}

func (hc *HealthChecker) executeChecks() {
    hc.mutex.RLock()
    checks := make([]HealthCheck, 0, len(hc.checks))
    for _, check := range hc.checks {
        checks = append(checks, check)
    }
    hc.mutex.RUnlock()

    for _, check := range checks {
        go hc.executeCheck(check)
    }
}

func (hc *HealthChecker) executeCheck(check HealthCheck) {
    start := time.Now()
    var result HealthResult

    switch check.Type {
    case "http":
        result = hc.httpCheck(check)
    case "tcp":
        result = hc.tcpCheck(check)
    case "script":
        result = hc.scriptCheck(check)
    default:
        result = HealthResult{
            CheckID:   check.ID,
            Status:    "fail",
            Message:   "unknown check type",
            Timestamp: time.Now(),
            Duration:  time.Since(start),
        }
    }

    hc.mutex.Lock()
    hc.results[check.ID] = result
    hc.mutex.Unlock()
}

func (hc *HealthChecker) httpCheck(check HealthCheck) HealthResult {
    // HTTPÂÅ•Â∫∑Ê£ÄÊü•ÂÆûÁé∞
    return HealthResult{
        CheckID:   check.ID,
        Status:    "pass",
        Message:   "HTTP check passed",
        Timestamp: time.Now(),
        Duration:  50 * time.Millisecond,
    }
}

func (hc *HealthChecker) tcpCheck(check HealthCheck) HealthResult {
    // TCPÂÅ•Â∫∑Ê£ÄÊü•ÂÆûÁé∞
    return HealthResult{
        CheckID:   check.ID,
        Status:    "pass",
        Message:   "TCP check passed",
        Timestamp: time.Now(),
        Duration:  10 * time.Millisecond,
    }
}

func (hc *HealthChecker) scriptCheck(check HealthCheck) HealthResult {
    // ËÑöÊú¨ÂÅ•Â∫∑Ê£ÄÊü•ÂÆûÁé∞
    return HealthResult{
        CheckID:   check.ID,
        Status:    "pass",
        Message:   "Script check passed",
        Timestamp: time.Now(),
        Duration:  100 * time.Millisecond,
    }
}

// 4. ÊïÖÈöúËΩ¨ÁßªÁÆ°ÁêÜÂô®
type FailoverManager struct {
    policies []FailoverPolicy
    mutex    sync.RWMutex
}

type FailoverPolicy struct {
    ServiceName     string        `json:"service_name"`
    FailureThreshold int          `json:"failure_threshold"`
    RecoveryTime    time.Duration `json:"recovery_time"`
    Actions         []FailoverAction `json:"actions"`
}

type FailoverAction struct {
    Type   string                 `json:"type"` // switch, scale, notify
    Config map[string]interface{} `json:"config"`
}

func NewFailoverManager() *FailoverManager {
    return &FailoverManager{
        policies: make([]FailoverPolicy, 0),
    }
}

// Ê∑ªÂä†ÊïÖÈöúËΩ¨ÁßªÁ≠ñÁï•
func (fm *FailoverManager) AddPolicy(policy FailoverPolicy) {
    fm.mutex.Lock()
    defer fm.mutex.Unlock()
    fm.policies = append(fm.policies, policy)
}

// ÊâßË°åÊïÖÈöúËΩ¨Áßª
func (fm *FailoverManager) ExecuteFailover(serviceName string, failureCount int) {
    fm.mutex.RLock()
    defer fm.mutex.RUnlock()

    for _, policy := range fm.policies {
        if policy.ServiceName == serviceName && failureCount >= policy.FailureThreshold {
            for _, action := range policy.Actions {
                go fm.executeAction(action, serviceName)
            }
        }
    }
}

func (fm *FailoverManager) executeAction(action FailoverAction, serviceName string) {
    switch action.Type {
    case "switch":
        fmt.Printf("Switching traffic for service %s\n", serviceName)
    case "scale":
        fmt.Printf("Scaling service %s\n", serviceName)
    case "notify":
        fmt.Printf("Notifying administrators about service %s failure\n", serviceName)
    }
}

// ‰ΩøÁî®Á§∫‰æã
func ExampleHighAvailabilityArchitecture() {
    // ÂàõÂª∫È´òÂèØÁî®Êû∂ÊûÑ
    ha := &HighAvailabilityArchitecture{
        LoadBalancer:    NewLoadBalancer("weighted"),
        ServiceRegistry: NewServiceRegistry(),
        HealthChecker:   NewHealthChecker(30 * time.Second),
        FailoverManager: NewFailoverManager(),
    }

    // Ê≥®ÂÜåÊúçÂä°ÂÆû‰æã
    ha.ServiceRegistry.RegisterService(ServiceInstance{
        ID:      "mall-api-1",
        Name:    "mall-api",
        Address: "10.0.1.10",
        Port:    8080,
        Tags:    []string{"api", "v1"},
        TTL:     60 * time.Second,
    })

    ha.ServiceRegistry.RegisterService(ServiceInstance{
        ID:      "mall-api-2",
        Name:    "mall-api",
        Address: "10.0.1.11",
        Port:    8080,
        Tags:    []string{"api", "v1"},
        TTL:     60 * time.Second,
    })

    // Ê∑ªÂä†Ë¥üËΩΩÂùáË°°ÂêéÁ´Ø
    ha.LoadBalancer.AddBackend(Backend{
        ID:      "mall-api-1",
        Address: "10.0.1.10:8080",
        Weight:  100,
        Healthy: true,
    })

    ha.LoadBalancer.AddBackend(Backend{
        ID:      "mall-api-2",
        Address: "10.0.1.11:8080",
        Weight:  100,
        Healthy: true,
    })

    // Ê∑ªÂä†ÂÅ•Â∫∑Ê£ÄÊü•
    ha.HealthChecker.AddCheck(HealthCheck{
        ID:       "mall-api-health",
        Type:     "http",
        Target:   "http://10.0.1.10:8080/health",
        Interval: 30 * time.Second,
        Timeout:  5 * time.Second,
    })

    // Ê∑ªÂä†ÊïÖÈöúËΩ¨ÁßªÁ≠ñÁï•
    ha.FailoverManager.AddPolicy(FailoverPolicy{
        ServiceName:      "mall-api",
        FailureThreshold: 3,
        RecoveryTime:     5 * time.Minute,
        Actions: []FailoverAction{
            {Type: "switch", Config: map[string]interface{}{"backup_region": "us-west-2"}},
            {Type: "notify", Config: map[string]interface{}{"channel": "slack"}},
        },
    })

    // Ê®°ÊãüË¥üËΩΩÂùáË°°
    for i := 0; i < 5; i++ {
        backend, err := ha.LoadBalancer.SelectBackend()
        if err != nil {
            fmt.Printf("Error selecting backend: %v\n", err)
        } else {
            fmt.Printf("Selected backend: %s\n", backend.Address)
        }
    }

    // Ê®°ÊãüÊúçÂä°ÂèëÁé∞
    instances, err := ha.ServiceRegistry.DiscoverService("mall-api")
    if err != nil {
        fmt.Printf("Error discovering service: %v\n", err)
    } else {
        fmt.Printf("Discovered %d instances\n", len(instances))
    }
}

/*
È´òÂèØÁî®Êû∂ÊûÑËÆæËÆ°Ë¶ÅÁÇπÔºö
1. Â§öÂ±ÇÂÜó‰ΩôÔºöË¥üËΩΩÂùáË°°„ÄÅÊúçÂä°ÂÆû‰æã„ÄÅÊï∞ÊçÆÂ≠òÂÇ®
2. ÊïÖÈöúÊ£ÄÊµãÔºöÂÅ•Â∫∑Ê£ÄÊü•„ÄÅÁõëÊéßÂëäË≠¶
3. Ëá™Âä®ÊÅ¢Â§çÔºöÊïÖÈöúËΩ¨Áßª„ÄÅËá™Âä®Êâ©Áº©ÂÆπ
4. Êï∞ÊçÆ‰∏ÄËá¥ÊÄßÔºö‰∏ª‰ªéÂ§çÂà∂„ÄÅÂàÜÂ∏ÉÂºè‰∫ãÂä°
5. ÁÅæÈöæÊÅ¢Â§çÔºöË∑®Âå∫ÂüüÈÉ®ÁΩ≤„ÄÅÊï∞ÊçÆÂ§á‰ªΩ

Êâ©Â±ïÊÄùËÄÉÔºö
- Â¶Ç‰ΩïÂÆûÁé∞Ë∑®Âå∫ÂüüÁöÑÊïÖÈöúËΩ¨ÁßªÔºü
- Â¶Ç‰ΩïÂ§ÑÁêÜÁΩëÁªúÂàÜÂå∫ÈóÆÈ¢òÔºü
- Â¶Ç‰Ωï‰øùËØÅÊï∞ÊçÆÁöÑÊúÄÁªà‰∏ÄËá¥ÊÄßÔºü
- Â¶Ç‰ΩïËÆæËÆ°ÂêàÁêÜÁöÑÈôçÁ∫ßÁ≠ñÁï•Ôºü
*/
```

---

## üìö Á´†ËäÇÊÄªÁªì

### üéØ Êú¨Á´†Ê†∏ÂøÉË¶ÅÁÇπ

ÈÄöËøáÊú¨Á´†ÁöÑÂ≠¶‰π†ÔºåÊàë‰ª¨Ê∑±ÂÖ•ÊéåÊè°‰∫ÜGoËØ≠Ë®ÄÂú®Áîü‰∫ßÁéØÂ¢É‰∏≠ÁöÑÂÆûË∑µÊäÄËÉΩÔºö

#### 1. **ÂÆπÂô®ÂåñÈÉ®ÁΩ≤** üê≥
- **DockerÊúÄ‰Ω≥ÂÆûË∑µ**ÔºöÂ§öÈò∂ÊÆµÊûÑÂª∫„ÄÅÈùûrootÁî®Êà∑„ÄÅÂÅ•Â∫∑Ê£ÄÊü•
- **KubernetesÁºñÊéí**ÔºöDeployment„ÄÅService„ÄÅIngress„ÄÅHPAÈÖçÁΩÆ
- **ÂÆâÂÖ®ÈÖçÁΩÆ**ÔºöÈïúÂÉèÊâ´Êèè„ÄÅËµÑÊ∫êÈôêÂà∂„ÄÅÁΩëÁªúÁ≠ñÁï•

#### 2. **ÁõëÊéß‰∏éÂèØËßÇÊµãÊÄß** üìä
- **ÊåáÊ†áÁõëÊéß**ÔºöPrometheusÈõÜÊàê„ÄÅËá™ÂÆö‰πâÊåáÊ†á„ÄÅ‰∏öÂä°ÁõëÊéß
- **ÈìæË∑ØËøΩË∏™**ÔºöOpenTelemetry„ÄÅÂàÜÂ∏ÉÂºèËøΩË∏™„ÄÅÊÄßËÉΩÂàÜÊûê
- **Êó•ÂøóÁÆ°ÁêÜ**ÔºöÁªìÊûÑÂåñÊó•Âøó„ÄÅÊó•ÂøóËÅöÂêà„ÄÅÊü•ËØ¢ÂàÜÊûê
- **ÂëäË≠¶Á≥ªÁªü**ÔºöËßÑÂàôÈÖçÁΩÆ„ÄÅÂ§öÊ∏†ÈÅìÈÄöÁü•„ÄÅÊïÖÈöúÂìçÂ∫î

#### 3. **ÊÄßËÉΩ‰ºòÂåñ** üîß
- **ÊÄßËÉΩÂàÜÊûê**ÔºöpprofÂ∑•ÂÖ∑„ÄÅÊÄßËÉΩÁì∂È¢àËØÜÂà´„ÄÅ‰ºòÂåñÁ≠ñÁï•
- **ÂÜÖÂ≠ò‰ºòÂåñ**ÔºöÂØπË±°Ê±†„ÄÅÂÜÖÂ≠òÂ§çÁî®„ÄÅGCË∞É‰ºò
- **Âπ∂Âèë‰ºòÂåñ**ÔºögoroutineÁÆ°ÁêÜ„ÄÅchannel‰ºòÂåñ„ÄÅÈîÅ‰ºòÂåñ
- **ÁºìÂ≠òÁ≠ñÁï•**ÔºöÂ§öÁ∫ßÁºìÂ≠ò„ÄÅÁºìÂ≠òÊõ¥Êñ∞„ÄÅÁºìÂ≠òÁ©øÈÄèÈò≤Êä§

#### 4. **ÂÆâÂÖ®ÂÆûË∑µ** üõ°Ô∏è
- **ËÆ§ËØÅÊéàÊùÉ**ÔºöJWTÂÆûÁé∞„ÄÅRBACÊùÉÈôêÊéßÂà∂„ÄÅAPIÂØÜÈí•ÁÆ°ÁêÜ
- **Êï∞ÊçÆÂÆâÂÖ®**ÔºöÂä†ÂØÜ‰º†Ëæì„ÄÅÊïèÊÑüÊï∞ÊçÆ‰øùÊä§„ÄÅÂÆâÂÖ®Êâ´Êèè
- **ËÆøÈóÆÊéßÂà∂**ÔºöÁΩëÁªúÈöîÁ¶ª„ÄÅÈò≤ÁÅ´Â¢ôÈÖçÁΩÆ„ÄÅÂÆâÂÖ®ÂÆ°ËÆ°

#### 5. **CI/CDÊµÅÊ∞¥Á∫ø** üîÑ
- **Ëá™Âä®ÂåñÊûÑÂª∫**ÔºöGitHub Actions„ÄÅÂ§öÁéØÂ¢ÉÈÉ®ÁΩ≤„ÄÅË¥®ÈáèÈó®Á¶Å
- **ÊµãËØïÈõÜÊàê**ÔºöÂçïÂÖÉÊµãËØï„ÄÅÈõÜÊàêÊµãËØï„ÄÅÂÆâÂÖ®Êâ´Êèè
- **ÈÉ®ÁΩ≤Á≠ñÁï•**ÔºöËìùÁªøÈÉ®ÁΩ≤„ÄÅÊªöÂä®Êõ¥Êñ∞„ÄÅÈáë‰∏ùÈõÄÂèëÂ∏É
- **ÂõûÊªöÊú∫Âà∂**ÔºöÁâàÊú¨ÁÆ°ÁêÜ„ÄÅÂø´ÈÄüÂõûÊªö„ÄÅÊïÖÈöúÊÅ¢Â§ç

### üè¢ ‰ºÅ‰∏öÁ∫ßÂÆûË∑µÁªèÈ™å

#### **‰∏éJavaÁîüÊÄÅÂØπÊØî**
```go
/*
Go vs Java Áîü‰∫ßÂÆûË∑µÂØπÊØîÔºö

ÈÉ®ÁΩ≤ÊñπÈù¢Ôºö
- Go: Âçï‰∏Ä‰∫åËøõÂà∂Êñá‰ª∂ÔºåÂÆπÂô®ÂåñÁÆÄÂçïÔºåÂêØÂä®Âø´ÈÄü
- Java: ÈúÄË¶ÅJVMÔºåWAR/JARÂåÖÔºåÂêØÂä®ËæÉÊÖ¢‰ΩÜÁîüÊÄÅÊàêÁÜü

ÁõëÊéßÊñπÈù¢Ôºö
- Go: pprofÂÜÖÁΩÆÔºåPrometheusÂéüÁîüÊîØÊåÅ
- Java: JMXÁõëÊéßÔºåAPMÂ∑•ÂÖ∑‰∏∞ÂØåÔºàÂ¶ÇSkywalking„ÄÅPinpointÔºâ

ÊÄßËÉΩÊñπÈù¢Ôºö
- Go: ÂÜÖÂ≠òÂç†Áî®Â∞èÔºåÂπ∂ÂèëÊÄßËÉΩÂ•ΩÔºåGCÂª∂Ëøü‰Ωé
- Java: ÊàêÁÜüÁöÑJVM‰ºòÂåñÔºåÂ§ßÈáèÊÄßËÉΩË∞É‰ºòÂ∑•ÂÖ∑

ËøêÁª¥ÊñπÈù¢Ôºö
- Go: ËøêÁª¥ÁÆÄÂçïÔºå‰æùËµñÂ∞ëÔºåÊïÖÈöúÊéíÊü•Áõ∏ÂØπÂÆπÊòì
- Java: ËøêÁª¥Â§çÊùÇÔºå‰ΩÜÂ∑•ÂÖ∑ÈìæÂÆåÂñÑÔºåÁªèÈ™å‰∏∞ÂØå
*/
```

#### **Mall-GoÈ°πÁõÆÁîü‰∫ßÂÆûË∑µ**
```go
// Mall-GoÁîü‰∫ßÁéØÂ¢ÉÈÖçÁΩÆÁ§∫‰æã
type MallGoProductionConfig struct {
    // Â∫îÁî®ÈÖçÁΩÆ
    App struct {
        Name         string `yaml:"name"`
        Version      string `yaml:"version"`
        Environment  string `yaml:"environment"`
        LogLevel     string `yaml:"log_level"`
        GracefulTimeout time.Duration `yaml:"graceful_timeout"`
    } `yaml:"app"`

    // ÊúçÂä°ÈÖçÁΩÆ
    Server struct {
        Host         string        `yaml:"host"`
        Port         int           `yaml:"port"`
        ReadTimeout  time.Duration `yaml:"read_timeout"`
        WriteTimeout time.Duration `yaml:"write_timeout"`
        IdleTimeout  time.Duration `yaml:"idle_timeout"`
    } `yaml:"server"`

    // Êï∞ÊçÆÂ∫ìÈÖçÁΩÆ
    Database struct {
        Master DatabaseConfig `yaml:"master"`
        Slaves []DatabaseConfig `yaml:"slaves"`
    } `yaml:"database"`

    // ÁºìÂ≠òÈÖçÁΩÆ
    Redis struct {
        Cluster []RedisNode `yaml:"cluster"`
        Sentinel SentinelConfig `yaml:"sentinel"`
    } `yaml:"redis"`

    // ÁõëÊéßÈÖçÁΩÆ
    Monitoring struct {
        Prometheus PrometheusConfig `yaml:"prometheus"`
        Jaeger     JaegerConfig     `yaml:"jaeger"`
        Logging    LoggingConfig    `yaml:"logging"`
    } `yaml:"monitoring"`
}

/*
Áîü‰∫ßÁéØÂ¢ÉÈÉ®ÁΩ≤Êû∂ÊûÑÔºö
1. Ë¥üËΩΩÂùáË°°ÔºöNginx + Keepalived
2. Â∫îÁî®Â±ÇÔºöÂ§öÂÆû‰æãÈÉ®ÁΩ≤ + ÊúçÂä°ÂèëÁé∞
3. Êï∞ÊçÆÂ±ÇÔºö‰∏ª‰ªéÂ§çÂà∂ + ËØªÂÜôÂàÜÁ¶ª
4. ÁºìÂ≠òÂ±ÇÔºöRedisÈõÜÁæ§ + Âì®ÂÖµÊ®°Âºè
5. ÁõëÊéßÂ±ÇÔºöPrometheus + Grafana + Jaeger
*/
```

### üöÄ ËÅå‰∏öÂèëÂ±ïÂª∫ËÆÆ

#### **ÊäÄËÉΩËøõÈò∂Ë∑ØÂæÑ**
1. **ÂàùÁ∫ßÈò∂ÊÆµ**ÔºöÊéåÊè°Âü∫Êú¨ÁöÑÂÆπÂô®ÂåñÈÉ®ÁΩ≤ÂíåÁõëÊéßÈÖçÁΩÆ
2. **‰∏≠Á∫ßÈò∂ÊÆµ**ÔºöÊ∑±ÂÖ•ÁêÜËß£ÊÄßËÉΩ‰ºòÂåñÂíåÂÆâÂÖ®ÂÆûË∑µ
3. **È´òÁ∫ßÈò∂ÊÆµ**ÔºöËÆæËÆ°È´òÂèØÁî®Êû∂ÊûÑÂíåÊïÖÈöúÂ§ÑÁêÜÊú∫Âà∂
4. **‰∏ìÂÆ∂Èò∂ÊÆµ**ÔºöÊûÑÂª∫ÂÆåÊï¥ÁöÑDevOps‰ΩìÁ≥ªÂíåÂπ≥Âè∞ÂåñËÉΩÂäõ

#### **Èù¢ËØïÂáÜÂ§áÈáçÁÇπ**
- **Áîü‰∫ßÁéØÂ¢ÉÁªèÈ™å**ÔºöÂÆπÂô®ÂåñÈÉ®ÁΩ≤„ÄÅÁõëÊéßÂëäË≠¶„ÄÅÊïÖÈöúÂ§ÑÁêÜ
- **ÊÄßËÉΩ‰ºòÂåñÊ°à‰æã**ÔºöÂÖ∑‰ΩìÁöÑ‰ºòÂåñÂÆûË∑µÂíåÊïàÊûúÊï∞ÊçÆ
- **Êû∂ÊûÑËÆæËÆ°ËÉΩÂäõ**ÔºöÈ´òÂèØÁî®„ÄÅÈ´òÂπ∂Âèë„ÄÅÂèØÊâ©Â±ïÁöÑÁ≥ªÁªüËÆæËÆ°
- **ËøêÁª¥Ëá™Âä®Âåñ**ÔºöCI/CDÊµÅÊ∞¥Á∫ø„ÄÅÂü∫Á°ÄËÆæÊñΩÂç≥‰ª£Á†Å

### üìñ Êé®ËçêÂ≠¶‰π†ËµÑÊ∫ê

#### **ÂÆòÊñπÊñáÊ°£**
- [GoÂÆòÊñπÊñáÊ°£](https://golang.org/doc/)
- [DockerÂÆòÊñπÊñáÊ°£](https://docs.docker.com/)
- [KubernetesÂÆòÊñπÊñáÊ°£](https://kubernetes.io/docs/)
- [PrometheusÂÆòÊñπÊñáÊ°£](https://prometheus.io/docs/)

#### **ÂºÄÊ∫êÈ°πÁõÆ**
- [Gin Web Framework](https://github.com/gin-gonic/gin)
- [GORM](https://github.com/go-gorm/gorm)
- [Go-Redis](https://github.com/go-redis/redis)
- [OpenTelemetry Go](https://github.com/open-telemetry/opentelemetry-go)

#### **ÂÆûË∑µÈ°πÁõÆ**
- ÊûÑÂª∫ÂÆåÊï¥ÁöÑÂæÆÊúçÂä°È°πÁõÆ
- ÂÆûÁé∞ÁõëÊéßÂíåÂëäË≠¶Á≥ªÁªü
- ËÆæËÆ°CI/CDÊµÅÊ∞¥Á∫ø
- ‰ºòÂåñÂ∫îÁî®ÊÄßËÉΩ

---

## üéâ ÊÅ≠ÂñúÂÆåÊàêGoËØ≠Ë®ÄÂ≠¶‰π†‰πãÊóÖÔºÅ

ÈÄöËøáÂÆåÊï¥ÁöÑÂ≠¶‰π†Ë∑ØÂæÑÔºå‰Ω†Â∑≤ÁªèÊéåÊè°‰∫ÜÔºö

### üìö **Âü∫Á°ÄÁØá**Ôºà4Á´†Ôºâ
- ÂèòÈáèÁ±ªÂûã‰∏éÂü∫Êú¨ËØ≠Ê≥ï
- ÊéßÂà∂ÁªìÊûÑ‰∏éÊµÅÁ®ãÊéßÂà∂
- ÂáΩÊï∞ÊñπÊ≥ï‰∏éÂåÖÁÆ°ÁêÜ
- ÁªìÊûÑ‰ΩìÊé•Âè£‰∏éÈù¢ÂêëÂØπË±°

### üöÄ **ËøõÈò∂ÁØá**Ôºà4Á´†Ôºâ
- ÈîôËØØÂ§ÑÁêÜ‰∏éÂºÇÂ∏∏ÁÆ°ÁêÜ
- Âπ∂ÂèëÁºñÁ®ã‰∏égoroutine
- Êé•Âè£ËÆæËÆ°‰∏éÂ§öÊÄÅÂÆûÁé∞
- ÂèçÂ∞ÑÊú∫Âà∂‰∏éÂÖÉÁºñÁ®ã

### üíº **ÂÆûÊàòÁØá**Ôºà4Á´†Ôºâ
- GinÊ°ÜÊû∂WebÂºÄÂèë
- GORMÊï∞ÊçÆÂ∫ìÊìç‰Ωú
- RedisÁºìÂ≠òÂ∫îÁî®
- Ê∂àÊÅØÈòüÂàóÈõÜÊàê

### üèóÔ∏è **Êû∂ÊûÑÁØá**Ôºà1Á´†Ôºâ
- ÂæÆÊúçÂä°Êû∂ÊûÑËÆæËÆ°

### üéØ **È´òÁ∫ßÁØá**Ôºà1Á´†Ôºâ
- Áîü‰∫ßÂÆûË∑µ‰∏éËøêÁª¥

### üåü **‰Ω†Áé∞Âú®ÂÖ∑Â§áÁöÑËÉΩÂäõ**
- ‚úÖ **‰ºÅ‰∏öÁ∫ßGoÂºÄÂèë**ÔºöËÉΩÂ§üÁã¨Á´ãÂºÄÂèëÂíåÁª¥Êä§Â§ßÂûãGoÈ°πÁõÆ
- ‚úÖ **ÂæÆÊúçÂä°Êû∂ÊûÑ**ÔºöÂÖ∑Â§áËÆæËÆ°ÂíåÂÆûÁé∞ÂæÆÊúçÂä°Á≥ªÁªüÁöÑËÉΩÂäõ
- ‚úÖ **Áîü‰∫ßÁéØÂ¢ÉËøêÁª¥**ÔºöÊéåÊè°ÂÆπÂô®ÂåñÈÉ®ÁΩ≤„ÄÅÁõëÊéß„ÄÅÊÄßËÉΩ‰ºòÂåñ
- ‚úÖ **ÊäÄÊúØÈÄâÂûãËÉΩÂäõ**ÔºöËÉΩÂ§üÊ†πÊçÆ‰∏öÂä°ÈúÄÊ±ÇÈÄâÊã©ÂêàÈÄÇÁöÑÊäÄÊúØÊ†à
- ‚úÖ **ÈóÆÈ¢òËß£ÂÜ≥ËÉΩÂäõ**ÔºöÂÖ∑Â§áÂàÜÊûêÂíåËß£ÂÜ≥Â§çÊùÇÊäÄÊúØÈóÆÈ¢òÁöÑËÉΩÂäõ

### üéØ **‰∏ã‰∏ÄÊ≠•Âª∫ËÆÆ**
1. **Ê∑±ÂÖ•ÂÆûË∑µ**ÔºöÂèÇ‰∏éÂºÄÊ∫êÈ°πÁõÆÊàñÊûÑÂª∫‰∏™‰∫∫È°πÁõÆ
2. **ÊäÄÊúØÂàÜ‰∫´**ÔºöÂÜôÊäÄÊúØÂçöÂÆ¢ÊàñÂèÇ‰∏éÊäÄÊúØÁ§æÂå∫
3. **ÊåÅÁª≠Â≠¶‰π†**ÔºöÂÖ≥Ê≥®GoËØ≠Ë®ÄÊñ∞ÁâπÊÄßÂíåÁîüÊÄÅÂèëÂ±ï
4. **ËÅå‰∏öÂèëÂ±ï**ÔºöÂêëÈ´òÁ∫ßÂ∑•Á®ãÂ∏àÊàñÊû∂ÊûÑÂ∏àÊñπÂêëÂèëÂ±ï

**ËÆ∞‰ΩèÔºöÊäÄÊúØÁöÑÂ≠¶‰π†Ê∞∏Êó†Ê≠¢Â¢ÉÔºå‰øùÊåÅÂ•ΩÂ•áÂøÉÂíåÂ≠¶‰π†ÁÉ≠ÊÉÖÔºåÊåÅÁª≠Á≤æËøõÔºÅ** üöÄüí™

---

*"‰ª£Á†ÅÊîπÂèò‰∏ñÁïåÔºåGoËØ≠Ë®ÄËÆ©‰Ω†Êõ¥Êé•ËøëËøô‰∏™ÁõÆÊ†áÔºÅÁªßÁª≠Âä†Ê≤πÔºåÊú™Êù•ÁöÑGoÂ§ßÂ∏àÔºÅ"* üéä‚ú®
```
```
```
```
```
