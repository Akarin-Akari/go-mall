# å®æˆ˜ç¯‡ç¬¬ä¸€ç« ï¼šGinæ¡†æ¶å…¥é—¨ä¸å®è·µ ğŸš€

> **"ä»ç†è®ºåˆ°å®è·µï¼Œä»ä»£ç åˆ°äº§å“"** ğŸ’«

---

## ğŸ“– ç« èŠ‚å¯¼è¯»

æ¬¢è¿æ¥åˆ°Goè¯­è¨€Webå¼€å‘çš„å®æˆ˜ä¸–ç•Œï¼ğŸŒŸ ç»è¿‡å‰é¢åŸºç¡€ç¯‡å’Œè¿›é˜¶ç¯‡çš„å­¦ä¹ ï¼Œä½ å·²ç»æŒæ¡äº†Goè¯­è¨€çš„æ ¸å¿ƒè¯­æ³•å’Œé«˜çº§ç‰¹æ€§ã€‚ç°åœ¨æ˜¯æ—¶å€™å°†è¿™äº›çŸ¥è¯†åº”ç”¨åˆ°çœŸå®çš„Webå¼€å‘ä¸­äº†ã€‚

åœ¨è¿™ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ·±å…¥å­¦ä¹ Ginæ¡†æ¶â€”â€”Goè¯­è¨€æœ€æµè¡Œçš„Webæ¡†æ¶ä¹‹ä¸€ï¼Œé€šè¿‡mall-goé¡¹ç›®çš„çœŸå®æ¡ˆä¾‹ï¼ŒæŒæ¡ç°ä»£Webåº”ç”¨å¼€å‘çš„æ ¸å¿ƒæŠ€èƒ½ã€‚

### ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œä½ å°†æŒæ¡ï¼š

- **ğŸ—ï¸ Ginæ¡†æ¶åŸºç¡€**ï¼šç†è§£Ginçš„è®¾è®¡ç†å¿µå’Œæ ¸å¿ƒæ¦‚å¿µ
- **ğŸ›£ï¸ è·¯ç”±ç³»ç»Ÿ**ï¼šæŒæ¡RESTful APIè®¾è®¡å’Œè·¯ç”±ç»„ç»‡
- **ğŸ”§ ä¸­é—´ä»¶æœºåˆ¶**ï¼šå­¦ä¼šä½¿ç”¨å’Œè‡ªå®šä¹‰ä¸­é—´ä»¶
- **ğŸ“ è¯·æ±‚å¤„ç†**ï¼šå¤„ç†å„ç§HTTPè¯·æ±‚å’Œå“åº”
- **ğŸ”’ è®¤è¯æˆæƒ**ï¼šå®ç°JWTè®¤è¯å’Œæƒé™æ§åˆ¶
- **ğŸ“Š æ•°æ®éªŒè¯**ï¼šè¯·æ±‚å‚æ•°éªŒè¯å’Œé”™è¯¯å¤„ç†
- **ğŸ§ª æµ‹è¯•æŠ€å·§**ï¼šWeb APIçš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•

### ğŸ“‹ ç« èŠ‚å¤§çº²

```
01-gin-framework-basics.md
â”œâ”€â”€ ğŸŒŸ  Ginæ¡†æ¶æ¦‚è¿°
â”œâ”€â”€ ğŸš€  å¿«é€Ÿå¼€å§‹
â”œâ”€â”€ ğŸ›£ï¸  è·¯ç”±ç³»ç»Ÿè¯¦è§£
â”‚   â”œâ”€â”€ åŸºç¡€è·¯ç”±
â”‚   â”œâ”€â”€ è·¯ç”±å‚æ•°
â”‚   â”œâ”€â”€ è·¯ç”±ç»„
â”‚   â””â”€â”€ RESTfulè®¾è®¡
â”œâ”€â”€ ğŸ”§  ä¸­é—´ä»¶æœºåˆ¶
â”‚   â”œâ”€â”€ å†…ç½®ä¸­é—´ä»¶
â”‚   â”œâ”€â”€ è‡ªå®šä¹‰ä¸­é—´ä»¶
â”‚   â””â”€â”€ ä¸­é—´ä»¶é“¾
â”œâ”€â”€ ğŸ“  è¯·æ±‚ä¸å“åº”å¤„ç†
â”‚   â”œâ”€â”€ è¯·æ±‚ç»‘å®š
â”‚   â”œâ”€â”€ æ•°æ®éªŒè¯
â”‚   â”œâ”€â”€ å“åº”æ ¼å¼
â”‚   â””â”€â”€ æ–‡ä»¶ä¸Šä¼ 
â”œâ”€â”€ ğŸ”’  è®¤è¯ä¸æˆæƒ
â”œâ”€â”€ ğŸ¢  å®æˆ˜æ¡ˆä¾‹åˆ†æ
â”œâ”€â”€ ğŸ¯  é¢è¯•å¸¸è€ƒç‚¹
â”œâ”€â”€ âš ï¸   è¸©å‘æé†’
â”œâ”€â”€ ğŸ“  ç»ƒä¹ é¢˜
â””â”€â”€ ğŸ“š  ç« èŠ‚æ€»ç»“
```

---

## ğŸŒŸ Ginæ¡†æ¶æ¦‚è¿°

### ä»€ä¹ˆæ˜¯Ginï¼Ÿ

Ginæ˜¯ä¸€ä¸ªç”¨Goè¯­è¨€ç¼–å†™çš„HTTP Webæ¡†æ¶ï¼Œä»¥å…¶é«˜æ€§èƒ½å’Œç®€æ´çš„APIè®¾è®¡è€Œé—»åã€‚å®ƒæä¾›äº†ç±»ä¼¼Martiniçš„APIï¼Œä½†æ€§èƒ½æ¯”Martiniå¿«40å€ã€‚

```go
// æ¥è‡ª mall-go/main.go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

/*
Ginæ¡†æ¶çš„æ ¸å¿ƒç‰¹æ€§ï¼š

1. é«˜æ€§èƒ½ï¼šåŸºäºhttprouterï¼Œæ€§èƒ½ä¼˜å¼‚
2. ä¸­é—´ä»¶æ”¯æŒï¼šä¸°å¯Œçš„ä¸­é—´ä»¶ç”Ÿæ€
3. JSONéªŒè¯ï¼šå†…ç½®JSONç»‘å®šå’ŒéªŒè¯
4. è·¯ç”±ç»„ï¼šæ”¯æŒè·¯ç”±åˆ†ç»„å’ŒåµŒå¥—
5. é”™è¯¯ç®¡ç†ï¼šä¼˜é›…çš„é”™è¯¯å¤„ç†æœºåˆ¶
6. æ¸²æŸ“å†…ç½®ï¼šæ”¯æŒJSONã€XMLã€HTMLç­‰å¤šç§æ¸²æŸ“
7. å¯æ‰©å±•ï¼šæ˜“äºæ‰©å±•å’Œè‡ªå®šä¹‰
*/

func main() {
    // åˆ›å»ºGinå¼•æ“
    r := gin.Default()
    
    // å®šä¹‰è·¯ç”±
    r.GET("/ping", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "message": "pong",
        })
    })
    
    // å¯åŠ¨æœåŠ¡å™¨
    r.Run(":8080")
}
```

### Gin vs å…¶ä»–Webæ¡†æ¶å¯¹æ¯”

#### ä¸Java Spring Bootå¯¹æ¯”

```java
// Java Spring Boot
@RestController
@RequestMapping("/api")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/users/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        return ResponseEntity.ok(user);
    }
    
    @PostMapping("/users")
    public ResponseEntity<User> createUser(@RequestBody @Valid User user) {
        User savedUser = userService.save(user);
        return ResponseEntity.status(HttpStatus.CREATED).body(savedUser);
    }
}
```

```go
// Go Ginç­‰ä»·å®ç°
package main

import (
    "net/http"
    "strconv"
    
    "github.com/gin-gonic/gin"
)

type UserController struct {
    userService *UserService
}

func NewUserController(userService *UserService) *UserController {
    return &UserController{userService: userService}
}

func (uc *UserController) GetUser(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
        return
    }
    
    user, err := uc.userService.FindByID(id)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
        return
    }
    
    c.JSON(http.StatusOK, user)
}

func (uc *UserController) CreateUser(c *gin.Context) {
    var user User
    if err := c.ShouldBindJSON(&user); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    savedUser, err := uc.userService.Save(&user)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save user"})
        return
    }
    
    c.JSON(http.StatusCreated, savedUser)
}

func setupRoutes(r *gin.Engine, userController *UserController) {
    api := r.Group("/api")
    {
        api.GET("/users/:id", userController.GetUser)
        api.POST("/users", userController.CreateUser)
    }
}
```

#### ä¸Python Flaskå¯¹æ¯”

```python
# Python Flask
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'
db = SQLAlchemy(app)

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), nullable=False)
    email = db.Column(db.String(120), nullable=False)

@app.route('/api/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    user = User.query.get_or_404(user_id)
    return jsonify({
        'id': user.id,
        'name': user.name,
        'email': user.email
    })

@app.route('/api/users', methods=['POST'])
def create_user():
    data = request.get_json()
    user = User(name=data['name'], email=data['email'])
    db.session.add(user)
    db.session.commit()
    return jsonify({'id': user.id}), 201

if __name__ == '__main__':
    app.run(debug=True)
```

```go
// Go Ginç­‰ä»·å®ç°
package main

import (
    "net/http"
    "strconv"
    
    "github.com/gin-gonic/gin"
    "gorm.io/gorm"
)

type User struct {
    ID    uint   `json:"id" gorm:"primaryKey"`
    Name  string `json:"name" binding:"required"`
    Email string `json:"email" binding:"required,email"`
}

type UserHandler struct {
    db *gorm.DB
}

func NewUserHandler(db *gorm.DB) *UserHandler {
    return &UserHandler{db: db}
}

func (h *UserHandler) GetUser(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
        return
    }
    
    var user User
    if err := h.db.First(&user, uint(id)).Error; err != nil {
        if err == gorm.ErrRecordNotFound {
            c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
            return
        }
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error"})
        return
    }
    
    c.JSON(http.StatusOK, user)
}

func (h *UserHandler) CreateUser(c *gin.Context) {
    var user User
    if err := c.ShouldBindJSON(&user); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    if err := h.db.Create(&user).Error; err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create user"})
        return
    }
    
    c.JSON(http.StatusCreated, gin.H{"id": user.ID})
}

func main() {
    // æ•°æ®åº“è¿æ¥çœç•¥...
    
    r := gin.Default()
    userHandler := NewUserHandler(db)
    
    api := r.Group("/api")
    {
        api.GET("/users/:id", userHandler.GetUser)
        api.POST("/users", userHandler.CreateUser)
    }
    
    r.Run(":8080")
}
```

### æ¡†æ¶å¯¹æ¯”æ€»ç»“

| ç‰¹æ€§ | Gin (Go) | Spring Boot (Java) | Flask (Python) |
|------|----------|-------------------|----------------|
| **æ€§èƒ½** | æé«˜ | ä¸­ç­‰ | è¾ƒä½ |
| **å†…å­˜å ç”¨** | å¾ˆä½ | è¾ƒé«˜ | ä¸­ç­‰ |
| **å¯åŠ¨é€Ÿåº¦** | æå¿« | è¾ƒæ…¢ | å¿« |
| **å­¦ä¹ æ›²çº¿** | å¹³ç¼“ | é™¡å³­ | å¹³ç¼“ |
| **ç”Ÿæ€ç³»ç»Ÿ** | å¿«é€Ÿå‘å±• | éå¸¸æˆç†Ÿ | æˆç†Ÿ |
| **å¹¶å‘å¤„ç†** | åŸç”Ÿæ”¯æŒ | çº¿ç¨‹æ±  | éœ€è¦é¢å¤–é…ç½® |
| **éƒ¨ç½²å¤æ‚åº¦** | ç®€å• | å¤æ‚ | ä¸­ç­‰ |

---

## ğŸš€ å¿«é€Ÿå¼€å§‹

è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªå®Œæ•´çš„ç¤ºä¾‹æ¥å¿«é€Ÿä¸Šæ‰‹Ginæ¡†æ¶ã€‚

### é¡¹ç›®åˆå§‹åŒ–

```bash
# åˆ›å»ºé¡¹ç›®ç›®å½•
mkdir gin-demo
cd gin-demo

# åˆå§‹åŒ–Goæ¨¡å—
go mod init gin-demo

# å®‰è£…Ginæ¡†æ¶
go get github.com/gin-gonic/gin
```

### ç¬¬ä¸€ä¸ªGinåº”ç”¨

```go
// æ¥è‡ª mall-go/cmd/server/main.go
package main

import (
    "log"
    "net/http"
    
    "github.com/gin-gonic/gin"
)

// ç”¨æˆ·æ•°æ®ç»“æ„
type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

// æ¨¡æ‹Ÿæ•°æ®åº“
var users = []User{
    {ID: 1, Name: "å¼ ä¸‰", Email: "zhangsan@example.com"},
    {ID: 2, Name: "æå››", Email: "lisi@example.com"},
}

func main() {
    // è®¾ç½®Ginæ¨¡å¼
    gin.SetMode(gin.ReleaseMode) // ç”Ÿäº§ç¯å¢ƒ
    // gin.SetMode(gin.DebugMode)   // å¼€å‘ç¯å¢ƒ
    
    // åˆ›å»ºGinå¼•æ“
    r := gin.Default()
    
    // æ·»åŠ ä¸­é—´ä»¶
    r.Use(gin.Logger())
    r.Use(gin.Recovery())
    
    // å¥åº·æ£€æŸ¥ç«¯ç‚¹
    r.GET("/health", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "status": "ok",
            "message": "Service is running",
        })
    })
    
    // APIè·¯ç”±ç»„
    api := r.Group("/api/v1")
    {
        // è·å–æ‰€æœ‰ç”¨æˆ·
        api.GET("/users", getUsers)
        
        // è·å–å•ä¸ªç”¨æˆ·
        api.GET("/users/:id", getUser)
        
        // åˆ›å»ºç”¨æˆ·
        api.POST("/users", createUser)
        
        // æ›´æ–°ç”¨æˆ·
        api.PUT("/users/:id", updateUser)
        
        // åˆ é™¤ç”¨æˆ·
        api.DELETE("/users/:id", deleteUser)
    }
    
    // å¯åŠ¨æœåŠ¡å™¨
    log.Println("Server starting on :8080")
    if err := r.Run(":8080"); err != nil {
        log.Fatal("Failed to start server:", err)
    }
}

// è·å–æ‰€æœ‰ç”¨æˆ·
func getUsers(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{
        "code": 200,
        "message": "success",
        "data": users,
    })
}

// è·å–å•ä¸ªç”¨æˆ·
func getUserByID(id int) *User {
    for i, user := range users {
        if user.ID == id {
            return &users[i]
        }
    }
    return nil
}

func getUser(c *gin.Context) {
    // è·å–è·¯å¾„å‚æ•°
    idStr := c.Param("id")
    id := 0
    
    // å‚æ•°è½¬æ¢
    if _, err := fmt.Sscanf(idStr, "%d", &id); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "code": 400,
            "message": "Invalid user ID",
        })
        return
    }
    
    // æŸ¥æ‰¾ç”¨æˆ·
    user := getUserByID(id)
    if user == nil {
        c.JSON(http.StatusNotFound, gin.H{
            "code": 404,
            "message": "User not found",
        })
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "code": 200,
        "message": "success",
        "data": user,
    })
}

// åˆ›å»ºç”¨æˆ·
func createUser(c *gin.Context) {
    var newUser User
    
    // ç»‘å®šJSONæ•°æ®
    if err := c.ShouldBindJSON(&newUser); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "code": 400,
            "message": "Invalid request data",
            "error": err.Error(),
        })
        return
    }
    
    // ç”Ÿæˆæ–°ID
    newUser.ID = len(users) + 1
    
    // æ·»åŠ åˆ°"æ•°æ®åº“"
    users = append(users, newUser)
    
    c.JSON(http.StatusCreated, gin.H{
        "code": 201,
        "message": "User created successfully",
        "data": newUser,
    })
}

// æ›´æ–°ç”¨æˆ·
func updateUser(c *gin.Context) {
    idStr := c.Param("id")
    id := 0
    
    if _, err := fmt.Sscanf(idStr, "%d", &id); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "code": 400,
            "message": "Invalid user ID",
        })
        return
    }
    
    // æŸ¥æ‰¾ç”¨æˆ·ç´¢å¼•
    userIndex := -1
    for i, user := range users {
        if user.ID == id {
            userIndex = i
            break
        }
    }
    
    if userIndex == -1 {
        c.JSON(http.StatusNotFound, gin.H{
            "code": 404,
            "message": "User not found",
        })
        return
    }
    
    var updatedUser User
    if err := c.ShouldBindJSON(&updatedUser); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "code": 400,
            "message": "Invalid request data",
            "error": err.Error(),
        })
        return
    }
    
    // ä¿æŒåŸID
    updatedUser.ID = id
    users[userIndex] = updatedUser
    
    c.JSON(http.StatusOK, gin.H{
        "code": 200,
        "message": "User updated successfully",
        "data": updatedUser,
    })
}

// åˆ é™¤ç”¨æˆ·
func deleteUser(c *gin.Context) {
    idStr := c.Param("id")
    id := 0
    
    if _, err := fmt.Sscanf(idStr, "%d", &id); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "code": 400,
            "message": "Invalid user ID",
        })
        return
    }
    
    // æŸ¥æ‰¾å¹¶åˆ é™¤ç”¨æˆ·
    for i, user := range users {
        if user.ID == id {
            users = append(users[:i], users[i+1:]...)
            c.JSON(http.StatusOK, gin.H{
                "code": 200,
                "message": "User deleted successfully",
            })
            return
        }
    }
    
    c.JSON(http.StatusNotFound, gin.H{
        "code": 404,
        "message": "User not found",
    })
}
```

### æµ‹è¯•API

```bash
# å¯åŠ¨æœåŠ¡å™¨
go run main.go

# æµ‹è¯•å¥åº·æ£€æŸ¥
curl http://localhost:8080/health

# è·å–æ‰€æœ‰ç”¨æˆ·
curl http://localhost:8080/api/v1/users

# è·å–å•ä¸ªç”¨æˆ·
curl http://localhost:8080/api/v1/users/1

# åˆ›å»ºç”¨æˆ·
curl -X POST http://localhost:8080/api/v1/users \
  -H "Content-Type: application/json" \
  -d '{"name":"ç‹äº”","email":"wangwu@example.com"}'

# æ›´æ–°ç”¨æˆ·
curl -X PUT http://localhost:8080/api/v1/users/1 \
  -H "Content-Type: application/json" \
  -d '{"name":"å¼ ä¸‰ä¸‰","email":"zhangsan@newdomain.com"}'

# åˆ é™¤ç”¨æˆ·
curl -X DELETE http://localhost:8080/api/v1/users/2
```

---

## ğŸ›£ï¸ è·¯ç”±ç³»ç»Ÿè¯¦è§£

Ginçš„è·¯ç”±ç³»ç»Ÿæ˜¯å…¶æ ¸å¿ƒåŠŸèƒ½ä¹‹ä¸€ï¼Œæ”¯æŒRESTfulè®¾è®¡å’Œçµæ´»çš„è·¯ç”±ç»„ç»‡ã€‚

### åŸºç¡€è·¯ç”±

```go
// æ¥è‡ª mall-go/internal/router/router.go
package router

import (
    "net/http"

    "github.com/gin-gonic/gin"
)

func SetupBasicRoutes(r *gin.Engine) {
    // HTTPæ–¹æ³•è·¯ç”±
    r.GET("/get", handleGet)
    r.POST("/post", handlePost)
    r.PUT("/put", handlePut)
    r.DELETE("/delete", handleDelete)
    r.PATCH("/patch", handlePatch)
    r.HEAD("/head", handleHead)
    r.OPTIONS("/options", handleOptions)

    // ä»»æ„æ–¹æ³•è·¯ç”±
    r.Any("/any", handleAny)

    // é™æ€æ–‡ä»¶æœåŠ¡
    r.Static("/static", "./static")
    r.StaticFS("/assets", http.Dir("./assets"))
    r.StaticFile("/favicon.ico", "./favicon.ico")

    // HTMLæ¨¡æ¿
    r.LoadHTMLGlob("templates/*")
    r.GET("/html", func(c *gin.Context) {
        c.HTML(http.StatusOK, "index.html", gin.H{
            "title": "Gin HTML Template",
        })
    })
}

func handleGet(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{"method": "GET"})
}

func handlePost(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{"method": "POST"})
}

func handlePut(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{"method": "PUT"})
}

func handleDelete(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{"method": "DELETE"})
}

func handlePatch(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{"method": "PATCH"})
}

func handleHead(c *gin.Context) {
    c.Status(http.StatusOK)
}

func handleOptions(c *gin.Context) {
    c.Header("Allow", "GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS")
    c.Status(http.StatusOK)
}

func handleAny(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{
        "method": c.Request.Method,
        "message": "This endpoint accepts any HTTP method",
    })
}
```

### è·¯ç”±å‚æ•°

```go
// æ¥è‡ª mall-go/internal/router/params.go
package router

import (
    "net/http"
    "strconv"

    "github.com/gin-gonic/gin"
)

func SetupParamRoutes(r *gin.Engine) {
    // è·¯å¾„å‚æ•°
    r.GET("/users/:id", getUserByID)
    r.GET("/users/:id/posts/:postId", getUserPost)

    // é€šé…ç¬¦å‚æ•°
    r.GET("/files/*filepath", getFile)

    // æŸ¥è¯¢å‚æ•°
    r.GET("/search", searchUsers)

    // è¡¨å•å‚æ•°
    r.POST("/form", handleForm)

    // æ··åˆå‚æ•°
    r.GET("/users/:id/search", searchUserPosts)
}

// è·¯å¾„å‚æ•°å¤„ç†
func getUserByID(c *gin.Context) {
    // è·å–è·¯å¾„å‚æ•°
    idStr := c.Param("id")

    // å‚æ•°éªŒè¯å’Œè½¬æ¢
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "Invalid user ID",
            "code": "INVALID_PARAM",
        })
        return
    }

    // ä¸šåŠ¡é€»è¾‘
    user := findUserByID(id)
    if user == nil {
        c.JSON(http.StatusNotFound, gin.H{
            "error": "User not found",
            "code": "USER_NOT_FOUND",
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "data": user,
        "code": "SUCCESS",
    })
}

// å¤šä¸ªè·¯å¾„å‚æ•°
func getUserPost(c *gin.Context) {
    userID := c.Param("id")
    postID := c.Param("postId")

    c.JSON(http.StatusOK, gin.H{
        "userID": userID,
        "postID": postID,
        "message": "User post retrieved",
    })
}

// é€šé…ç¬¦å‚æ•°
func getFile(c *gin.Context) {
    filepath := c.Param("filepath")

    // å®‰å…¨æ£€æŸ¥
    if filepath == "" {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "File path is required",
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "filepath": filepath,
        "message": "File path captured",
    })
}

// æŸ¥è¯¢å‚æ•°å¤„ç†
func searchUsers(c *gin.Context) {
    // è·å–æŸ¥è¯¢å‚æ•°
    keyword := c.Query("q")                    // å¿…éœ€å‚æ•°
    page := c.DefaultQuery("page", "1")       // å¸¦é»˜è®¤å€¼
    limit := c.DefaultQuery("limit", "10")    // å¸¦é»˜è®¤å€¼
    sortBy := c.Query("sort")                 // å¯é€‰å‚æ•°

    // å‚æ•°éªŒè¯
    if keyword == "" {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "Search keyword is required",
            "code": "MISSING_PARAM",
        })
        return
    }

    // å‚æ•°è½¬æ¢
    pageNum, err := strconv.Atoi(page)
    if err != nil || pageNum < 1 {
        pageNum = 1
    }

    limitNum, err := strconv.Atoi(limit)
    if err != nil || limitNum < 1 || limitNum > 100 {
        limitNum = 10
    }

    // æ„å»ºæœç´¢æ¡ä»¶
    searchParams := map[string]interface{}{
        "keyword": keyword,
        "page":    pageNum,
        "limit":   limitNum,
        "sort":    sortBy,
    }

    c.JSON(http.StatusOK, gin.H{
        "params": searchParams,
        "message": "Search parameters processed",
    })
}

// è¡¨å•å‚æ•°å¤„ç†
func handleForm(c *gin.Context) {
    // è·å–è¡¨å•å‚æ•°
    name := c.PostForm("name")
    email := c.DefaultPostForm("email", "")
    age := c.PostForm("age")

    // è·å–å¤šå€¼å‚æ•°
    hobbies := c.PostFormArray("hobbies")

    // å‚æ•°éªŒè¯
    if name == "" {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "Name is required",
        })
        return
    }

    // å¤„ç†æ•°æ®
    formData := gin.H{
        "name":    name,
        "email":   email,
        "age":     age,
        "hobbies": hobbies,
    }

    c.JSON(http.StatusOK, gin.H{
        "data": formData,
        "message": "Form data processed",
    })
}

// æ··åˆå‚æ•°å¤„ç†
func searchUserPosts(c *gin.Context) {
    // è·¯å¾„å‚æ•°
    userID := c.Param("id")

    // æŸ¥è¯¢å‚æ•°
    keyword := c.Query("q")
    category := c.DefaultQuery("category", "all")

    c.JSON(http.StatusOK, gin.H{
        "userID":   userID,
        "keyword":  keyword,
        "category": category,
        "message":  "Mixed parameters processed",
    })
}

// è¾…åŠ©å‡½æ•°
func findUserByID(id int64) map[string]interface{} {
    // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
    users := map[int64]map[string]interface{}{
        1: {"id": 1, "name": "å¼ ä¸‰", "email": "zhangsan@example.com"},
        2: {"id": 2, "name": "æå››", "email": "lisi@example.com"},
    }

    return users[id]
}
```

---

## ğŸ”§ ä¸­é—´ä»¶æœºåˆ¶

ä¸­é—´ä»¶æ˜¯Ginæ¡†æ¶çš„æ ¸å¿ƒç‰¹æ€§ä¹‹ä¸€ï¼Œæä¾›äº†å¼ºå¤§çš„è¯·æ±‚å¤„ç†èƒ½åŠ›ã€‚

### å†…ç½®ä¸­é—´ä»¶

```go
// æ¥è‡ª mall-go/internal/middleware/builtin.go
package middleware

import (
    "fmt"
    "net/http"
    "time"

    "github.com/gin-gonic/gin"
)

func SetupBuiltinMiddleware(r *gin.Engine) {
    // 1. Loggerä¸­é—´ä»¶ - è®°å½•è¯·æ±‚æ—¥å¿—
    r.Use(gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
        return fmt.Sprintf("%s - [%s] \"%s %s %s %d %s \"%s\" %s\"\n",
            param.ClientIP,
            param.TimeStamp.Format(time.RFC1123),
            param.Method,
            param.Path,
            param.Request.Proto,
            param.StatusCode,
            param.Latency,
            param.Request.UserAgent(),
            param.ErrorMessage,
        )
    }))

    // 2. Recoveryä¸­é—´ä»¶ - æ¢å¤panic
    r.Use(gin.CustomRecovery(func(c *gin.Context, recovered interface{}) {
        if err, ok := recovered.(string); ok {
            c.String(http.StatusInternalServerError, fmt.Sprintf("error: %s", err))
        }
        c.AbortWithStatus(http.StatusInternalServerError)
    }))

    // 3. CORSä¸­é—´ä»¶ - è·¨åŸŸèµ„æºå…±äº«
    r.Use(func(c *gin.Context) {
        method := c.Request.Method
        origin := c.Request.Header.Get("Origin")

        if origin != "" {
            c.Header("Access-Control-Allow-Origin", origin)
            c.Header("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE, UPDATE")
            c.Header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept, Authorization, Cache-Control, X-File-Name")
            c.Header("Access-Control-Expose-Headers", "Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Cache-Control, Content-Language, Content-Type")
            c.Header("Access-Control-Allow-Credentials", "true")
        }

        if method == "OPTIONS" {
            c.AbortWithStatus(http.StatusNoContent)
        }

        c.Next()
    })

    // 4. å®‰å…¨å¤´ä¸­é—´ä»¶
    r.Use(func(c *gin.Context) {
        c.Header("X-Frame-Options", "DENY")
        c.Header("X-Content-Type-Options", "nosniff")
        c.Header("X-XSS-Protection", "1; mode=block")
        c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")
        c.Next()
    })
}
```

### è‡ªå®šä¹‰ä¸­é—´ä»¶

```go
// æ¥è‡ª mall-go/internal/middleware/custom.go
package middleware

import (
    "fmt"
    "net/http"
    "strings"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/golang-jwt/jwt/v4"
)

// è¯·æ±‚IDä¸­é—´ä»¶
func RequestID() gin.HandlerFunc {
    return func(c *gin.Context) {
        requestID := c.GetHeader("X-Request-ID")
        if requestID == "" {
            requestID = generateRequestID()
        }

        c.Header("X-Request-ID", requestID)
        c.Set("request_id", requestID)
        c.Next()
    }
}

// é™æµä¸­é—´ä»¶
func RateLimit(maxRequests int, window time.Duration) gin.HandlerFunc {
    // ç®€å•çš„å†…å­˜é™æµå™¨
    requests := make(map[string][]time.Time)

    return func(c *gin.Context) {
        clientIP := c.ClientIP()
        now := time.Now()

        // æ¸…ç†è¿‡æœŸè¯·æ±‚
        if times, exists := requests[clientIP]; exists {
            var validTimes []time.Time
            for _, t := range times {
                if now.Sub(t) < window {
                    validTimes = append(validTimes, t)
                }
            }
            requests[clientIP] = validTimes
        }

        // æ£€æŸ¥è¯·æ±‚æ•°é‡
        if len(requests[clientIP]) >= maxRequests {
            c.JSON(http.StatusTooManyRequests, gin.H{
                "error": "Rate limit exceeded",
                "retry_after": window.Seconds(),
            })
            c.Abort()
            return
        }

        // è®°å½•å½“å‰è¯·æ±‚
        requests[clientIP] = append(requests[clientIP], now)
        c.Next()
    }
}

// JWTè®¤è¯ä¸­é—´ä»¶
func JWTAuth(secretKey string) gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": "Authorization header is required",
            })
            c.Abort()
            return
        }

        // æ£€æŸ¥Bearerå‰ç¼€
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        if tokenString == authHeader {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": "Bearer token is required",
            })
            c.Abort()
            return
        }

        // è§£æJWT token
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
            if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
                return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
            }
            return []byte(secretKey), nil
        })

        if err != nil || !token.Valid {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": "Invalid token",
            })
            c.Abort()
            return
        }

        // æå–ç”¨æˆ·ä¿¡æ¯
        if claims, ok := token.Claims.(jwt.MapClaims); ok {
            c.Set("user_id", claims["user_id"])
            c.Set("username", claims["username"])
            c.Set("role", claims["role"])
        }

        c.Next()
    }
}

// æƒé™æ£€æŸ¥ä¸­é—´ä»¶
func RequireRole(requiredRole string) gin.HandlerFunc {
    return func(c *gin.Context) {
        role, exists := c.Get("role")
        if !exists {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": "User role not found",
            })
            c.Abort()
            return
        }

        userRole, ok := role.(string)
        if !ok || userRole != requiredRole {
            c.JSON(http.StatusForbidden, gin.H{
                "error": "Insufficient permissions",
                "required_role": requiredRole,
                "user_role": userRole,
            })
            c.Abort()
            return
        }

        c.Next()
    }
}

// è¯·æ±‚ä½“å¤§å°é™åˆ¶ä¸­é—´ä»¶
func RequestSizeLimit(maxSize int64) gin.HandlerFunc {
    return func(c *gin.Context) {
        if c.Request.ContentLength > maxSize {
            c.JSON(http.StatusRequestEntityTooLarge, gin.H{
                "error": "Request body too large",
                "max_size": maxSize,
            })
            c.Abort()
            return
        }

        c.Request.Body = http.MaxBytesReader(c.Writer, c.Request.Body, maxSize)
        c.Next()
    }
}

// è¶…æ—¶ä¸­é—´ä»¶
func Timeout(timeout time.Duration) gin.HandlerFunc {
    return func(c *gin.Context) {
        ctx, cancel := context.WithTimeout(c.Request.Context(), timeout)
        defer cancel()

        c.Request = c.Request.WithContext(ctx)

        finished := make(chan struct{})
        go func() {
            c.Next()
            finished <- struct{}{}
        }()

        select {
        case <-finished:
            return
        case <-ctx.Done():
            c.JSON(http.StatusRequestTimeout, gin.H{
                "error": "Request timeout",
                "timeout": timeout.String(),
            })
            c.Abort()
        }
    }
}

// ç¼“å­˜ä¸­é—´ä»¶
func Cache(duration time.Duration) gin.HandlerFunc {
    cache := make(map[string]CacheEntry)

    return func(c *gin.Context) {
        // åªç¼“å­˜GETè¯·æ±‚
        if c.Request.Method != "GET" {
            c.Next()
            return
        }

        key := c.Request.URL.String()

        // æ£€æŸ¥ç¼“å­˜
        if entry, exists := cache[key]; exists {
            if time.Since(entry.Timestamp) < duration {
                c.Header("X-Cache", "HIT")
                c.Data(entry.StatusCode, entry.ContentType, entry.Body)
                c.Abort()
                return
            }
            delete(cache, key)
        }

        // åˆ›å»ºå“åº”å†™å…¥å™¨
        writer := &CacheWriter{
            ResponseWriter: c.Writer,
            body:          make([]byte, 0),
        }
        c.Writer = writer

        c.Next()

        // ç¼“å­˜å“åº”
        if writer.statusCode == http.StatusOK {
            cache[key] = CacheEntry{
                Body:        writer.body,
                StatusCode:  writer.statusCode,
                ContentType: writer.Header().Get("Content-Type"),
                Timestamp:   time.Now(),
            }
            c.Header("X-Cache", "MISS")
        }
    }
}

// è¾…åŠ©ç»“æ„ä½“å’Œå‡½æ•°
type CacheEntry struct {
    Body        []byte
    StatusCode  int
    ContentType string
    Timestamp   time.Time
}

type CacheWriter struct {
    gin.ResponseWriter
    body       []byte
    statusCode int
}

func (w *CacheWriter) Write(data []byte) (int, error) {
    w.body = append(w.body, data...)
    return w.ResponseWriter.Write(data)
}

func (w *CacheWriter) WriteHeader(statusCode int) {
    w.statusCode = statusCode
    w.ResponseWriter.WriteHeader(statusCode)
}

func generateRequestID() string {
    return fmt.Sprintf("%d-%d", time.Now().UnixNano(), rand.Intn(10000))
}
```

---

## ğŸ“ è¯·æ±‚ä¸å“åº”å¤„ç†

Ginæä¾›äº†ä¸°å¯Œçš„è¯·æ±‚ç»‘å®šå’Œå“åº”å¤„ç†åŠŸèƒ½ï¼Œè®©Webå¼€å‘æ›´åŠ ä¾¿æ·ã€‚

### è¯·æ±‚ç»‘å®š

```go
// æ¥è‡ª mall-go/internal/handler/binding.go
package handler

import (
    "net/http"
    "time"

    "github.com/gin-gonic/gin"
)

// ç”¨æˆ·æ³¨å†Œè¯·æ±‚ç»“æ„
type RegisterRequest struct {
    Username string `json:"username" binding:"required,min=3,max=20"`
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required,min=6"`
    Age      int    `json:"age" binding:"gte=0,lte=130"`
    Phone    string `json:"phone" binding:"omitempty,len=11"`
}

// ç”¨æˆ·ç™»å½•è¯·æ±‚ç»“æ„
type LoginRequest struct {
    Username string `json:"username" binding:"required"`
    Password string `json:"password" binding:"required"`
}

// äº§å“åˆ›å»ºè¯·æ±‚ç»“æ„
type CreateProductRequest struct {
    Name        string  `json:"name" binding:"required,max=100"`
    Description string  `json:"description" binding:"max=500"`
    Price       float64 `json:"price" binding:"required,gt=0"`
    CategoryID  uint    `json:"category_id" binding:"required"`
    Tags        []string `json:"tags" binding:"dive,max=20"`
}

// æŸ¥è¯¢å‚æ•°ç»“æ„
type ProductQuery struct {
    Page     int    `form:"page" binding:"omitempty,gte=1"`
    Limit    int    `form:"limit" binding:"omitempty,gte=1,lte=100"`
    Category string `form:"category"`
    MinPrice float64 `form:"min_price" binding:"omitempty,gte=0"`
    MaxPrice float64 `form:"max_price" binding:"omitempty,gte=0"`
    SortBy   string `form:"sort_by" binding:"omitempty,oneof=name price created_at"`
    Order    string `form:"order" binding:"omitempty,oneof=asc desc"`
}

// JSONç»‘å®šç¤ºä¾‹
func RegisterUser(c *gin.Context) {
    var req RegisterRequest

    // ShouldBindJSON - ç»‘å®šJSONæ•°æ®
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "Invalid request data",
            "details": err.Error(),
        })
        return
    }

    // ä¸šåŠ¡é€»è¾‘å¤„ç†
    user := &User{
        Username: req.Username,
        Email:    req.Email,
        Age:      req.Age,
        Phone:    req.Phone,
        CreatedAt: time.Now(),
    }

    // æ¨¡æ‹Ÿä¿å­˜ç”¨æˆ·
    if err := saveUser(user); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to create user",
        })
        return
    }

    c.JSON(http.StatusCreated, gin.H{
        "message": "User created successfully",
        "user_id": user.ID,
    })
}

// æŸ¥è¯¢å‚æ•°ç»‘å®šç¤ºä¾‹
func ListProducts(c *gin.Context) {
    var query ProductQuery

    // ShouldBindQuery - ç»‘å®šæŸ¥è¯¢å‚æ•°
    if err := c.ShouldBindQuery(&query); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "Invalid query parameters",
            "details": err.Error(),
        })
        return
    }

    // è®¾ç½®é»˜è®¤å€¼
    if query.Page == 0 {
        query.Page = 1
    }
    if query.Limit == 0 {
        query.Limit = 10
    }
    if query.SortBy == "" {
        query.SortBy = "created_at"
    }
    if query.Order == "" {
        query.Order = "desc"
    }

    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    filters := buildProductFilters(query)

    // æŸ¥è¯¢äº§å“
    products, total, err := queryProducts(filters, query.Page, query.Limit)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to query products",
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "data": products,
        "pagination": gin.H{
            "page":  query.Page,
            "limit": query.Limit,
            "total": total,
            "pages": (total + query.Limit - 1) / query.Limit,
        },
    })
}

// è¡¨å•ç»‘å®šç¤ºä¾‹
func UpdateProfile(c *gin.Context) {
    var form struct {
        Name     string `form:"name" binding:"required"`
        Email    string `form:"email" binding:"required,email"`
        Bio      string `form:"bio" binding:"max=200"`
        Avatar   string `form:"avatar" binding:"omitempty,url"`
    }

    // ShouldBind - è‡ªåŠ¨é€‰æ‹©ç»‘å®šæ–¹å¼
    if err := c.ShouldBind(&form); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "Invalid form data",
            "details": err.Error(),
        })
        return
    }

    userID := c.GetString("user_id")

    // æ›´æ–°ç”¨æˆ·èµ„æ–™
    if err := updateUserProfile(userID, form); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to update profile",
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "message": "Profile updated successfully",
    })
}

// URIå‚æ•°ç»‘å®šç¤ºä¾‹
func GetUserByID(c *gin.Context) {
    var uri struct {
        ID uint `uri:"id" binding:"required,gte=1"`
    }

    // ShouldBindUri - ç»‘å®šURIå‚æ•°
    if err := c.ShouldBindUri(&uri); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "Invalid user ID",
            "details": err.Error(),
        })
        return
    }

    user, err := findUserByID(uri.ID)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{
            "error": "User not found",
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "data": user,
    })
}

// å¤´éƒ¨ç»‘å®šç¤ºä¾‹
func GetUserAgent(c *gin.Context) {
    var header struct {
        UserAgent string `header:"User-Agent"`
        Accept    string `header:"Accept"`
        Language  string `header:"Accept-Language"`
    }

    // ShouldBindHeader - ç»‘å®šè¯·æ±‚å¤´
    if err := c.ShouldBindHeader(&header); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "Invalid headers",
            "details": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "user_agent": header.UserAgent,
        "accept": header.Accept,
        "language": header.Language,
    })
}
```

### æ•°æ®éªŒè¯

```go
// æ¥è‡ª mall-go/internal/validator/custom.go
package validator

import (
    "regexp"
    "strings"

    "github.com/gin-gonic/gin/binding"
    "github.com/go-playground/validator/v10"
)

// è‡ªå®šä¹‰éªŒè¯å™¨
func RegisterCustomValidators() {
    if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
        // æ³¨å†Œè‡ªå®šä¹‰éªŒè¯è§„åˆ™
        v.RegisterValidation("phone", validatePhone)
        v.RegisterValidation("password", validatePassword)
        v.RegisterValidation("username", validateUsername)
        v.RegisterValidation("slug", validateSlug)
    }
}

// æ‰‹æœºå·éªŒè¯
func validatePhone(fl validator.FieldLevel) bool {
    phone := fl.Field().String()
    // ç®€å•çš„ä¸­å›½æ‰‹æœºå·éªŒè¯
    matched, _ := regexp.MatchString(`^1[3-9]\d{9}$`, phone)
    return matched
}

// å¯†ç å¼ºåº¦éªŒè¯
func validatePassword(fl validator.FieldLevel) bool {
    password := fl.Field().String()

    // è‡³å°‘8ä½ï¼ŒåŒ…å«å¤§å°å†™å­—æ¯å’Œæ•°å­—
    if len(password) < 8 {
        return false
    }

    hasUpper := regexp.MustCompile(`[A-Z]`).MatchString(password)
    hasLower := regexp.MustCompile(`[a-z]`).MatchString(password)
    hasNumber := regexp.MustCompile(`\d`).MatchString(password)

    return hasUpper && hasLower && hasNumber
}

// ç”¨æˆ·åéªŒè¯
func validateUsername(fl validator.FieldLevel) bool {
    username := fl.Field().String()
    // åªå…è®¸å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿ï¼Œ3-20ä½
    matched, _ := regexp.MatchString(`^[a-zA-Z0-9_]{3,20}$`, username)
    return matched
}

// URL slugéªŒè¯
func validateSlug(fl validator.FieldLevel) bool {
    slug := fl.Field().String()
    // åªå…è®¸å°å†™å­—æ¯ã€æ•°å­—å’Œè¿å­—ç¬¦
    matched, _ := regexp.MatchString(`^[a-z0-9-]+$`, slug)
    return matched
}

// éªŒè¯é”™è¯¯å¤„ç†
func HandleValidationError(err error) gin.H {
    if validationErrors, ok := err.(validator.ValidationErrors); ok {
        errors := make(map[string]string)

        for _, e := range validationErrors {
            field := strings.ToLower(e.Field())

            switch e.Tag() {
            case "required":
                errors[field] = "This field is required"
            case "email":
                errors[field] = "Invalid email format"
            case "min":
                errors[field] = fmt.Sprintf("Minimum length is %s", e.Param())
            case "max":
                errors[field] = fmt.Sprintf("Maximum length is %s", e.Param())
            case "gte":
                errors[field] = fmt.Sprintf("Value must be greater than or equal to %s", e.Param())
            case "lte":
                errors[field] = fmt.Sprintf("Value must be less than or equal to %s", e.Param())
            case "phone":
                errors[field] = "Invalid phone number format"
            case "password":
                errors[field] = "Password must be at least 8 characters with uppercase, lowercase and number"
            case "username":
                errors[field] = "Username can only contain letters, numbers and underscores (3-20 characters)"
            case "slug":
                errors[field] = "Slug can only contain lowercase letters, numbers and hyphens"
            default:
                errors[field] = "Invalid value"
            }
        }

        return gin.H{
            "error": "Validation failed",
            "fields": errors,
        }
    }

    return gin.H{
        "error": "Invalid request data",
        "message": err.Error(),
    }
}
```

### å“åº”æ ¼å¼

```go
// æ¥è‡ª mall-go/internal/response/response.go
package response

import (
    "net/http"
    "time"

    "github.com/gin-gonic/gin"
)

// ç»Ÿä¸€å“åº”ç»“æ„
type Response struct {
    Code      int         `json:"code"`
    Message   string      `json:"message"`
    Data      interface{} `json:"data,omitempty"`
    Timestamp int64       `json:"timestamp"`
    RequestID string      `json:"request_id,omitempty"`
}

// åˆ†é¡µå“åº”ç»“æ„
type PaginatedResponse struct {
    Code       int         `json:"code"`
    Message    string      `json:"message"`
    Data       interface{} `json:"data"`
    Pagination Pagination  `json:"pagination"`
    Timestamp  int64       `json:"timestamp"`
    RequestID  string      `json:"request_id,omitempty"`
}

type Pagination struct {
    Page       int `json:"page"`
    Limit      int `json:"limit"`
    Total      int `json:"total"`
    TotalPages int `json:"total_pages"`
}

// æˆåŠŸå“åº”
func Success(c *gin.Context, data interface{}) {
    response := Response{
        Code:      200,
        Message:   "Success",
        Data:      data,
        Timestamp: time.Now().Unix(),
        RequestID: getRequestID(c),
    }
    c.JSON(http.StatusOK, response)
}

// åˆ›å»ºæˆåŠŸå“åº”
func Created(c *gin.Context, data interface{}) {
    response := Response{
        Code:      201,
        Message:   "Created successfully",
        Data:      data,
        Timestamp: time.Now().Unix(),
        RequestID: getRequestID(c),
    }
    c.JSON(http.StatusCreated, response)
}

// åˆ†é¡µå“åº”
func Paginated(c *gin.Context, data interface{}, page, limit, total int) {
    totalPages := (total + limit - 1) / limit

    response := PaginatedResponse{
        Code:    200,
        Message: "Success",
        Data:    data,
        Pagination: Pagination{
            Page:       page,
            Limit:      limit,
            Total:      total,
            TotalPages: totalPages,
        },
        Timestamp: time.Now().Unix(),
        RequestID: getRequestID(c),
    }
    c.JSON(http.StatusOK, response)
}

// é”™è¯¯å“åº”
func Error(c *gin.Context, code int, message string) {
    response := Response{
        Code:      code,
        Message:   message,
        Timestamp: time.Now().Unix(),
        RequestID: getRequestID(c),
    }
    c.JSON(code, response)
}

// éªŒè¯é”™è¯¯å“åº”
func ValidationError(c *gin.Context, errors interface{}) {
    response := gin.H{
        "code":      400,
        "message":   "Validation failed",
        "errors":    errors,
        "timestamp": time.Now().Unix(),
        "request_id": getRequestID(c),
    }
    c.JSON(http.StatusBadRequest, response)
}

// æœªæˆæƒå“åº”
func Unauthorized(c *gin.Context, message string) {
    if message == "" {
        message = "Unauthorized"
    }
    Error(c, http.StatusUnauthorized, message)
}

// ç¦æ­¢è®¿é—®å“åº”
func Forbidden(c *gin.Context, message string) {
    if message == "" {
        message = "Forbidden"
    }
    Error(c, http.StatusForbidden, message)
}

// æœªæ‰¾åˆ°å“åº”
func NotFound(c *gin.Context, message string) {
    if message == "" {
        message = "Resource not found"
    }
    Error(c, http.StatusNotFound, message)
}

// æœåŠ¡å™¨é”™è¯¯å“åº”
func InternalError(c *gin.Context, message string) {
    if message == "" {
        message = "Internal server error"
    }
    Error(c, http.StatusInternalServerError, message)
}

// è·å–è¯·æ±‚ID
func getRequestID(c *gin.Context) string {
    if requestID, exists := c.Get("request_id"); exists {
        return requestID.(string)
    }
    return ""
}
```

### æ–‡ä»¶ä¸Šä¼ 

```go
// æ¥è‡ª mall-go/internal/handler/upload.go
package handler

import (
    "fmt"
    "io"
    "mime/multipart"
    "net/http"
    "os"
    "path/filepath"
    "strings"
    "time"

    "github.com/gin-gonic/gin"
)

// æ–‡ä»¶ä¸Šä¼ é…ç½®
type UploadConfig struct {
    MaxSize      int64    // æœ€å¤§æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
    AllowedTypes []string // å…è®¸çš„æ–‡ä»¶ç±»å‹
    UploadDir    string   // ä¸Šä¼ ç›®å½•
}

var defaultUploadConfig = UploadConfig{
    MaxSize:      10 << 20, // 10MB
    AllowedTypes: []string{".jpg", ".jpeg", ".png", ".gif", ".pdf", ".doc", ".docx"},
    UploadDir:    "./uploads",
}

// å•æ–‡ä»¶ä¸Šä¼ 
func UploadSingleFile(c *gin.Context) {
    // è·å–ä¸Šä¼ çš„æ–‡ä»¶
    file, header, err := c.Request.FormFile("file")
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "No file uploaded",
        })
        return
    }
    defer file.Close()

    // éªŒè¯æ–‡ä»¶
    if err := validateFile(header, defaultUploadConfig); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": err.Error(),
        })
        return
    }

    // ç”Ÿæˆæ–‡ä»¶å
    filename := generateFilename(header.Filename)
    filepath := filepath.Join(defaultUploadConfig.UploadDir, filename)

    // ç¡®ä¿ä¸Šä¼ ç›®å½•å­˜åœ¨
    if err := os.MkdirAll(defaultUploadConfig.UploadDir, 0755); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to create upload directory",
        })
        return
    }

    // ä¿å­˜æ–‡ä»¶
    if err := saveUploadedFile(file, filepath); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to save file",
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "message": "File uploaded successfully",
        "filename": filename,
        "size": header.Size,
        "url": fmt.Sprintf("/uploads/%s", filename),
    })
}

// å¤šæ–‡ä»¶ä¸Šä¼ 
func UploadMultipleFiles(c *gin.Context) {
    form, err := c.MultipartForm()
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "Failed to parse multipart form",
        })
        return
    }

    files := form.File["files"]
    if len(files) == 0 {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "No files uploaded",
        })
        return
    }

    var uploadedFiles []gin.H
    var errors []string

    for _, header := range files {
        // éªŒè¯æ–‡ä»¶
        if err := validateFileHeader(header, defaultUploadConfig); err != nil {
            errors = append(errors, fmt.Sprintf("%s: %s", header.Filename, err.Error()))
            continue
        }

        // æ‰“å¼€æ–‡ä»¶
        file, err := header.Open()
        if err != nil {
            errors = append(errors, fmt.Sprintf("%s: failed to open file", header.Filename))
            continue
        }

        // ç”Ÿæˆæ–‡ä»¶åå¹¶ä¿å­˜
        filename := generateFilename(header.Filename)
        filepath := filepath.Join(defaultUploadConfig.UploadDir, filename)

        if err := saveUploadedFile(file, filepath); err != nil {
            errors = append(errors, fmt.Sprintf("%s: failed to save file", header.Filename))
            file.Close()
            continue
        }

        file.Close()

        uploadedFiles = append(uploadedFiles, gin.H{
            "original_name": header.Filename,
            "filename": filename,
            "size": header.Size,
            "url": fmt.Sprintf("/uploads/%s", filename),
        })
    }

    response := gin.H{
        "message": fmt.Sprintf("Uploaded %d files successfully", len(uploadedFiles)),
        "files": uploadedFiles,
    }

    if len(errors) > 0 {
        response["errors"] = errors
    }

    c.JSON(http.StatusOK, response)
}

// å¤´åƒä¸Šä¼ ï¼ˆå¸¦å›¾ç‰‡å¤„ç†ï¼‰
func UploadAvatar(c *gin.Context) {
    file, header, err := c.Request.FormFile("avatar")
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "No avatar file uploaded",
        })
        return
    }
    defer file.Close()

    // éªŒè¯å›¾ç‰‡æ–‡ä»¶
    config := UploadConfig{
        MaxSize:      2 << 20, // 2MB
        AllowedTypes: []string{".jpg", ".jpeg", ".png"},
        UploadDir:    "./uploads/avatars",
    }

    if err := validateFile(header, config); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": err.Error(),
        })
        return
    }

    // è·å–ç”¨æˆ·ID
    userID := c.GetString("user_id")
    if userID == "" {
        c.JSON(http.StatusUnauthorized, gin.H{
            "error": "User not authenticated",
        })
        return
    }

    // ç”Ÿæˆå¤´åƒæ–‡ä»¶å
    ext := filepath.Ext(header.Filename)
    filename := fmt.Sprintf("avatar_%s_%d%s", userID, time.Now().Unix(), ext)
    filepath := filepath.Join(config.UploadDir, filename)

    // ç¡®ä¿ç›®å½•å­˜åœ¨
    if err := os.MkdirAll(config.UploadDir, 0755); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to create upload directory",
        })
        return
    }

    // ä¿å­˜æ–‡ä»¶
    if err := saveUploadedFile(file, filepath); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to save avatar",
        })
        return
    }

    // æ›´æ–°ç”¨æˆ·å¤´åƒURL
    avatarURL := fmt.Sprintf("/uploads/avatars/%s", filename)
    if err := updateUserAvatar(userID, avatarURL); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to update user avatar",
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "message": "Avatar uploaded successfully",
        "avatar_url": avatarURL,
    })
}

// æ–‡ä»¶éªŒè¯
func validateFile(header *multipart.FileHeader, config UploadConfig) error {
    // æ£€æŸ¥æ–‡ä»¶å¤§å°
    if header.Size > config.MaxSize {
        return fmt.Errorf("file size exceeds limit (%d bytes)", config.MaxSize)
    }

    // æ£€æŸ¥æ–‡ä»¶ç±»å‹
    ext := strings.ToLower(filepath.Ext(header.Filename))
    allowed := false
    for _, allowedType := range config.AllowedTypes {
        if ext == allowedType {
            allowed = true
            break
        }
    }

    if !allowed {
        return fmt.Errorf("file type %s not allowed", ext)
    }

    return nil
}

func validateFileHeader(header *multipart.FileHeader, config UploadConfig) error {
    return validateFile(header, config)
}

// ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
func generateFilename(originalName string) string {
    ext := filepath.Ext(originalName)
    name := strings.TrimSuffix(originalName, ext)

    // æ¸…ç†æ–‡ä»¶å
    name = strings.ReplaceAll(name, " ", "_")
    name = strings.ReplaceAll(name, "(", "")
    name = strings.ReplaceAll(name, ")", "")

    // æ·»åŠ æ—¶é—´æˆ³
    timestamp := time.Now().Unix()
    return fmt.Sprintf("%s_%d%s", name, timestamp, ext)
}

// ä¿å­˜ä¸Šä¼ çš„æ–‡ä»¶
func saveUploadedFile(src multipart.File, dst string) error {
    out, err := os.Create(dst)
    if err != nil {
        return err
    }
    defer out.Close()

    _, err = io.Copy(out, src)
    return err
}

// æ›´æ–°ç”¨æˆ·å¤´åƒï¼ˆæ¨¡æ‹Ÿï¼‰
func updateUserAvatar(userID, avatarURL string) error {
    // è¿™é‡Œåº”è¯¥æ˜¯æ•°æ®åº“æ›´æ–°æ“ä½œ
    fmt.Printf("Updating user %s avatar to %s\n", userID, avatarURL)
    return nil
}
```

---

## ğŸ”’ è®¤è¯ä¸æˆæƒ

è®¤è¯å’Œæˆæƒæ˜¯Webåº”ç”¨çš„æ ¸å¿ƒå®‰å…¨åŠŸèƒ½ï¼ŒGinæä¾›äº†çµæ´»çš„ä¸­é—´ä»¶æœºåˆ¶æ¥å®ç°ã€‚

### JWTè®¤è¯å®ç°

```go
// æ¥è‡ª mall-go/internal/auth/jwt.go
package auth

import (
    "errors"
    "time"

    "github.com/golang-jwt/jwt/v4"
)

// JWTé…ç½®
type JWTConfig struct {
    SecretKey       string
    AccessTokenTTL  time.Duration
    RefreshTokenTTL time.Duration
    Issuer          string
}

// JWT Claims
type Claims struct {
    UserID   uint   `json:"user_id"`
    Username string `json:"username"`
    Email    string `json:"email"`
    Role     string `json:"role"`
    jwt.RegisteredClaims
}

// JWTæœåŠ¡
type JWTService struct {
    config JWTConfig
}

func NewJWTService(config JWTConfig) *JWTService {
    return &JWTService{config: config}
}

// ç”Ÿæˆè®¿é—®ä»¤ç‰Œ
func (j *JWTService) GenerateAccessToken(userID uint, username, email, role string) (string, error) {
    claims := Claims{
        UserID:   userID,
        Username: username,
        Email:    email,
        Role:     role,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(j.config.AccessTokenTTL)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            NotBefore: jwt.NewNumericDate(time.Now()),
            Issuer:    j.config.Issuer,
            Subject:   fmt.Sprintf("%d", userID),
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(j.config.SecretKey))
}

// ç”Ÿæˆåˆ·æ–°ä»¤ç‰Œ
func (j *JWTService) GenerateRefreshToken(userID uint) (string, error) {
    claims := jwt.RegisteredClaims{
        ExpiresAt: jwt.NewNumericDate(time.Now().Add(j.config.RefreshTokenTTL)),
        IssuedAt:  jwt.NewNumericDate(time.Now()),
        NotBefore: jwt.NewNumericDate(time.Now()),
        Issuer:    j.config.Issuer,
        Subject:   fmt.Sprintf("%d", userID),
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(j.config.SecretKey))
}

// éªŒè¯è®¿é—®ä»¤ç‰Œ
func (j *JWTService) ValidateAccessToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
        }
        return []byte(j.config.SecretKey), nil
    })

    if err != nil {
        return nil, err
    }

    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }

    return nil, errors.New("invalid token")
}

// éªŒè¯åˆ·æ–°ä»¤ç‰Œ
func (j *JWTService) ValidateRefreshToken(tokenString string) (uint, error) {
    token, err := jwt.ParseWithClaims(tokenString, &jwt.RegisteredClaims{}, func(token *jwt.Token) (interface{}, error) {
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
        }
        return []byte(j.config.SecretKey), nil
    })

    if err != nil {
        return 0, err
    }

    if claims, ok := token.Claims.(*jwt.RegisteredClaims); ok && token.Valid {
        userID, err := strconv.ParseUint(claims.Subject, 10, 32)
        if err != nil {
            return 0, err
        }
        return uint(userID), nil
    }

    return 0, errors.New("invalid refresh token")
}
```

### è®¤è¯å¤„ç†å™¨

```go
// æ¥è‡ª mall-go/internal/handler/auth.go
package handler

import (
    "net/http"
    "time"

    "github.com/gin-gonic/gin"
    "golang.org/x/crypto/bcrypt"
)

type AuthHandler struct {
    jwtService *JWTService
    userService *UserService
}

func NewAuthHandler(jwtService *JWTService, userService *UserService) *AuthHandler {
    return &AuthHandler{
        jwtService: jwtService,
        userService: userService,
    }
}

// ç”¨æˆ·æ³¨å†Œ
func (h *AuthHandler) Register(c *gin.Context) {
    var req RegisterRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "Invalid request data",
            "details": err.Error(),
        })
        return
    }

    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨
    if exists, err := h.userService.UserExists(req.Username, req.Email); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to check user existence",
        })
        return
    } else if exists {
        c.JSON(http.StatusConflict, gin.H{
            "error": "User already exists",
        })
        return
    }

    // åŠ å¯†å¯†ç 
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to hash password",
        })
        return
    }

    // åˆ›å»ºç”¨æˆ·
    user := &User{
        Username:  req.Username,
        Email:     req.Email,
        Password:  string(hashedPassword),
        Role:      "user",
        CreatedAt: time.Now(),
        UpdatedAt: time.Now(),
    }

    if err := h.userService.CreateUser(user); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to create user",
        })
        return
    }

    c.JSON(http.StatusCreated, gin.H{
        "message": "User registered successfully",
        "user": gin.H{
            "id":       user.ID,
            "username": user.Username,
            "email":    user.Email,
            "role":     user.Role,
        },
    })
}

// ç”¨æˆ·ç™»å½•
func (h *AuthHandler) Login(c *gin.Context) {
    var req LoginRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "Invalid request data",
            "details": err.Error(),
        })
        return
    }

    // æŸ¥æ‰¾ç”¨æˆ·
    user, err := h.userService.FindByUsername(req.Username)
    if err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{
            "error": "Invalid credentials",
        })
        return
    }

    // éªŒè¯å¯†ç 
    if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password)); err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{
            "error": "Invalid credentials",
        })
        return
    }

    // ç”Ÿæˆä»¤ç‰Œ
    accessToken, err := h.jwtService.GenerateAccessToken(user.ID, user.Username, user.Email, user.Role)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to generate access token",
        })
        return
    }

    refreshToken, err := h.jwtService.GenerateRefreshToken(user.ID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to generate refresh token",
        })
        return
    }

    // æ›´æ–°æœ€åç™»å½•æ—¶é—´
    h.userService.UpdateLastLogin(user.ID)

    c.JSON(http.StatusOK, gin.H{
        "message": "Login successful",
        "user": gin.H{
            "id":       user.ID,
            "username": user.Username,
            "email":    user.Email,
            "role":     user.Role,
        },
        "tokens": gin.H{
            "access_token":  accessToken,
            "refresh_token": refreshToken,
            "token_type":    "Bearer",
            "expires_in":    3600, // 1å°æ—¶
        },
    })
}

// åˆ·æ–°ä»¤ç‰Œ
func (h *AuthHandler) RefreshToken(c *gin.Context) {
    var req struct {
        RefreshToken string `json:"refresh_token" binding:"required"`
    }

    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "Invalid request data",
        })
        return
    }

    // éªŒè¯åˆ·æ–°ä»¤ç‰Œ
    userID, err := h.jwtService.ValidateRefreshToken(req.RefreshToken)
    if err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{
            "error": "Invalid refresh token",
        })
        return
    }

    // è·å–ç”¨æˆ·ä¿¡æ¯
    user, err := h.userService.FindByID(userID)
    if err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{
            "error": "User not found",
        })
        return
    }

    // ç”Ÿæˆæ–°çš„è®¿é—®ä»¤ç‰Œ
    accessToken, err := h.jwtService.GenerateAccessToken(user.ID, user.Username, user.Email, user.Role)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to generate access token",
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "access_token": accessToken,
        "token_type":   "Bearer",
        "expires_in":   3600,
    })
}

// ç”¨æˆ·ç™»å‡º
func (h *AuthHandler) Logout(c *gin.Context) {
    // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥å°†ä»¤ç‰ŒåŠ å…¥é»‘åå•
    // æˆ–è€…ä»Redisç­‰ç¼“å­˜ä¸­åˆ é™¤ä»¤ç‰Œ

    c.JSON(http.StatusOK, gin.H{
        "message": "Logout successful",
    })
}

// è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
func (h *AuthHandler) GetProfile(c *gin.Context) {
    userID, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, gin.H{
            "error": "User not authenticated",
        })
        return
    }

    user, err := h.userService.FindByID(userID.(uint))
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{
            "error": "User not found",
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "user": gin.H{
            "id":         user.ID,
            "username":   user.Username,
            "email":      user.Email,
            "role":       user.Role,
            "created_at": user.CreatedAt,
            "updated_at": user.UpdatedAt,
        },
    })
}
```

---

## ğŸ¢ å®æˆ˜æ¡ˆä¾‹åˆ†æ

è®©æˆ‘ä»¬é€šè¿‡mall-goé¡¹ç›®çš„çœŸå®æ¡ˆä¾‹ï¼Œçœ‹çœ‹å¦‚ä½•åœ¨ä¼ä¸šçº§é¡¹ç›®ä¸­åº”ç”¨Ginæ¡†æ¶ã€‚

### å•†åŸAPIæ¶æ„è®¾è®¡

```go
// æ¥è‡ª mall-go/cmd/api/main.go
package main

import (
    "log"
    "time"

    "github.com/gin-gonic/gin"
    "mall-go/internal/config"
    "mall-go/internal/handler"
    "mall-go/internal/middleware"
    "mall-go/internal/service"
    "mall-go/pkg/database"
    "mall-go/pkg/redis"
)

func main() {
    // åŠ è½½é…ç½®
    cfg := config.Load()

    // åˆå§‹åŒ–æ•°æ®åº“
    db, err := database.NewConnection(cfg.Database)
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }

    // åˆå§‹åŒ–Redis
    rdb := redis.NewClient(cfg.Redis)

    // åˆå§‹åŒ–æœåŠ¡å±‚
    userService := service.NewUserService(db, rdb)
    productService := service.NewProductService(db, rdb)
    orderService := service.NewOrderService(db, rdb)

    // åˆå§‹åŒ–JWTæœåŠ¡
    jwtService := auth.NewJWTService(auth.JWTConfig{
        SecretKey:       cfg.JWT.SecretKey,
        AccessTokenTTL:  time.Hour,
        RefreshTokenTTL: time.Hour * 24 * 7,
        Issuer:          "mall-go",
    })

    // åˆå§‹åŒ–å¤„ç†å™¨
    authHandler := handler.NewAuthHandler(jwtService, userService)
    userHandler := handler.NewUserHandler(userService)
    productHandler := handler.NewProductHandler(productService)
    orderHandler := handler.NewOrderHandler(orderService)

    // åˆ›å»ºGinå¼•æ“
    r := gin.New()

    // å…¨å±€ä¸­é—´ä»¶
    r.Use(middleware.Logger())
    r.Use(middleware.Recovery())
    r.Use(middleware.CORS())
    r.Use(middleware.RequestID())
    r.Use(middleware.RateLimit(100, time.Minute))

    // è®¾ç½®è·¯ç”±
    setupRoutes(r, authHandler, userHandler, productHandler, orderHandler, jwtService)

    // å¯åŠ¨æœåŠ¡å™¨
    log.Printf("Server starting on port %s", cfg.Server.Port)
    if err := r.Run(":" + cfg.Server.Port); err != nil {
        log.Fatal("Failed to start server:", err)
    }
}

func setupRoutes(
    r *gin.Engine,
    authHandler *handler.AuthHandler,
    userHandler *handler.UserHandler,
    productHandler *handler.ProductHandler,
    orderHandler *handler.OrderHandler,
    jwtService *auth.JWTService,
) {
    // å¥åº·æ£€æŸ¥
    r.GET("/health", func(c *gin.Context) {
        c.JSON(200, gin.H{"status": "ok"})
    })

    // APIç‰ˆæœ¬1
    v1 := r.Group("/api/v1")
    {
        // è®¤è¯ç›¸å…³è·¯ç”±ï¼ˆæ— éœ€è®¤è¯ï¼‰
        auth := v1.Group("/auth")
        {
            auth.POST("/register", authHandler.Register)
            auth.POST("/login", authHandler.Login)
            auth.POST("/refresh", authHandler.RefreshToken)
        }

        // å…¬å¼€äº§å“APIï¼ˆæ— éœ€è®¤è¯ï¼‰
        public := v1.Group("/public")
        {
            public.GET("/products", productHandler.ListProducts)
            public.GET("/products/:id", productHandler.GetProduct)
            public.GET("/categories", productHandler.ListCategories)
        }

        // éœ€è¦è®¤è¯çš„è·¯ç”±
        protected := v1.Group("")
        protected.Use(middleware.JWTAuth(jwtService))
        {
            // ç”¨æˆ·ç›¸å…³
            users := protected.Group("/users")
            {
                users.GET("/profile", authHandler.GetProfile)
                users.PUT("/profile", userHandler.UpdateProfile)
                users.POST("/avatar", userHandler.UploadAvatar)
                users.GET("/orders", userHandler.GetUserOrders)
            }

            // è®¢å•ç›¸å…³
            orders := protected.Group("/orders")
            {
                orders.GET("", orderHandler.ListOrders)
                orders.POST("", orderHandler.CreateOrder)
                orders.GET("/:id", orderHandler.GetOrder)
                orders.PUT("/:id/cancel", orderHandler.CancelOrder)
                orders.POST("/:id/pay", orderHandler.PayOrder)
            }

            // è´­ç‰©è½¦ç›¸å…³
            cart := protected.Group("/cart")
            {
                cart.GET("", orderHandler.GetCart)
                cart.POST("/items", orderHandler.AddToCart)
                cart.PUT("/items/:id", orderHandler.UpdateCartItem)
                cart.DELETE("/items/:id", orderHandler.RemoveFromCart)
                cart.DELETE("", orderHandler.ClearCart)
            }
        }

        // ç®¡ç†å‘˜è·¯ç”±
        admin := v1.Group("/admin")
        admin.Use(middleware.JWTAuth(jwtService))
        admin.Use(middleware.RequireRole("admin"))
        {
            // ç”¨æˆ·ç®¡ç†
            adminUsers := admin.Group("/users")
            {
                adminUsers.GET("", userHandler.AdminListUsers)
                adminUsers.GET("/:id", userHandler.AdminGetUser)
                adminUsers.PUT("/:id/status", userHandler.AdminUpdateUserStatus)
                adminUsers.DELETE("/:id", userHandler.AdminDeleteUser)
            }

            // äº§å“ç®¡ç†
            adminProducts := admin.Group("/products")
            {
                adminProducts.GET("", productHandler.AdminListProducts)
                adminProducts.POST("", productHandler.CreateProduct)
                adminProducts.PUT("/:id", productHandler.UpdateProduct)
                adminProducts.DELETE("/:id", productHandler.DeleteProduct)
                adminProducts.POST("/:id/images", productHandler.UploadProductImages)
            }

            // è®¢å•ç®¡ç†
            adminOrders := admin.Group("/orders")
            {
                adminOrders.GET("", orderHandler.AdminListOrders)
                adminOrders.GET("/:id", orderHandler.AdminGetOrder)
                adminOrders.PUT("/:id/status", orderHandler.AdminUpdateOrderStatus)
                adminOrders.GET("/statistics", orderHandler.GetOrderStatistics)
            }
        }
    }
}
```

### å•†å“æœåŠ¡å®ç°

```go
// æ¥è‡ª mall-go/internal/handler/product.go
package handler

import (
    "net/http"
    "strconv"

    "github.com/gin-gonic/gin"
    "mall-go/internal/model"
    "mall-go/internal/service"
    "mall-go/pkg/response"
)

type ProductHandler struct {
    productService *service.ProductService
}

func NewProductHandler(productService *service.ProductService) *ProductHandler {
    return &ProductHandler{productService: productService}
}

// è·å–äº§å“åˆ—è¡¨
func (h *ProductHandler) ListProducts(c *gin.Context) {
    var query struct {
        Page       int     `form:"page" binding:"omitempty,gte=1"`
        Limit      int     `form:"limit" binding:"omitempty,gte=1,lte=100"`
        CategoryID uint    `form:"category_id"`
        MinPrice   float64 `form:"min_price" binding:"omitempty,gte=0"`
        MaxPrice   float64 `form:"max_price" binding:"omitempty,gte=0"`
        Keyword    string  `form:"keyword"`
        SortBy     string  `form:"sort_by" binding:"omitempty,oneof=name price created_at"`
        Order      string  `form:"order" binding:"omitempty,oneof=asc desc"`
    }

    if err := c.ShouldBindQuery(&query); err != nil {
        response.ValidationError(c, err)
        return
    }

    // è®¾ç½®é»˜è®¤å€¼
    if query.Page == 0 {
        query.Page = 1
    }
    if query.Limit == 0 {
        query.Limit = 20
    }
    if query.SortBy == "" {
        query.SortBy = "created_at"
    }
    if query.Order == "" {
        query.Order = "desc"
    }

    // æ„å»ºè¿‡æ»¤æ¡ä»¶
    filters := service.ProductFilters{
        CategoryID: query.CategoryID,
        MinPrice:   query.MinPrice,
        MaxPrice:   query.MaxPrice,
        Keyword:    query.Keyword,
        SortBy:     query.SortBy,
        Order:      query.Order,
    }

    // æŸ¥è¯¢äº§å“
    products, total, err := h.productService.ListProducts(filters, query.Page, query.Limit)
    if err != nil {
        response.InternalError(c, "Failed to fetch products")
        return
    }

    response.Paginated(c, products, query.Page, query.Limit, total)
}

// è·å–å•ä¸ªäº§å“
func (h *ProductHandler) GetProduct(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        response.Error(c, http.StatusBadRequest, "Invalid product ID")
        return
    }

    product, err := h.productService.GetProduct(uint(id))
    if err != nil {
        if err == service.ErrProductNotFound {
            response.NotFound(c, "Product not found")
            return
        }
        response.InternalError(c, "Failed to fetch product")
        return
    }

    response.Success(c, product)
}

// åˆ›å»ºäº§å“ï¼ˆç®¡ç†å‘˜ï¼‰
func (h *ProductHandler) CreateProduct(c *gin.Context) {
    var req model.CreateProductRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.ValidationError(c, err)
        return
    }

    // è·å–å½“å‰ç”¨æˆ·ID
    userID, _ := c.Get("user_id")

    product := &model.Product{
        Name:        req.Name,
        Description: req.Description,
        Price:       req.Price,
        CategoryID:  req.CategoryID,
        Stock:       req.Stock,
        Status:      "active",
        CreatedBy:   userID.(uint),
    }

    if err := h.productService.CreateProduct(product); err != nil {
        response.InternalError(c, "Failed to create product")
        return
    }

    response.Created(c, product)
}

// æ›´æ–°äº§å“ï¼ˆç®¡ç†å‘˜ï¼‰
func (h *ProductHandler) UpdateProduct(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        response.Error(c, http.StatusBadRequest, "Invalid product ID")
        return
    }

    var req model.UpdateProductRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.ValidationError(c, err)
        return
    }

    // è·å–å½“å‰ç”¨æˆ·ID
    userID, _ := c.Get("user_id")

    if err := h.productService.UpdateProduct(uint(id), req, userID.(uint)); err != nil {
        if err == service.ErrProductNotFound {
            response.NotFound(c, "Product not found")
            return
        }
        response.InternalError(c, "Failed to update product")
        return
    }

    response.Success(c, gin.H{"message": "Product updated successfully"})
}

// åˆ é™¤äº§å“ï¼ˆç®¡ç†å‘˜ï¼‰
func (h *ProductHandler) DeleteProduct(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        response.Error(c, http.StatusBadRequest, "Invalid product ID")
        return
    }

    if err := h.productService.DeleteProduct(uint(id)); err != nil {
        if err == service.ErrProductNotFound {
            response.NotFound(c, "Product not found")
            return
        }
        response.InternalError(c, "Failed to delete product")
        return
    }

    response.Success(c, gin.H{"message": "Product deleted successfully"})
}

// ä¸Šä¼ äº§å“å›¾ç‰‡ï¼ˆç®¡ç†å‘˜ï¼‰
func (h *ProductHandler) UploadProductImages(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        response.Error(c, http.StatusBadRequest, "Invalid product ID")
        return
    }

    // æ£€æŸ¥äº§å“æ˜¯å¦å­˜åœ¨
    if _, err := h.productService.GetProduct(uint(id)); err != nil {
        if err == service.ErrProductNotFound {
            response.NotFound(c, "Product not found")
            return
        }
        response.InternalError(c, "Failed to fetch product")
        return
    }

    // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
    form, err := c.MultipartForm()
    if err != nil {
        response.Error(c, http.StatusBadRequest, "Failed to parse multipart form")
        return
    }

    files := form.File["images"]
    if len(files) == 0 {
        response.Error(c, http.StatusBadRequest, "No images uploaded")
        return
    }

    // ä¸Šä¼ å›¾ç‰‡
    imageURLs, err := h.productService.UploadProductImages(uint(id), files)
    if err != nil {
        response.InternalError(c, "Failed to upload images")
        return
    }

    response.Success(c, gin.H{
        "message": "Images uploaded successfully",
        "images":  imageURLs,
    })
}
```

---

## ğŸ¯ é¢è¯•å¸¸è€ƒç‚¹

### 1. Ginæ¡†æ¶çš„æ ¸å¿ƒç‰¹æ€§å’Œä¼˜åŠ¿

**é—®é¢˜ï¼š** Ginæ¡†æ¶ç›¸æ¯”å…¶ä»–Go Webæ¡†æ¶æœ‰ä»€ä¹ˆä¼˜åŠ¿ï¼Ÿ

**ç­”æ¡ˆï¼š**
```go
/*
Ginæ¡†æ¶çš„æ ¸å¿ƒä¼˜åŠ¿ï¼š

1. é«˜æ€§èƒ½ï¼š
   - åŸºäºhttprouterï¼Œè·¯ç”±æ€§èƒ½ä¼˜å¼‚
   - é›¶å†…å­˜åˆ†é…çš„è·¯ç”±å™¨
   - æ¯”Martiniå¿«40å€

2. ä¸­é—´ä»¶æ”¯æŒï¼š
   - ä¸°å¯Œçš„å†…ç½®ä¸­é—´ä»¶
   - æ˜“äºç¼–å†™è‡ªå®šä¹‰ä¸­é—´ä»¶
   - æ”¯æŒä¸­é—´ä»¶é“¾å¼è°ƒç”¨

3. JSONå¤„ç†ï¼š
   - å†…ç½®JSONç»‘å®šå’ŒéªŒè¯
   - æ”¯æŒå¤šç§æ•°æ®ç»‘å®šæ–¹å¼
   - è‡ªåŠ¨å‚æ•°éªŒè¯

4. è·¯ç”±åŠŸèƒ½ï¼š
   - æ”¯æŒRESTfulè·¯ç”±
   - è·¯ç”±åˆ†ç»„
   - å‚æ•°è·¯ç”±å’Œé€šé…ç¬¦

5. é”™è¯¯å¤„ç†ï¼š
   - å†…ç½®é”™è¯¯å¤„ç†æœºåˆ¶
   - æ”¯æŒè‡ªå®šä¹‰é”™è¯¯å¤„ç†
   - ä¼˜é›…çš„panicæ¢å¤

6. æ¸²æŸ“æ”¯æŒï¼š
   - æ”¯æŒJSONã€XMLã€HTMLç­‰å¤šç§æ ¼å¼
   - æ¨¡æ¿å¼•æ“æ”¯æŒ
   - é™æ€æ–‡ä»¶æœåŠ¡
*/

// æ€§èƒ½å¯¹æ¯”ç¤ºä¾‹
func BenchmarkGinRouter(b *testing.B) {
    r := gin.New()
    r.GET("/user/:id", func(c *gin.Context) {
        c.String(200, c.Param("id"))
    })

    req, _ := http.NewRequest("GET", "/user/123", nil)
    w := httptest.NewRecorder()

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        r.ServeHTTP(w, req)
    }
}
```

### 2. ä¸­é—´ä»¶çš„æ‰§è¡Œé¡ºåºå’ŒåŸç†

**é—®é¢˜ï¼š** Ginä¸­é—´ä»¶çš„æ‰§è¡Œé¡ºåºæ˜¯æ€æ ·çš„ï¼Ÿå¦‚ä½•å®ç°çš„ï¼Ÿ

**ç­”æ¡ˆï¼š**
```go
// ä¸­é—´ä»¶æ‰§è¡Œé¡ºåºç¤ºä¾‹
func MiddlewareOrder() {
    r := gin.New()

    // å…¨å±€ä¸­é—´ä»¶ï¼ˆæŒ‰æ³¨å†Œé¡ºåºæ‰§è¡Œï¼‰
    r.Use(Middleware1()) // ç¬¬ä¸€ä¸ªæ‰§è¡Œ
    r.Use(Middleware2()) // ç¬¬äºŒä¸ªæ‰§è¡Œ

    // è·¯ç”±ç»„ä¸­é—´ä»¶
    api := r.Group("/api")
    api.Use(Middleware3()) // ç¬¬ä¸‰ä¸ªæ‰§è¡Œ
    {
        // è·¯ç”±çº§ä¸­é—´ä»¶
        api.GET("/users", Middleware4(), handler) // ç¬¬å››ä¸ªæ‰§è¡Œï¼Œç„¶åæ˜¯handler
    }
}

func Middleware1() gin.HandlerFunc {
    return func(c *gin.Context) {
        fmt.Println("Middleware1 - Before")
        c.Next() // è°ƒç”¨ä¸‹ä¸€ä¸ªä¸­é—´ä»¶
        fmt.Println("Middleware1 - After")
    }
}

func Middleware2() gin.HandlerFunc {
    return func(c *gin.Context) {
        fmt.Println("Middleware2 - Before")
        c.Next()
        fmt.Println("Middleware2 - After")
    }
}

/*
æ‰§è¡Œé¡ºåºï¼š
1. Middleware1 - Before
2. Middleware2 - Before
3. Middleware3 - Before
4. Middleware4 - Before
5. Handler
6. Middleware4 - After
7. Middleware3 - After
8. Middleware2 - After
9. Middleware1 - After

åŸç†ï¼š
- Ginä½¿ç”¨handlersåˆ‡ç‰‡å­˜å‚¨ä¸­é—´ä»¶
- c.Next()è°ƒç”¨ä¸‹ä¸€ä¸ªhandler
- å½¢æˆç±»ä¼¼æ´‹è‘±æ¨¡å‹çš„æ‰§è¡Œç»“æ„
*/
```

### 3. æ•°æ®ç»‘å®šå’ŒéªŒè¯æœºåˆ¶

**é—®é¢˜ï¼š** Ginçš„æ•°æ®ç»‘å®šæœ‰å“ªäº›æ–¹å¼ï¼ŸéªŒè¯æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿ

**ç­”æ¡ˆï¼š**
```go
// æ•°æ®ç»‘å®šæ–¹å¼å¯¹æ¯”
func DataBindingComparison(c *gin.Context) {
    // 1. ShouldBind - è‡ªåŠ¨é€‰æ‹©ç»‘å®šæ–¹å¼ï¼Œä¸ä¼šæ”¹å˜c.Request.Body
    var user1 User
    if err := c.ShouldBind(&user1); err != nil {
        // å¤„ç†é”™è¯¯ï¼Œä½†ä¸ä¼šç»ˆæ­¢è¯·æ±‚
    }

    // 2. Bind - è‡ªåŠ¨é€‰æ‹©ç»‘å®šæ–¹å¼ï¼Œä¼šæ”¹å˜c.Request.Body
    var user2 User
    if err := c.Bind(&user2); err != nil {
        // è‡ªåŠ¨è¿”å›400é”™è¯¯å¹¶ç»ˆæ­¢è¯·æ±‚
        return
    }

    // 3. å…·ä½“ç»‘å®šæ–¹å¼
    var user3 User
    c.ShouldBindJSON(&user3)    // JSONç»‘å®š
    c.ShouldBindQuery(&user3)   // æŸ¥è¯¢å‚æ•°ç»‘å®š
    c.ShouldBindUri(&user3)     // URIå‚æ•°ç»‘å®š
    c.ShouldBindHeader(&user3)  // è¯·æ±‚å¤´ç»‘å®š
}

// éªŒè¯æ ‡ç­¾ä½¿ç”¨
type User struct {
    ID       uint   `json:"id"`
    Username string `json:"username" binding:"required,min=3,max=20"`
    Email    string `json:"email" binding:"required,email"`
    Age      int    `json:"age" binding:"gte=0,lte=130"`
    Password string `json:"password" binding:"required,min=6"`
    Phone    string `json:"phone" binding:"omitempty,len=11"`
}

/*
å¸¸ç”¨éªŒè¯æ ‡ç­¾ï¼š
- required: å¿…å¡«å­—æ®µ
- min/max: å­—ç¬¦ä¸²é•¿åº¦æˆ–æ•°å€¼èŒƒå›´
- gte/lte: å¤§äºç­‰äº/å°äºç­‰äº
- email: é‚®ç®±æ ¼å¼
- url: URLæ ¼å¼
- len: ç²¾ç¡®é•¿åº¦
- oneof: æšä¸¾å€¼
- dive: åˆ‡ç‰‡/æ•°ç»„å…ƒç´ éªŒè¯
*/
```

### 4. é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

**é—®é¢˜ï¼š** åœ¨Ginä¸­å¦‚ä½•ä¼˜é›…åœ°å¤„ç†é”™è¯¯ï¼Ÿ

**ç­”æ¡ˆï¼š**
```go
// ç»Ÿä¸€é”™è¯¯å¤„ç†ä¸­é—´ä»¶
func ErrorHandler() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Next()

        // å¤„ç†è¯·æ±‚è¿‡ç¨‹ä¸­çš„é”™è¯¯
        if len(c.Errors) > 0 {
            err := c.Errors.Last()

            switch err.Type {
            case gin.ErrorTypeBind:
                c.JSON(400, gin.H{
                    "error": "Invalid request data",
                    "details": err.Error(),
                })
            case gin.ErrorTypePublic:
                c.JSON(500, gin.H{
                    "error": err.Error(),
                })
            default:
                c.JSON(500, gin.H{
                    "error": "Internal server error",
                })
            }
        }
    }
}

// ä¸šåŠ¡é”™è¯¯å¤„ç†
type APIError struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
}

func (e APIError) Error() string {
    return e.Message
}

func HandleBusinessError(c *gin.Context, err error) {
    if apiErr, ok := err.(APIError); ok {
        c.JSON(apiErr.Code, apiErr)
        return
    }

    // è®°å½•æœªçŸ¥é”™è¯¯
    log.Printf("Unknown error: %v", err)
    c.JSON(500, gin.H{
        "error": "Internal server error",
    })
}
```

### 5. æ€§èƒ½ä¼˜åŒ–æŠ€å·§

**é—®é¢˜ï¼š** å¦‚ä½•ä¼˜åŒ–Ginåº”ç”¨çš„æ€§èƒ½ï¼Ÿ

**ç­”æ¡ˆï¼š**
```go
// æ€§èƒ½ä¼˜åŒ–æŠ€å·§

// 1. ä½¿ç”¨gin.ReleaseMode
func OptimizeForProduction() {
    gin.SetMode(gin.ReleaseMode)
    r := gin.New()

    // 2. è‡ªå®šä¹‰Loggerï¼ˆé¿å…é»˜è®¤çš„å½©è‰²è¾“å‡ºï¼‰
    r.Use(gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
        return fmt.Sprintf("%s - [%s] \"%s %s %s %d %s\"\n",
            param.ClientIP,
            param.TimeStamp.Format(time.RFC1123),
            param.Method,
            param.Path,
            param.Request.Proto,
            param.StatusCode,
            param.Latency,
        )
    }))

    // 3. ä½¿ç”¨è¿æ¥æ± 
    r.Use(func(c *gin.Context) {
        // è®¾ç½®è¿æ¥å¤ç”¨
        c.Header("Connection", "keep-alive")
        c.Next()
    })
}

// 4. ç¼“å­˜ä¸­é—´ä»¶
func CacheMiddleware(duration time.Duration) gin.HandlerFunc {
    cache := make(map[string]CacheEntry)
    mutex := sync.RWMutex{}

    return func(c *gin.Context) {
        if c.Request.Method != "GET" {
            c.Next()
            return
        }

        key := c.Request.URL.String()

        mutex.RLock()
        if entry, exists := cache[key]; exists {
            if time.Since(entry.Timestamp) < duration {
                mutex.RUnlock()
                c.Data(entry.StatusCode, entry.ContentType, entry.Body)
                c.Abort()
                return
            }
        }
        mutex.RUnlock()

        // ç»§ç»­å¤„ç†è¯·æ±‚...
        c.Next()
    }
}

// 5. é¢„ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼
var (
    phoneRegex = regexp.MustCompile(`^1[3-9]\d{9}$`)
    emailRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
)

func ValidatePhone(phone string) bool {
    return phoneRegex.MatchString(phone)
}
```

---

## âš ï¸ è¸©å‘æé†’

### 1. ä¸­é—´ä»¶ä½¿ç”¨é™·é˜±

```go
// âŒ é”™è¯¯ï¼šå¿˜è®°è°ƒç”¨c.Next()
func BadMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // åšä¸€äº›å¤„ç†
        fmt.Println("Processing...")
        // å¿˜è®°è°ƒç”¨c.Next()ï¼Œåç»­ä¸­é—´ä»¶å’Œå¤„ç†å™¨ä¸ä¼šæ‰§è¡Œ
    }
}

// âœ… æ­£ç¡®ï¼šè®°å¾—è°ƒç”¨c.Next()
func GoodMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        fmt.Println("Before processing")
        c.Next() // è°ƒç”¨ä¸‹ä¸€ä¸ªä¸­é—´ä»¶
        fmt.Println("After processing")
    }
}

// âŒ é”™è¯¯ï¼šåœ¨goroutineä¸­ä½¿ç”¨gin.Context
func BadAsyncHandler(c *gin.Context) {
    go func() {
        // å±é™©ï¼gin.Contextä¸æ˜¯goroutineå®‰å…¨çš„
        user := c.Param("user")
        // å¤„ç†å¼‚æ­¥é€»è¾‘...
    }()

    c.JSON(200, gin.H{"message": "Processing async"})
}

// âœ… æ­£ç¡®ï¼šå¤åˆ¶Contextç”¨äºå¼‚æ­¥å¤„ç†
func GoodAsyncHandler(c *gin.Context) {
    // å¤åˆ¶contextç”¨äºgoroutine
    cCp := c.Copy()

    go func() {
        // å®‰å…¨ä½¿ç”¨å¤åˆ¶çš„context
        user := cCp.Param("user")
        // å¤„ç†å¼‚æ­¥é€»è¾‘...
    }()

    c.JSON(200, gin.H{"message": "Processing async"})
}
```

### 2. æ•°æ®ç»‘å®šé™·é˜±

```go
// âŒ é”™è¯¯ï¼šé‡å¤ç»‘å®šåŒä¸€ä¸ªè¯·æ±‚ä½“
func BadBinding(c *gin.Context) {
    var user1 User
    c.Bind(&user1) // ç¬¬ä¸€æ¬¡ç»‘å®šï¼Œæ¶ˆè€—äº†è¯·æ±‚ä½“

    var user2 User
    c.Bind(&user2) // ç¬¬äºŒæ¬¡ç»‘å®šä¼šå¤±è´¥ï¼Œå› ä¸ºè¯·æ±‚ä½“å·²è¢«è¯»å–
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨ShouldBindæˆ–åªç»‘å®šä¸€æ¬¡
func GoodBinding(c *gin.Context) {
    var user User
    if err := c.ShouldBindJSON(&user); err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }

    // å¯ä»¥ç»§ç»­ä½¿ç”¨user...
}

// âŒ é”™è¯¯ï¼šéªŒè¯æ ‡ç­¾ä½¿ç”¨é”™è¯¯
type BadUser struct {
    Age int `json:"age" binding:"min=18"` // é”™è¯¯ï¼šminç”¨äºå­—ç¬¦ä¸²é•¿åº¦
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨æ­£ç¡®çš„éªŒè¯æ ‡ç­¾
type GoodUser struct {
    Age int `json:"age" binding:"gte=18"` // æ­£ç¡®ï¼šgteç”¨äºæ•°å€¼æ¯”è¾ƒ
}
```

### 3. è·¯ç”±å®šä¹‰é™·é˜±

```go
// âŒ é”™è¯¯ï¼šè·¯ç”±å†²çª
func BadRoutes(r *gin.Engine) {
    r.GET("/users/:id", getUserByID)
    r.GET("/users/profile", getUserProfile) // å†²çªï¼ä¼šè¢«/:idåŒ¹é…
}

// âœ… æ­£ç¡®ï¼šé¿å…è·¯ç”±å†²çª
func GoodRoutes(r *gin.Engine) {
    r.GET("/users/profile", getUserProfile) // å…·ä½“è·¯ç”±æ”¾åœ¨å‰é¢
    r.GET("/users/:id", getUserByID)        // å‚æ•°è·¯ç”±æ”¾åœ¨åé¢
}

// âŒ é”™è¯¯ï¼šå¿˜è®°å¤„ç†OPTIONSè¯·æ±‚
func BadCORS(r *gin.Engine) {
    r.Use(func(c *gin.Context) {
        c.Header("Access-Control-Allow-Origin", "*")
        c.Next()
    })
}

// âœ… æ­£ç¡®ï¼šæ­£ç¡®å¤„ç†CORS
func GoodCORS(r *gin.Engine) {
    r.Use(func(c *gin.Context) {
        c.Header("Access-Control-Allow-Origin", "*")
        c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization")

        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(204)
            return
        }

        c.Next()
    })
}
```

### 4. å†…å­˜æ³„æ¼é™·é˜±

```go
// âŒ é”™è¯¯ï¼šåœ¨ä¸­é—´ä»¶ä¸­åˆ›å»ºgoroutineä½†ä¸ç®¡ç†ç”Ÿå‘½å‘¨æœŸ
func BadAsyncMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        go func() {
            // é•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡ï¼Œå¯èƒ½å¯¼è‡´goroutineæ³„æ¼
            time.Sleep(time.Hour)
        }()
        c.Next()
    }
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨contextæ§åˆ¶goroutineç”Ÿå‘½å‘¨æœŸ
func GoodAsyncMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        ctx, cancel := context.WithTimeout(c.Request.Context(), time.Minute)
        defer cancel()

        go func() {
            select {
            case <-ctx.Done():
                return // åŠæ—¶é€€å‡º
            case <-time.After(time.Hour):
                // é•¿æ—¶é—´ä»»åŠ¡
            }
        }()

        c.Next()
    }
}
```

---

## ğŸ“ ç»ƒä¹ é¢˜

### ç»ƒä¹ é¢˜1ï¼šRESTful APIè®¾è®¡ï¼ˆâ­â­ï¼‰

**é¢˜ç›®æè¿°ï¼š**
è®¾è®¡ä¸€ä¸ªå›¾ä¹¦ç®¡ç†ç³»ç»Ÿçš„RESTful APIï¼ŒåŒ…å«å›¾ä¹¦çš„å¢åˆ æ”¹æŸ¥åŠŸèƒ½ï¼Œè¦æ±‚ä½¿ç”¨Ginæ¡†æ¶å®ç°ã€‚

```go
// ç»ƒä¹ é¢˜1ï¼šå›¾ä¹¦ç®¡ç†API
package main

import (
    "net/http"
    "strconv"
    "time"

    "github.com/gin-gonic/gin"
)

// å›¾ä¹¦ç»“æ„ä½“
type Book struct {
    ID          uint      `json:"id"`
    Title       string    `json:"title" binding:"required,max=200"`
    Author      string    `json:"author" binding:"required,max=100"`
    ISBN        string    `json:"isbn" binding:"required,len=13"`
    Price       float64   `json:"price" binding:"required,gt=0"`
    Stock       int       `json:"stock" binding:"gte=0"`
    Category    string    `json:"category" binding:"required"`
    PublishedAt time.Time `json:"published_at"`
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
}

// æ¨¡æ‹Ÿæ•°æ®åº“
var books = []Book{
    {
        ID: 1, Title: "Goè¯­è¨€å®æˆ˜", Author: "å¼ ä¸‰", ISBN: "9787111111111",
        Price: 89.0, Stock: 100, Category: "ç¼–ç¨‹", PublishedAt: time.Now(),
        CreatedAt: time.Now(), UpdatedAt: time.Now(),
    },
    {
        ID: 2, Title: "æ•°æ®ç»“æ„ä¸ç®—æ³•", Author: "æå››", ISBN: "9787111222222",
        Price: 79.0, Stock: 50, Category: "è®¡ç®—æœº", PublishedAt: time.Now(),
        CreatedAt: time.Now(), UpdatedAt: time.Now(),
    },
}

var nextID uint = 3

func main() {
    r := gin.Default()

    // è®¾ç½®è·¯ç”±
    api := r.Group("/api/v1")
    {
        books := api.Group("/books")
        {
            books.GET("", listBooks)           // GET /api/v1/books
            books.POST("", createBook)         // POST /api/v1/books
            books.GET("/:id", getBook)         // GET /api/v1/books/:id
            books.PUT("/:id", updateBook)      // PUT /api/v1/books/:id
            books.DELETE("/:id", deleteBook)   // DELETE /api/v1/books/:id
        }
    }

    r.Run(":8080")
}

// è·å–å›¾ä¹¦åˆ—è¡¨
func listBooks(c *gin.Context) {
    // æŸ¥è¯¢å‚æ•°
    category := c.Query("category")
    author := c.Query("author")
    pageStr := c.DefaultQuery("page", "1")
    limitStr := c.DefaultQuery("limit", "10")

    page, _ := strconv.Atoi(pageStr)
    limit, _ := strconv.Atoi(limitStr)

    // è¿‡æ»¤å›¾ä¹¦
    var filteredBooks []Book
    for _, book := range books {
        if category != "" && book.Category != category {
            continue
        }
        if author != "" && book.Author != author {
            continue
        }
        filteredBooks = append(filteredBooks, book)
    }

    // åˆ†é¡µ
    start := (page - 1) * limit
    end := start + limit
    if start > len(filteredBooks) {
        start = len(filteredBooks)
    }
    if end > len(filteredBooks) {
        end = len(filteredBooks)
    }

    result := filteredBooks[start:end]

    c.JSON(http.StatusOK, gin.H{
        "code": 200,
        "message": "success",
        "data": result,
        "pagination": gin.H{
            "page":  page,
            "limit": limit,
            "total": len(filteredBooks),
        },
    })
}

// åˆ›å»ºå›¾ä¹¦
func createBook(c *gin.Context) {
    var book Book
    if err := c.ShouldBindJSON(&book); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "code": 400,
            "message": "Invalid request data",
            "error": err.Error(),
        })
        return
    }

    // æ£€æŸ¥ISBNæ˜¯å¦å·²å­˜åœ¨
    for _, existingBook := range books {
        if existingBook.ISBN == book.ISBN {
            c.JSON(http.StatusConflict, gin.H{
                "code": 409,
                "message": "Book with this ISBN already exists",
            })
            return
        }
    }

    // è®¾ç½®IDå’Œæ—¶é—´æˆ³
    book.ID = nextID
    nextID++
    book.CreatedAt = time.Now()
    book.UpdatedAt = time.Now()

    // æ·»åŠ åˆ°"æ•°æ®åº“"
    books = append(books, book)

    c.JSON(http.StatusCreated, gin.H{
        "code": 201,
        "message": "Book created successfully",
        "data": book,
    })
}

// è·å–å•ä¸ªå›¾ä¹¦
func getBook(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "code": 400,
            "message": "Invalid book ID",
        })
        return
    }

    // æŸ¥æ‰¾å›¾ä¹¦
    for _, book := range books {
        if book.ID == uint(id) {
            c.JSON(http.StatusOK, gin.H{
                "code": 200,
                "message": "success",
                "data": book,
            })
            return
        }
    }

    c.JSON(http.StatusNotFound, gin.H{
        "code": 404,
        "message": "Book not found",
    })
}

// æ›´æ–°å›¾ä¹¦
func updateBook(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "code": 400,
            "message": "Invalid book ID",
        })
        return
    }

    var updateData Book
    if err := c.ShouldBindJSON(&updateData); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "code": 400,
            "message": "Invalid request data",
            "error": err.Error(),
        })
        return
    }

    // æŸ¥æ‰¾å¹¶æ›´æ–°å›¾ä¹¦
    for i, book := range books {
        if book.ID == uint(id) {
            // ä¿æŒåŸæœ‰çš„IDå’Œåˆ›å»ºæ—¶é—´
            updateData.ID = book.ID
            updateData.CreatedAt = book.CreatedAt
            updateData.UpdatedAt = time.Now()

            books[i] = updateData

            c.JSON(http.StatusOK, gin.H{
                "code": 200,
                "message": "Book updated successfully",
                "data": updateData,
            })
            return
        }
    }

    c.JSON(http.StatusNotFound, gin.H{
        "code": 404,
        "message": "Book not found",
    })
}

// åˆ é™¤å›¾ä¹¦
func deleteBook(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "code": 400,
            "message": "Invalid book ID",
        })
        return
    }

    // æŸ¥æ‰¾å¹¶åˆ é™¤å›¾ä¹¦
    for i, book := range books {
        if book.ID == uint(id) {
            books = append(books[:i], books[i+1:]...)
            c.JSON(http.StatusOK, gin.H{
                "code": 200,
                "message": "Book deleted successfully",
            })
            return
        }
    }

    c.JSON(http.StatusNotFound, gin.H{
        "code": 404,
        "message": "Book not found",
    })
}

/*
è§£æè¯´æ˜ï¼š
1. RESTfulè®¾è®¡ï¼šéµå¾ªRESTåŸåˆ™ï¼Œä½¿ç”¨HTTPæ–¹æ³•è¡¨ç¤ºæ“ä½œ
2. æ•°æ®éªŒè¯ï¼šä½¿ç”¨bindingæ ‡ç­¾è¿›è¡Œå‚æ•°éªŒè¯
3. é”™è¯¯å¤„ç†ï¼šç»Ÿä¸€çš„é”™è¯¯å“åº”æ ¼å¼
4. æŸ¥è¯¢åŠŸèƒ½ï¼šæ”¯æŒåˆ†é¡µå’Œè¿‡æ»¤
5. çŠ¶æ€ç ï¼šæ­£ç¡®ä½¿ç”¨HTTPçŠ¶æ€ç 

æ‰©å±•æ€è€ƒï¼š
- å¦‚ä½•æ·»åŠ æ•°æ®åº“æ”¯æŒï¼Ÿ
- å¦‚ä½•å®ç°æ›´å¤æ‚çš„æŸ¥è¯¢åŠŸèƒ½ï¼Ÿ
- å¦‚ä½•æ·»åŠ è®¤è¯å’Œæˆæƒï¼Ÿ
- å¦‚ä½•å®ç°APIç‰ˆæœ¬æ§åˆ¶ï¼Ÿ
*/
```

### ç»ƒä¹ é¢˜2ï¼šä¸­é—´ä»¶å¼€å‘ï¼ˆâ­â­â­ï¼‰

**é¢˜ç›®æè¿°ï¼š**
å¼€å‘ä¸€ä¸ªAPIè®¿é—®ç»Ÿè®¡ä¸­é—´ä»¶ï¼Œè®°å½•æ¯ä¸ªAPIçš„è®¿é—®æ¬¡æ•°ã€å“åº”æ—¶é—´å’Œé”™è¯¯ç‡ã€‚

```go
// ç»ƒä¹ é¢˜2ï¼šAPIç»Ÿè®¡ä¸­é—´ä»¶
package main

import (
    "fmt"
    "sync"
    "time"

    "github.com/gin-gonic/gin"
)

// APIç»Ÿè®¡æ•°æ®
type APIStats struct {
    Path         string        `json:"path"`
    Method       string        `json:"method"`
    Count        int64         `json:"count"`
    TotalTime    time.Duration `json:"total_time"`
    AvgTime      time.Duration `json:"avg_time"`
    ErrorCount   int64         `json:"error_count"`
    ErrorRate    float64       `json:"error_rate"`
    LastAccessed time.Time     `json:"last_accessed"`
}

// ç»Ÿè®¡ç®¡ç†å™¨
type StatsManager struct {
    stats map[string]*APIStats
    mutex sync.RWMutex
}

func NewStatsManager() *StatsManager {
    return &StatsManager{
        stats: make(map[string]*APIStats),
    }
}

// è®°å½•APIè®¿é—®
func (sm *StatsManager) Record(method, path string, duration time.Duration, isError bool) {
    sm.mutex.Lock()
    defer sm.mutex.Unlock()

    key := fmt.Sprintf("%s:%s", method, path)

    if stat, exists := sm.stats[key]; exists {
        stat.Count++
        stat.TotalTime += duration
        stat.AvgTime = stat.TotalTime / time.Duration(stat.Count)
        if isError {
            stat.ErrorCount++
        }
        stat.ErrorRate = float64(stat.ErrorCount) / float64(stat.Count) * 100
        stat.LastAccessed = time.Now()
    } else {
        errorCount := int64(0)
        if isError {
            errorCount = 1
        }

        sm.stats[key] = &APIStats{
            Path:         path,
            Method:       method,
            Count:        1,
            TotalTime:    duration,
            AvgTime:      duration,
            ErrorCount:   errorCount,
            ErrorRate:    float64(errorCount) * 100,
            LastAccessed: time.Now(),
        }
    }
}

// è·å–ç»Ÿè®¡æ•°æ®
func (sm *StatsManager) GetStats() map[string]*APIStats {
    sm.mutex.RLock()
    defer sm.mutex.RUnlock()

    result := make(map[string]*APIStats)
    for k, v := range sm.stats {
        result[k] = v
    }
    return result
}

// ç»Ÿè®¡ä¸­é—´ä»¶
func StatsMiddleware(statsManager *StatsManager) gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()

        // å¤„ç†è¯·æ±‚
        c.Next()

        // è®¡ç®—å“åº”æ—¶é—´
        duration := time.Since(start)

        // åˆ¤æ–­æ˜¯å¦ä¸ºé”™è¯¯
        isError := c.Writer.Status() >= 400

        // è®°å½•ç»Ÿè®¡
        statsManager.Record(c.Request.Method, c.FullPath(), duration, isError)
    }
}

// æµ‹è¯•ç¤ºä¾‹
func TestStatsMiddleware() {
    statsManager := NewStatsManager()

    r := gin.Default()
    r.Use(StatsMiddleware(statsManager))

    // æµ‹è¯•è·¯ç”±
    r.GET("/users", func(c *gin.Context) {
        time.Sleep(100 * time.Millisecond) // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
        c.JSON(200, gin.H{"message": "success"})
    })

    r.GET("/users/:id", func(c *gin.Context) {
        time.Sleep(50 * time.Millisecond)
        if c.Param("id") == "999" {
            c.JSON(404, gin.H{"error": "user not found"})
            return
        }
        c.JSON(200, gin.H{"id": c.Param("id")})
    })

    // ç»Ÿè®¡æŸ¥çœ‹æ¥å£
    r.GET("/stats", func(c *gin.Context) {
        stats := statsManager.GetStats()
        c.JSON(200, stats)
    })

    r.Run(":8080")
}

/*
è§£æè¯´æ˜ï¼š
1. å¹¶å‘å®‰å…¨ï¼šä½¿ç”¨sync.RWMutexä¿æŠ¤å…±äº«æ•°æ®
2. æ€§èƒ½ç›‘æ§ï¼šè®°å½•å“åº”æ—¶é—´å’Œé”™è¯¯ç‡
3. ç»Ÿè®¡åˆ†æï¼šè®¡ç®—å¹³å‡å“åº”æ—¶é—´å’Œè®¿é—®é¢‘ç‡
4. å®æ—¶æ›´æ–°ï¼šæ¯æ¬¡è¯·æ±‚éƒ½æ›´æ–°ç»Ÿè®¡æ•°æ®

æ‰©å±•æ€è€ƒï¼š
- å¦‚ä½•æŒä¹…åŒ–ç»Ÿè®¡æ•°æ®ï¼Ÿ
- å¦‚ä½•å®ç°ç»Ÿè®¡æ•°æ®çš„å®šæ—¶æ¸…ç†ï¼Ÿ
- å¦‚ä½•æ·»åŠ æ›´å¤šç»´åº¦çš„ç»Ÿè®¡ï¼Ÿ
- å¦‚ä½•å®ç°åˆ†å¸ƒå¼ç»Ÿè®¡ï¼Ÿ
*/
```

---

## ğŸ“š ç« èŠ‚æ€»ç»“

æ­å–œä½ å®Œæˆäº†Ginæ¡†æ¶å…¥é—¨ä¸å®è·µçš„å­¦ä¹ ï¼ğŸ‰ è®©æˆ‘ä»¬æ¥æ€»ç»“ä¸€ä¸‹è¿™ä¸€ç« çš„æ ¸å¿ƒå†…å®¹ã€‚

### ğŸ¯ æ ¸å¿ƒçŸ¥è¯†ç‚¹å›é¡¾

#### 1. Ginæ¡†æ¶åŸºç¡€ ğŸ—ï¸

```go
// Ginæ¡†æ¶çš„æ ¸å¿ƒç‰¹æ€§
/*
1. é«˜æ€§èƒ½è·¯ç”±ï¼šåŸºäºhttprouterï¼Œé›¶å†…å­˜åˆ†é…
2. ä¸­é—´ä»¶æ”¯æŒï¼šä¸°å¯Œçš„ä¸­é—´ä»¶ç”Ÿæ€å’Œè‡ªå®šä¹‰èƒ½åŠ›
3. æ•°æ®ç»‘å®šï¼šå¤šç§ç»‘å®šæ–¹å¼å’Œè‡ªåŠ¨éªŒè¯
4. JSONå¤„ç†ï¼šå†…ç½®JSONåºåˆ—åŒ–å’Œååºåˆ—åŒ–
5. é”™è¯¯å¤„ç†ï¼šä¼˜é›…çš„é”™è¯¯å¤„ç†æœºåˆ¶
6. é™æ€æ–‡ä»¶ï¼šå†…ç½®é™æ€æ–‡ä»¶æœåŠ¡
*/

// åŸºæœ¬ä½¿ç”¨æ¨¡å¼
r := gin.Default()
r.Use(middleware...)
r.GET("/path", handler)
r.Run(":8080")
```

#### 2. è·¯ç”±ç³»ç»Ÿè®¾è®¡ ğŸ›£ï¸

| è·¯ç”±ç±»å‹ | è¯­æ³• | ç”¨é€” |
|---------|------|------|
| **é™æ€è·¯ç”±** | `/users` | å›ºå®šè·¯å¾„ |
| **å‚æ•°è·¯ç”±** | `/users/:id` | åŠ¨æ€å‚æ•° |
| **é€šé…ç¬¦è·¯ç”±** | `/files/*path` | è·¯å¾„åŒ¹é… |
| **è·¯ç”±ç»„** | `r.Group("/api")` | è·¯ç”±åˆ†ç»„ |

#### 3. ä¸­é—´ä»¶æœºåˆ¶ ğŸ”§

```go
// ä¸­é—´ä»¶æ‰§è¡Œæ¨¡å‹ï¼ˆæ´‹è‘±æ¨¡å‹ï¼‰
func Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // å‰ç½®å¤„ç†
        c.Next() // è°ƒç”¨ä¸‹ä¸€ä¸ªä¸­é—´ä»¶
        // åç½®å¤„ç†
    }
}

// ä¸­é—´ä»¶ç±»å‹
- å…¨å±€ä¸­é—´ä»¶ï¼šr.Use()
- è·¯ç”±ç»„ä¸­é—´ä»¶ï¼šgroup.Use()
- è·¯ç”±çº§ä¸­é—´ä»¶ï¼šr.GET("/path", middleware, handler)
```

#### 4. æ•°æ®å¤„ç†èƒ½åŠ› ğŸ“

```go
// æ•°æ®ç»‘å®šæ–¹å¼å¯¹æ¯”
c.ShouldBind()      // è‡ªåŠ¨é€‰æ‹©ï¼Œä¸æ”¹å˜Body
c.Bind()            // è‡ªåŠ¨é€‰æ‹©ï¼Œæ”¹å˜Body
c.ShouldBindJSON()  // JSONç»‘å®š
c.ShouldBindQuery() // æŸ¥è¯¢å‚æ•°ç»‘å®š
c.ShouldBindUri()   // URIå‚æ•°ç»‘å®š

// éªŒè¯æ ‡ç­¾
type User struct {
    Name  string `binding:"required,min=3,max=20"`
    Email string `binding:"required,email"`
    Age   int    `binding:"gte=0,lte=130"`
}
```

### ğŸš€ Gin vs å…¶ä»–æ¡†æ¶ä¼˜åŠ¿

#### ä¸Java Spring Bootå¯¹æ¯”
- **æ€§èƒ½**ï¼šGinå“åº”é€Ÿåº¦æ›´å¿«ï¼Œå†…å­˜å ç”¨æ›´å°‘
- **ç®€æ´æ€§**ï¼šä»£ç æ›´ç®€æ´ï¼Œå­¦ä¹ æ›²çº¿æ›´å¹³ç¼“
- **éƒ¨ç½²**ï¼šå•æ–‡ä»¶éƒ¨ç½²ï¼Œæ— éœ€JVMç¯å¢ƒ
- **å¹¶å‘**ï¼šåŸç”Ÿgoroutineæ”¯æŒï¼Œå¹¶å‘æ€§èƒ½ä¼˜å¼‚

#### ä¸Python Flaskå¯¹æ¯”
- **ç±»å‹å®‰å…¨**ï¼šç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥ï¼Œè¿è¡Œæ—¶æ›´ç¨³å®š
- **æ€§èƒ½**ï¼šæ‰§è¡Œæ•ˆç‡æ›´é«˜ï¼ŒGCå‹åŠ›æ›´å°
- **å¹¶å‘**ï¼šå†…ç½®å¹¶å‘æ”¯æŒï¼Œæ— éœ€é¢å¤–é…ç½®
- **ç”Ÿæ€**ï¼šGoç”Ÿæ€ç³»ç»Ÿå¿«é€Ÿå‘å±•ï¼Œå·¥å…·é“¾å®Œå–„

### ğŸ“ å®æˆ˜æŠ€èƒ½æŒæ¡

#### âœ… å·²æŒæ¡çš„æ ¸å¿ƒæŠ€èƒ½

1. **APIè®¾è®¡èƒ½åŠ›**
   - RESTful APIè®¾è®¡åŸåˆ™
   - è·¯ç”±ç»„ç»‡å’Œç‰ˆæœ¬æ§åˆ¶
   - ç»Ÿä¸€å“åº”æ ¼å¼è®¾è®¡

2. **ä¸­é—´ä»¶å¼€å‘**
   - è®¤è¯æˆæƒä¸­é—´ä»¶
   - æ—¥å¿—è®°å½•ä¸­é—´ä»¶
   - é”™è¯¯å¤„ç†ä¸­é—´ä»¶
   - æ€§èƒ½ç›‘æ§ä¸­é—´ä»¶

3. **æ•°æ®å¤„ç†æŠ€å·§**
   - è¯·æ±‚å‚æ•°éªŒè¯
   - æ–‡ä»¶ä¸Šä¼ å¤„ç†
   - æ•°æ®ç»‘å®šå’Œè½¬æ¢
   - é”™è¯¯ä¿¡æ¯å¤„ç†

4. **å®‰å…¨å®è·µ**
   - JWTè®¤è¯å®ç°
   - CORSè·¨åŸŸå¤„ç†
   - è¯·æ±‚é™æµæ§åˆ¶
   - è¾“å…¥æ•°æ®éªŒè¯

### ğŸ”— ä¸å‰é¢ç« èŠ‚çš„çŸ¥è¯†è¿æ¥

#### ä¸åŸºç¡€ç¯‡çš„è”ç³»
- **ç»“æ„ä½“åº”ç”¨**ï¼šå®šä¹‰è¯·æ±‚/å“åº”ç»“æ„ä½“
- **æ¥å£ä½¿ç”¨**ï¼šä¸­é—´ä»¶å’Œå¤„ç†å™¨æ¥å£
- **é”™è¯¯å¤„ç†**ï¼šWebåº”ç”¨çš„é”™è¯¯å¤„ç†å®è·µ
- **å¹¶å‘ç¼–ç¨‹**ï¼šå¼‚æ­¥å¤„ç†å’Œgoroutineåº”ç”¨

#### ä¸è¿›é˜¶ç¯‡çš„è”ç³»
- **æ¥å£è®¾è®¡**ï¼šHTTPå¤„ç†å™¨æ¥å£è®¾è®¡
- **ä¾èµ–æ³¨å…¥**ï¼šæœåŠ¡å±‚ä¾èµ–ç®¡ç†
- **è®¾è®¡æ¨¡å¼**ï¼šä¸­é—´ä»¶æ¨¡å¼ã€è£…é¥°å™¨æ¨¡å¼
- **æ€§èƒ½ä¼˜åŒ–**ï¼šWebåº”ç”¨æ€§èƒ½è°ƒä¼˜

### ğŸ¯ ä¸‹ä¸€æ­¥å­¦ä¹ å»ºè®®

#### ç«‹å³å®è·µ (æœ¬å‘¨å†…)
1. **å®Œæˆç»ƒä¹ é¢˜**ï¼šå®ç°å›¾ä¹¦ç®¡ç†APIå’Œç»Ÿè®¡ä¸­é—´ä»¶
2. **æ­å»ºé¡¹ç›®**ï¼šåˆ›å»ºä¸€ä¸ªå®Œæ•´çš„Webåº”ç”¨é¡¹ç›®
3. **é›†æˆæ•°æ®åº“**ï¼šå­¦ä¹ GORMé›†æˆå’Œæ•°æ®åº“æ“ä½œ

#### æ·±å…¥å­¦ä¹  (æœ¬æœˆå†…)
1. **å¾®æœåŠ¡æ¶æ„**ï¼šå­¦ä¹ æœåŠ¡æ‹†åˆ†å’Œé€šä¿¡
2. **å®¹å™¨åŒ–éƒ¨ç½²**ï¼šDockerå’ŒKuberneteså®è·µ
3. **ç›‘æ§æ—¥å¿—**ï¼šé›†æˆPrometheuså’ŒELKæ ˆ
4. **æµ‹è¯•æŠ€å·§**ï¼šå•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•

#### é«˜çº§è¿›é˜¶ (é•¿æœŸç›®æ ‡)
1. **åˆ†å¸ƒå¼ç³»ç»Ÿ**ï¼šæœåŠ¡å‘ç°ã€é…ç½®ä¸­å¿ƒã€é“¾è·¯è¿½è¸ª
2. **é«˜å¹¶å‘å¤„ç†**ï¼šç¼“å­˜ç­–ç•¥ã€æ•°æ®åº“ä¼˜åŒ–ã€è´Ÿè½½å‡è¡¡
3. **DevOpså®è·µ**ï¼šCI/CDæµæ°´çº¿ã€è‡ªåŠ¨åŒ–éƒ¨ç½²
4. **å¼€æºè´¡çŒ®**ï¼šå‚ä¸Go Webæ¡†æ¶å¼€æºé¡¹ç›®

### ğŸŒŸ Ginæ¡†æ¶æœ€ä½³å®è·µæ€»ç»“

#### ğŸ—ï¸ é¡¹ç›®ç»“æ„
```
project/
â”œâ”€â”€ cmd/           # åº”ç”¨å…¥å£
â”œâ”€â”€ internal/      # ç§æœ‰ä»£ç 
â”‚   â”œâ”€â”€ handler/   # HTTPå¤„ç†å™¨
â”‚   â”œâ”€â”€ service/   # ä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ model/     # æ•°æ®æ¨¡å‹
â”‚   â””â”€â”€ middleware/ # ä¸­é—´ä»¶
â”œâ”€â”€ pkg/           # å…¬å…±åº“
â””â”€â”€ configs/       # é…ç½®æ–‡ä»¶
```

#### ğŸ”§ å¼€å‘è§„èŒƒ
- **ç»Ÿä¸€å“åº”æ ¼å¼**ï¼šä½¿ç”¨æ ‡å‡†çš„APIå“åº”ç»“æ„
- **é”™è¯¯å¤„ç†**ï¼šå®ç°ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æœºåˆ¶
- **å‚æ•°éªŒè¯**ï¼šä½¿ç”¨bindingæ ‡ç­¾è¿›è¡Œæ•°æ®éªŒè¯
- **ä¸­é—´ä»¶å¤ç”¨**ï¼šå¼€å‘å¯å¤ç”¨çš„ä¸­é—´ä»¶ç»„ä»¶
- **æ€§èƒ½ç›‘æ§**ï¼šé›†æˆæ€§èƒ½ç›‘æ§å’Œæ—¥å¿—è®°å½•

#### ğŸš€ æ€§èƒ½ä¼˜åŒ–
- **ä½¿ç”¨ReleaseMode**ï¼šç”Ÿäº§ç¯å¢ƒå…³é—­è°ƒè¯•ä¿¡æ¯
- **è¿æ¥æ± é…ç½®**ï¼šåˆç†é…ç½®æ•°æ®åº“è¿æ¥æ± 
- **ç¼“å­˜ç­–ç•¥**ï¼šå®ç°å¤šå±‚ç¼“å­˜æœºåˆ¶
- **å¼‚æ­¥å¤„ç†**ï¼šä½¿ç”¨goroutineå¤„ç†è€—æ—¶æ“ä½œ
- **èµ„æºç®¡ç†**ï¼šåŠæ—¶é‡Šæ”¾èµ„æºï¼Œé¿å…å†…å­˜æ³„æ¼

### ğŸ‰ å­¦ä¹ æˆæœå±•ç¤º

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œä½ å·²ç»æŒæ¡äº†ï¼š

#### ğŸ“– ç†è®ºçŸ¥è¯†
- Ginæ¡†æ¶çš„è®¾è®¡ç†å¿µå’Œæ ¸å¿ƒç‰¹æ€§
- Webå¼€å‘çš„æœ€ä½³å®è·µå’Œè®¾è®¡æ¨¡å¼
- RESTful APIè®¾è®¡åŸåˆ™å’Œå®ç°æ–¹æ³•
- ä¸­é—´ä»¶æœºåˆ¶å’Œè‡ªå®šä¹‰å¼€å‘æŠ€å·§

#### ğŸ› ï¸ å®è·µæŠ€èƒ½
- å®Œæ•´Webåº”ç”¨çš„å¼€å‘èƒ½åŠ›
- ä¸­é—´ä»¶çš„è®¾è®¡å’Œå®ç°èƒ½åŠ›
- APIæ¥å£çš„è®¾è®¡å’Œä¼˜åŒ–èƒ½åŠ›
- é”™è¯¯å¤„ç†å’Œæ•°æ®éªŒè¯æŠ€å·§

#### ğŸ—ï¸ æ¶æ„èƒ½åŠ›
- Webåº”ç”¨æ¶æ„è®¾è®¡
- æœåŠ¡å±‚æŠ½è±¡å’Œç»„ç»‡
- å®‰å…¨è®¤è¯å’Œæˆæƒå®ç°
- æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–ç­–ç•¥

#### ğŸ¯ é¢è¯•å‡†å¤‡
- Ginæ¡†æ¶ç›¸å…³é¢è¯•é¢˜
- Webå¼€å‘æœ€ä½³å®è·µ
- æ€§èƒ½ä¼˜åŒ–æŠ€å·§
- å®é™…é¡¹ç›®ç»éªŒåˆ†äº«

æ­å–œä½ å·²ç»æˆä¸ºGin Webå¼€å‘çš„ä¸“å®¶ï¼ğŸŠ

ç»§ç»­ä½ çš„Goè¯­è¨€å­¦ä¹ ä¹‹æ—…ï¼Œä¸‹ä¸€ç« æˆ‘ä»¬å°†æ·±å…¥å­¦ä¹ GORMæ•°æ®åº“æ“ä½œï¼Œæ„å»ºå®Œæ•´çš„æ•°æ®æŒä¹…åŒ–è§£å†³æ–¹æ¡ˆã€‚åŠ æ²¹ï¼ğŸš€âœ¨
```
```
```
```
```
```
```
```
```
```
